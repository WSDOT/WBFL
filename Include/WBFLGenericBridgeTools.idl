///////////////////////////////////////////////////////////////////////
// GenericBridgeTools - Tools for manipluating the Generic Bridge Modeling
// Copyright © 1999-2014  Washington State Department of Transportation
//                        Bridge and Structures Office
//
// This library is a part of the Washington Bridge Foundation Libraries
// and was developed as part of the Alternate Route Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the Alternate Route Library Open Source License as 
// published by the Washington State Department of Transportation,
// Bridge and Structures Office.
//
// This program is distributed in the hope that it will be useful,
// but is distributed AS IS, WITHOUT ANY WARRANTY; without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
// PURPOSE.  See the Alternate Route Library Open Source License for more details.
//
// You should have received a copy of the Alternate Route Library Open Source License
// along with this program; if not, write to the Washington State
// Department of Transportation, Bridge and Structures Office,
// P.O. Box 47340, Olympia, WA 98503, USA or e-mail
// Bridge_Support@wsdot.wa.gov
///////////////////////////////////////////////////////////////////////

// GenericBridgeTools.idl : IDL source for GenericBridgeTools.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (GenericBridgeTools.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";
import "WBFLTypes.idl";
import "WBFLTools.idl";
import "WBFLUnitServer.idl";
import "WBFLGeometry.idl";
import "WBFLSections.idl";
import "WBFLCogo.idl";
import "WBFLBridgeGeometry.idl";
//import "WBFLGenericBridge.idl";

cpp_quote("#include <WBFLGenericBridge.h>")
cpp_quote("#define GBMT_E_UNKNOWNDECKTYPE             MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,512)")
cpp_quote("#define GBMT_E_GIRDERSECTION               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,513)")
cpp_quote("#define GBMT_E_NODECK                      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,514)")
cpp_quote("#define GBMT_E_COMPOSITEDECK               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,515)")
cpp_quote("#define GBMT_E_MATERIAL                    MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,516)")
cpp_quote("#define GBMT_E_SHAPE                       MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,517)")
cpp_quote("#define GBMT_E_REMOVEDEBOND                MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,518)")

[
	uuid(B7AEBB77-85BC-4FB0-BD1F-1078DB8FF85E),
	version(1.0),
	helpstring("WBFLGenericBridgeTools Library")
]
library WBFLGenericBridgeTools
{
	importlib("stdole32.tlb");
	importlib("stdole2.tlb");
   importlib("WBFLGenericBridge.tlb");

   interface IPrecastGirder;

   typedef [public,helpstring("enum LayoutPosition"),uuid(9246CAAE-3CAD-401f-BB00-0DA5EFA41EE2)]
   enum 
   {
	   lpLeft,
	   lpCenter,
	   lpRight
   } LayoutPosition;

   typedef [public,helpstring("enum SectionPropertyMethod"),uuid(B7DC993C-340A-4fb0-A058-6286F9C890B7)]
   enum
   {
      spmGross,
      spmTransformed,
      spmNet
   } SectionPropertyMethod;

   typedef [public,helpstring("enum HarpPointReference"),uuid(9744FFFE-8025-422e-A4C3-9A58B48DD102)] 
   enum 
   {
       hprEndOfGirder    = 0,
	   hprBearing        = 1,
	   hprCenterOfGirder = 2,
   } HarpPointReference;

   typedef [public,helpstring("enum HarpPointMeasure"),uuid(97051264-41BA-4691-9C4E-CDE659BB2C5A)] 
   enum 
   {
       hpmFractionOfSpanLength   = 0,
	   hpmFractionOfGirderLength = 1,
	   hpmAbsoluteDistance       = 2
   } HarpPointMeasure;

   typedef [public,helpstring("enum BarrierSectionCut"),uuid(B87307A0-81D1-41e5-A115-E1CAB0E39A43)]
   enum 
   {
      bscNone,  // don't include barrier in section cut
	  bscStructurallyContinuousOnly, // include only the structurally continuous portion of the barrier
	  bscAll // enclude all components of the barrier
   } BarrierSectionCut;


	[
		object,
		uuid(B887911C-EC53-4f32-B5E2-9D43C1F8D977),
		oleautomation,
		helpstring("IFlexRebarLayoutItem Interface"),
		pointer_default(unique)
	]
	interface IFlexRebarLayoutItem : IRebarLayoutItem
	{
	   [propget,helpstring("property Position")] HRESULT Position([out,retval] LayoutPosition* lp);
	   [propput,helpstring("property Position")] HRESULT Position([in] LayoutPosition lp);
	   [propget,helpstring("property LengthFactor")] HRESULT LengthFactor([out,retval] Float64* lf);
	   [propput,helpstring("property LengthFactor")] HRESULT LengthFactor([in] Float64 lf);
	   [propputref,helpstring("property Girder")] HRESULT Girder([in]IPrecastGirder* girder);
	};

	[
		object,
		oleautomation,
		uuid(B3D076FB-B0B0-4791-ADCF-BE1826640996),
		helpstring("SectionCutTool Interface"),
		pointer_default(unique)
	]
	interface ISectionCutTool : IUnknown
	{
      // EffectiveFlangeWidthTool is used to compute the width of the deck when creating shapes and sections
      // after the deck has become composite
	   [propputref,helpstring("property EffectiveFlangeWidthTool")] HRESULT EffectiveFlangeWidthTool([in] IEffectiveFlangeWidthTool* pTool);
	   [propget,helpstring("property EffectiveFlangeWidthTool")] HRESULT EffectiveFlangeWidthTool([out,retval] IEffectiveFlangeWidthTool* *pTool);

      // The "section" methods create a structural section from which stiffness properties can be determined
      // Bridge and Barrier sections are always gross sections
      [helpstring("method CreateGirderSectionBySSMbr")] HRESULT CreateGirderSectionBySSMbr([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]Float64 Xgp,[in]GirderIDType leftSSMbrID,[in]GirderIDType rightSSMbrID,[in] StageIndexType stageIdx, [in] SectionPropertyMethod sectionPropMethod,[out,retval]ISection** section);
	   [helpstring("method CreateGirderSectionBySegment")] HRESULT CreateGirderSectionBySegment([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx,[in]Float64 Xs,[in]GirderIDType leftSSMbrID,[in]GirderIDType rightSSMbrID,[in] StageIndexType stageIdx, [in] SectionPropertyMethod sectionPropMethod,[out,retval]ISection** section);
	   [helpstring("method CreateBridgeSection")] HRESULT CreateBridgeSection([in]IGenericBridge* bridge,[in]Float64 distFromStartOfBridge,[in] StageIndexType stageIdx, [in] BarrierSectionCut bsc,[out,retval]ISection** section);
	   [helpstring("method CreateLeftBarrierSection")] HRESULT CreateLeftBarrierSection([in]IGenericBridge* bridge,[in] Float64 station,[in] VARIANT_BOOL bStructuralOnly,[out,retval]ISection** section);
	   [helpstring("method CreateRightBarrierSection")] HRESULT CreateRightBarrierSection([in]IGenericBridge* bridge,[in] Float64 station,[in] VARIANT_BOOL bStructuralOnly,[out,retval]ISection** section);

      [helpstring("method CreateNetDeckSection")] HRESULT CreateNetDeckSection([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx,[in]Float64 Xs,[in]GirderIDType leftSSMbrID,[in]GirderIDType rightSSMbrID,[in]StageIndexType stageIdx,[out,retval]ISection** section);

      // The "shape" methods create a shape object that is typically used for creating a graphical representations of the girder or bridge
      [helpstring("method CreateGirderShapeBySSMbr")] HRESULT CreateGirderShapeBySSMbr([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]Float64 Xgp,[in]GirderIDType leftSSMbrID,[in]GirderIDType rightSSMbrID,[in] StageIndexType stageIdx, [out,retval]IShape** ppShape);
	   [helpstring("method CreateGirderShapeBySegment")] HRESULT CreateGirderShapeBySegment([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx,[in]Float64 Xs,[in]GirderIDType leftSSMbrID,[in]GirderIDType rightSSMbrID,[in] StageIndexType stageIdx, [out,retval]IShape** ppShape);
	   [helpstring("method CreateLeftBarrierShape")] HRESULT CreateLeftBarrierShape([in]IGenericBridge* bridge,[in] Float64 station,[out,retval]IShape** shape);
	   [helpstring("method CreateRightBarrierShape")] HRESULT CreateRightBarrierShape([in]IGenericBridge* bridge,[in] Float64 station,[out,retval]IShape** shape);
      [helpstring("method CreateSlabShape")] HRESULT CreateSlabShape([in]IGenericBridge* bridge,[in]Float64 station,[out,retval]IShape** shape);
	};

   // This interface tells how to move harped strands when they are offset
	[
		object,
		oleautomation,
		uuid(0FAD048E-8F77-472a-B2BF-7ED599FA765D),
		helpstring("IStrandMover Interface"),
		pointer_default(unique)
	]
	interface IStrandMover : IUnknown 
	{
      // Top elevation of girder in strand coords (note that cover is below this).
	   [propget, helpstring("property TopElevation")] HRESULT TopElevation([out, retval]Float64* topElev);

      // Max/min Y locations for harped prestressing strands within section at harping points and ends
	   [propget, helpstring("property HpStrandElevationBoundaries")] HRESULT HpStrandElevationBoundaries([out]Float64* bottomMin,[out]Float64* topMax);
	   [propget, helpstring("property EndStrandElevationBoundaries")] HRESULT EndStrandElevationBoundaries([out]Float64* bottomMin,[out]Float64* topMax);

      // default increments for moving strands
	   [propget, helpstring("property StrandIncrements")] HRESULT StrandIncrements([out]Float64* endIncrement,[out]Float64* hpIncrement);

      // Test if a strand location is within valid bounds 
	   [helpstring("method TestHpStrandLocation")] HRESULT TestHpStrandLocation([in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]VARIANT_BOOL* isWithin);
	   [helpstring("method TestEndStrandLocation")] HRESULT TestEndStrandLocation([in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]VARIANT_BOOL* isWithin);

      // Based on an original location and a Y offset, compute the new strand location
	   [helpstring("method TranslateStrand")] HRESULT TranslateStrand([in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]Float64* newX, [out]Float64* newY );
   }

   // Definitions:
   // Strand Grid: A condensed grid of potential strand locations. All x values are 0.0 or more.
   //              For x > 0.0, there is assumed to be a second potiential strand location at -x
   // Strand Grid Index: Index into the condensed strand grid
   // Strand Position: The position of a strand in the fully expanded strand grid
   //                  Strand positions correspond to the strand fill sequence numbers you'll find
   //                  on girder plans. The strands in a girder can be at position 0,1,6,7,10,11
   // Strand Index: Zero based index into the list of strands used in a girder.
   //               For the example given above, we have
   //               index 0 -> strand position 0
   //               index 1 -> strand position 1
   //               index 2 -> strand position 6
   //               index 3 -> strand position 7
   //               index 4 -> strand position 10
   //               index 5 -> strand position 11

	[
		object,
		oleautomation,
		uuid(656F5032-BB18-4644-911A-CD4672EBA5B0),
		helpstring("IStrandGrid Interface"),
		pointer_default(unique)
	]
	interface IStrandGrid : IUnknown
	{
      // Grid points represent holes where strands can go
      // Grid points use a compacted numbering sequence where points with positive X values
      // are placed symmetrically (e.g., represent two actual strand locations)
	   [helpstring("method AddGridPoint")] HRESULT AddGridPoint([in]IPoint2d* point);
	   [helpstring("method AddGridPoints")] HRESULT AddGridPoints([in]IPoint2dCollection* points);
	   [propget, helpstring("property GridPointCount")] HRESULT GridPointCount([out,retval]GridIndexType* count);
	   [propget, helpstring("property GridPoint")] HRESULT GridPoint([in] GridIndexType idx,[out,retval]IPoint2d** point);
	   [propget, helpstring("property GridPoints")] HRESULT GridPoints([out,retval]IPoint2dCollection** point);
	   [helpstring("method RemoveGridPoint")] HRESULT RemoveGridPoint([in] GridIndexType idx);
	   [helpstring("method ClearGridPoints")] HRESULT ClearGridPoints();

	   [helpstring("method GridBoundingBox")] HRESULT GridBoundingBox([out,retval]IRect2d** box);
    }


	[
		object,
		oleautomation,
		uuid(E5DF8437-92B8-4d3e-A3F5-71E46214571D),
		helpstring("IStrandGridFiller Interface"),
		pointer_default(unique)
	]
	interface IStrandGridFiller : IUnknown
	{
      // Functions below have to do with filling of grid points and query for filled strands
      // This is a mostly private interface to facilitate use of the strand grid.
      
      // Max number strands that can be filled
      [propget,helpstring("property MaxStrandCount")] HRESULT MaxStrandCount([out,retval]StrandIndexType* count);

      // Returns a vector of integers GridPointCount long indicating the max number of strands
      // that normally can be placed at each Grid point (1 - if X==0.0, or 2 - if X>0.0)
      [helpstring("method GetMaxStrandFill")] HRESULT GetMaxStrandFill([out,retval]IIndexArray** maxFill);

      // Set or get vector of integers indicated number of strands filled at each Grid point
      // Possible values are 0, 1, or 2. Length of vector is GridPointCount
      // If Grid point has positive X value and 1 is input, the strand is placed at X=0.0
      // If Grid point has zero X value and 2 is input, two strands are placed at X=0.0
      [propget, helpstring("property StrandFill")] HRESULT StrandFill([out,retval]IIndexArray** fill);
      [propput, helpstring("property StrandFill")] HRESULT StrandFill([in]IIndexArray* fill);

	   [helpstring("method RemoveAllStrands")] HRESULT RemoveAllStrands();

      // Set the strand mover. By default strands just move up or down
      [propput, helpstring("property StrandMover")] HRESULT StrandMover([in]IStrandMover* mover);

      // adjust strands upward or downward (up is positive)
      [propget, helpstring("property VerticalStrandAdjustment")] HRESULT VerticalStrandAdjustment([out,retval]Float64* adjust);
      [propput, helpstring("property VerticalStrandAdjustment")] HRESULT VerticalStrandAdjustment([in]Float64 adjust);

      // Return number of currently filled strand locations
	   [helpstring("method GetStrandCount")] HRESULT GetStrandCount([out,retval] StrandIndexType* count);

      // Returns a collection of all currently filled strand locations
      // index 0 in the collection corresponds to strandIndex = 0, index 1 -> strandIndex = 1, etc
	   [helpstring("method GetStrandPositions")] HRESULT GetStrandPositions([out,retval]IPoint2dCollection** points);

      // Convert strand index (defined in IPoint2dCollection's above) to/from Grid index
      [helpstring("method StrandIndexToGridIndex")] HRESULT StrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      // can possibly have one or two strands per grid index. If only one, strandIndex2==INVALID_INDEX
      [helpstring("method GridIndexToStrandIndex")] HRESULT GridIndexToStrandIndex([in] GridIndexType gridIndex, [out] StrandIndexType* strandIndex1, [out] StrandIndexType* strandIndex2);

      // Return CG and bounding box of currently filled strands - adjused for vertical adjustment
	   [propget,helpstring("property CG")] HRESULT CG([out]Float64* cgx, [out]Float64* cgy);
	   [propget,helpstring("property StrandBoundingBox")] HRESULT StrandBoundingBox([out,retval]IRect2d** box);

      // Unadjusted upper and lower bounds for currently filled grid
      // returns zeros if no strands in fill
	   [propget,helpstring("property FilledGridBounds")] HRESULT FilledGridBounds([out]Float64* bottomElev, [out]Float64* topElev);

	   [propget,helpstring("property RowsWithStrand")] HRESULT RowsWithStrand([out,retval]RowIndexType* nRows);
	   [propget,helpstring("property StrandsInRow")] HRESULT StrandsInRow([in]RowIndexType rowIdx,[out,retval]IIndexArray** gridIndexes);
	   [propget,helpstring("property NumStrandsInRow")] HRESULT NumStrandsInRow([in]RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);

      // Ex methods are typically for testing a new fill.
      // they allow input of a temporary fill array. Internal fill array is not changed
	   [helpstring("method GetStrandCountEx")] HRESULT GetStrandCountEx([in]IIndexArray* fill, [out,retval] StrandIndexType* count);
	   [helpstring("method GetStrandPositionsEx")] HRESULT GetStrandPositionsEx([in]IIndexArray* fill, [out,retval]IPoint2dCollection** points);
	   [propget,helpstring("property CGEx")] HRESULT CGEx([in]IIndexArray* fill, [out]Float64* cgx, [out]Float64* cgy);
	   [propget,helpstring("property StrandBoundingBoxEx")] HRESULT StrandBoundingBoxEx([in]IIndexArray* fill, [out,retval]IRect2d** box);
      [helpstring("method StrandIndexToGridIndexEx")] HRESULT StrandIndexToGridIndexEx([in]IIndexArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
	   [propget,helpstring("property FilledGridBoundsEx")] HRESULT FilledGridBoundsEx([in]IIndexArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);

      // Debonding - could go into another interface, but it's handy to have it here
      // rough count of debonded strands at current fill
      [helpstring("method GetStrandDebondCount")] HRESULT GetStrandDebondCount([out,retval] StrandIndexType* count);

      // Debond  strands based on Grid index
      [helpstring("method DebondStrandByGridIndex")] HRESULT DebondStrandByGridIndex([in]GridIndexType grdIndex,[in]Float64 l1,[in]Float64 l2);
      [helpstring("method GetDebondedStrandsByGridIndex")] HRESULT GetDebondedStrandsByGridIndex([out,retval]IIndexArray** grdIndexes);
      [helpstring("method GetDebondLengthByGridIndex")] HRESULT GetDebondLengthByGridIndex([in]GridIndexType grdIndex, [out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);

      // Debonded  strands based on Positions index (i.e., from GetStrandPositions)
      [helpstring("method GetDebondLengthByPositionIndex")] HRESULT GetDebondLengthByPositionIndex([in]StrandIndexType positionIndex,[out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);
      [helpstring("method GetStrandsDebondedByPositionIndex")] HRESULT GetStrandsDebondedByPositionIndex([in]Float64 distFromStart, [in]Float64 girderLength, [out,retval]IIndexArray** positionIndexes);

      // Distance that a strand is bonded (left and right) for a given location. Also returns strand's Y coordinate
      // Note that versions are for position and grid indexing
      [helpstring("method GetBondedLengthByPositionIndex")] HRESULT GetBondedLengthByPositionIndex([in]StrandIndexType positionIndex, [in]Float64 distFromStart, [in]Float64 girderLength,
                                                                             [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);

      [helpstring("method GetBondedLengthByGridIndex")] HRESULT GetBondedLengthByGridIndex([in]GridIndexType grdIndex, [in]Float64 distFromStart, [in]Float64 girderLength,
                                                                             [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);

      [propget,helpstring("property StrandDebondInRow")] HRESULT StrandDebondInRow([in] RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);
      [helpstring("method IsExteriorStrandDebondedInRow")] HRESULT IsExteriorStrandDebondedInRow([in] RowIndexType rowIndex,[out,retval]VARIANT_BOOL* bResult);

      [helpstring("method GetDebondSections")] HRESULT GetDebondSections([out]IDblArray** arrLeft,[out]IDblArray** arrRight);
      [helpstring("method GetDebondAtLeftSection")] HRESULT GetDebondAtLeftSection([in]SectionIndexType sectionIdx,[out,retval]IIndexArray** strandIndexes);
      [helpstring("method GetDebondAtRightSection")] HRESULT GetDebondAtRightSection([in]SectionIndexType sectionIdx,[out,retval]IIndexArray** strandIndexes);

	  [helpstring("method ClearDebonding")] HRESULT ClearDebonding();
   }

   [
      object,
      oleautomation,
      uuid(DBD342C8-9EA4-408c-9CF5-27744DE0CA60),
      helpstring("IStrandFillTool Interface"),
      pointer_default(unique)
   ]
   interface IStrandFillTool : IUnknown
   {
      [helpstring("method ComputeHarpedStrandMaxFill")] HRESULT ComputeHarpedStrandMaxFill([in]IStrandGridFiller* pEndGridFiller,[in]IStrandGridFiller* pHPGridFiller,[out]StrandIndexType* pMaxStrandCount,[out]IIndexArray** ppStrandFill);
   };

	[
		object,
		oleautomation,
		uuid(231B2534-7714-459c-A2CE-A2195474A2C2),
		helpstring("IPrecastGirder Interface"),
		pointer_default(unique)
	]
	interface IPrecastGirder : IUnknown
	{
      [helpstring("method Initialize")] HRESULT Initialize([in]ISegment* segment, [in]IStrandMover* strandMover);

      [propputref,helpstring("property StraightStrandMaterial")] HRESULT StraightStrandMaterial([in]IPrestressingStrand* pMaterial);
      [propget,helpstring("property StraightStrandMaterial")] HRESULT StraightStrandMaterial([out,retval]IPrestressingStrand** ppMaterial);

      [propputref,helpstring("property HarpedStrandMaterial")] HRESULT HarpedStrandMaterial([in]IPrestressingStrand* pMaterial);
      [propget,helpstring("property HarpedStrandMaterial")] HRESULT HarpedStrandMaterial([out,retval]IPrestressingStrand** ppMaterial);

      [propputref,helpstring("property TemporaryStrandMaterial")] HRESULT TemporaryStrandMaterial([in]IPrestressingStrand* pMaterial);
      [propget,helpstring("property TemporaryStrandMaterial")] HRESULT TemporaryStrandMaterial([out,retval]IPrestressingStrand** ppMaterial);

      [propget,helpstring("property StraightStrandGrid")] HRESULT StraightStrandGrid([in]EndType endType,[out,retval]IStrandGrid** ptrn);
      [propget,helpstring("property TemporaryStrandGrid")] HRESULT TemporaryStrandGrid([in]EndType endType,[out,retval]IStrandGrid** ptrn);
      [propget,helpstring("property HarpedStrandGridEnd")] HRESULT HarpedStrandGridEnd([in]EndType endType,[out,retval]IStrandGrid** ptrn);
      [propget,helpstring("property HarpedStrandGridHP")] HRESULT HarpedStrandGridHP([in]EndType endType,[out,retval]IStrandGrid** ptrn);

	   [propput,helpstring("property AllowOddNumberOfHarpedStrands")] HRESULT AllowOddNumberOfHarpedStrands([in]VARIANT_BOOL bUseMin);
	   [propget,helpstring("property AllowOddNumberOfHarpedStrands")] HRESULT AllowOddNumberOfHarpedStrands([out,retval]VARIANT_BOOL* bUseMin);

	   [propput,helpstring("property UseDifferentHarpedGridsAtEnds")] HRESULT UseDifferentHarpedGridsAtEnds([in]VARIANT_BOOL bUseDifferent);
	   [propget,helpstring("property UseDifferentHarpedGridsAtEnds")] HRESULT UseDifferentHarpedGridsAtEnds([out,retval]VARIANT_BOOL* bUseDifferent);

      // default design increments for vertical adjustment of strands at end and harping points
      // NOTE: If this value is less than zero, NO adjustment will be made.
      [propget,helpstring("property HarpedEndAdjustmentIncrement")] HRESULT HarpedEndAdjustmentIncrement([out,retval]Float64* increment);
      [propget,helpstring("property HarpedHpAdjustmentIncrement")] HRESULT HarpedHpAdjustmentIncrement([out,retval]Float64* increment);

      // max elevation of girder (girder Top) top is at 0.0
      [propget,helpstring("property TopElevation")] HRESULT TopElevation([out,retval]Float64* offset);

      // Vertical adjustments of harped strands
      // Cannot be set to a non-zero value if Increment (above) is negative.
      [propget,helpstring("property HarpedStrandAdjustmentEnd")] HRESULT HarpedStrandAdjustmentEnd([out,retval]Float64* offset);
      [propput,helpstring("property HarpedStrandAdjustmentEnd")] HRESULT HarpedStrandAdjustmentEnd([in]Float64 offset);
      [propget,helpstring("property HarpedStrandAdjustmentHP")] HRESULT HarpedStrandAdjustmentHP([out,retval]Float64* offset);
      [propput,helpstring("property HarpedStrandAdjustmentHP")] HRESULT HarpedStrandAdjustmentHP([in]Float64 offset);

	   [helpstring("method SetHarpingPoints")] HRESULT SetHarpingPoints([in]Float64 hp1,[in]Float64 hp2);
	   [helpstring("method GetHarpingPoints")] HRESULT GetHarpingPoints([out]Float64* hp1,[out]Float64* hp2);
	   [helpstring("method SetEndHarpingPoints")] HRESULT SetEndHarpingPoints([in]Float64 hp1,[in]Float64 hp2);
	   [helpstring("method GetEndHarpingPoints")] HRESULT GetEndHarpingPoints([out]Float64* hp1,[out]Float64* hp2);
	   [propput,helpstring("property UseMinHarpPointDistance")] HRESULT UseMinHarpPointDistance([in]VARIANT_BOOL bUseMin);
	   [propget,helpstring("property UseMinHarpPointDistance")] HRESULT UseMinHarpPointDistance([out,retval]VARIANT_BOOL* bUseMin);
	   [propput,helpstring("method MinHarpPointDistance")] HRESULT MinHarpPointDistance([in]Float64 minHpDist);
	   [propget,helpstring("method MinHarpPointDistance")] HRESULT MinHarpPointDistance([out,retval]Float64* minHpDist);
	   [propput,helpstring("property HarpingPointMeasure")] HRESULT HarpingPointMeasure([in] HarpPointMeasure measure);
	   [propget,helpstring("property HarpingPointMeasure")] HRESULT HarpingPointMeasure([out,retval] HarpPointMeasure* measure);
	   [propput,helpstring("property HarpingPointReference")] HRESULT HarpingPointReference([in] HarpPointReference hpRef);
	   [propget,helpstring("property HarpingPointReference")] HRESULT HarpingPointReference([out,retval] HarpPointReference* hpRef);
	   [helpstring("method GetHarpingPointLocations")] HRESULT GetHarpingPointLocations([out]Float64* hp1,[out]Float64* hp2);
	   [helpstring("method GetEndHarpingPointLocations")] HRESULT GetEndHarpingPointLocations([out]Float64* hp1,[out]Float64* hp2);

      [propget,helpstring("property SpanLength")] HRESULT SpanLength([out,retval] Float64* length);
      [propget,helpstring("property GirderLength")] HRESULT GirderLength([out,retval] Float64* length);
      [propget,helpstring("property LeftEndSize")] HRESULT LeftEndDistance([out,retval] Float64* size);
      [propget,helpstring("property RightEndSize")] HRESULT RightEndDistance([out,retval] Float64* size);
      [propget,helpstring("property LeftBearingOffset")] HRESULT LeftBearingOffset([out,retval] Float64* offset);
      [propget,helpstring("property RightBearingOffset")] HRESULT RightBearingOffset([out,retval] Float64* offset);
      [helpstring("method GetEndPoints")] HRESULT GetEndPoints([out]IPoint2d** pntPier1,[out]IPoint2d** pntEnd1,[out]IPoint2d** pntBrg1,[out]IPoint2d** pntBrg2,[out]IPoint2d** pntEnd2,[out]IPoint2d** pntPier2);

      [propget,helpstring("property StraightMaxStrandFill")] HRESULT StraightMaxStrandFill([out,retval]IIndexArray** fill);
      [propget,helpstring("property HarpedMaxStrandFill")] HRESULT HarpedMaxStrandFill([out,retval]IIndexArray** fill);
      [propget,helpstring("property TemporaryMaxStrandFill")] HRESULT TemporaryMaxStrandFill([out,retval]IIndexArray** fill);

      [propget,helpstring("property StraightStrandFill")] HRESULT StraightStrandFill([out,retval]IIndexArray** fill);
      [propput,helpstring("property StraightStrandFill")] HRESULT StraightStrandFill([in]IIndexArray* fill);
      [propget,helpstring("property HarpedStrandFill")] HRESULT HarpedStrandFill([out,retval]IIndexArray** fill);
      [propput,helpstring("property HarpedStrandFill")] HRESULT HarpedStrandFill([in]IIndexArray* fill);
      [propget,helpstring("property TemporaryStrandFill")] HRESULT TemporaryStrandFill([out,retval]IIndexArray** fill);
      [propput,helpstring("property TemporaryStrandFill")] HRESULT TemporaryStrandFill([in]IIndexArray* fill);

      // Get all strand locations based on current fill, or input fill. 
      // Debonded strands are not removed
      // Locations are adjusted by offset
      [propget,helpstring("property StraightStrandPositions")] HRESULT StraightStrandPositions([in] Float64 distFromStart, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property StraightStrandPositionsEx")] HRESULT StraightStrandPositionsEx([in] Float64 distFromStart, [in]IIndexArray* fill, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property HarpedStrandPositions")] HRESULT HarpedStrandPositions([in] Float64 distFromStart, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property HarpedStrandPositionsEx")] HRESULT HarpedStrandPositionsEx([in] Float64 distFromStart, [in]IIndexArray* fill, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property TemporaryStrandPositions")] HRESULT TemporaryStrandPositions([in] Float64 distFromStart, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property TemporaryStrandPositionsEx")] HRESULT TemporaryStrandPositionsEx([in] Float64 distFromStart, [in]IIndexArray* fill, [out,retval]IPoint2dCollection** points);

      // Convert strand index (defined in IPoint2dCollection's above) to Grid index
      [helpstring("method StraightStrandIndexToGridIndex")] HRESULT StraightStrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method StraightStrandIndexToGridIndexEx")] HRESULT StraightStrandIndexToGridIndexEx([in]IIndexArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method HarpedStrandIndexToGridIndex")] HRESULT HarpedStrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method HarpedStrandIndexToGridIndexEx")] HRESULT HarpedStrandIndexToGridIndexEx([in]IIndexArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method TemporaryStrandIndexToGridIndex")] HRESULT TemporaryStrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method TemporaryStrandIndexToGridIndexEx")] HRESULT TemporaryStrandIndexToGridIndexEx([in]IIndexArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);

      // Compute bounding boxes of harped and straight strands accounting for vertical offsets for harped strands
	   [helpstring("method StraightStrandBoundingBox")] HRESULT StraightStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);
	   [helpstring("method StraightStrandBoundingBoxEx")] HRESULT StraightStrandBoundingBoxEx([in]EndType endType, [in] IIndexArray* fill, [out,retval]IRect2d** box);
	   [helpstring("method HarpedEndStrandBoundingBox")] HRESULT HarpedEndStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);
	   [helpstring("method HarpedEndStrandBoundingBoxEx")] HRESULT HarpedEndStrandBoundingBoxEx([in]EndType endType, [in] IIndexArray* fill, [out,retval]IRect2d** box);
	   [helpstring("method HarpedHpStrandBoundingBox")] HRESULT HarpedHpStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);
	   [helpstring("method HarpedHpStrandBoundingBoxEx")] HRESULT HarpedHpStrandBoundingBoxEx([in]EndType endType, [in] IIndexArray* fill, [out,retval]IRect2d** box);

      // Compute offset adjustment required in order to put harped strands within proper bounds
      // If zero, no adjustment is required. 
      // If non-zero, add this number to current offset to move current harped strands just enough to fit within cross section boundary
	   [helpstring("method HarpedEndStrandBoundaryCheck")] HRESULT HarpedEndStrandBoundaryCheck([out,retval]Float64* adjustment);
	   [helpstring("method HarpedHpStrandBoundaryCheck")] HRESULT HarpedHpStrandBoundaryCheck([out,retval]Float64* adjustment);

      // Max allowable up or down strand adjustment to keep strands in bounds
	   [helpstring("method GetHarpedEndAdjustmentBounds")] HRESULT GetHarpedEndAdjustmentBounds([out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
	   [helpstring("method GetHarpedEndAdjustmentBoundsEx")] HRESULT GetHarpedEndAdjustmentBoundsEx([in] IIndexArray* fill, [out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
	   [helpstring("method GetHarpedHpAdjustmentBounds")] HRESULT GetHarpedHpAdjustmentBounds([out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
	   [helpstring("method GetHarpedHpAdjustmentBoundsEx")] HRESULT GetHarpedHpAdjustmentBoundsEx([in] IIndexArray* fill, [out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);

	   [helpstring("property GetHarpedEndFilledGridBoundsEx")] HRESULT GetHarpedEndFilledGridBoundsEx([in]IIndexArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);
	   [helpstring("property GetHarpedHpFilledGridBoundsEx")] HRESULT GetHarpedHpFilledGridBoundsEx([in]IIndexArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);

      [helpstring("property ComputeMaxHarpedStrandSlope")] HRESULT ComputeMaxHarpedStrandSlope([in]Float64 distFromStart,[out,retval]Float64* slope);
      [helpstring("property ComputeMaxHarpedStrandSlopeEx")] HRESULT ComputeMaxHarpedStrandSlopeEx([in]Float64 distFromStart, [in]IIndexArray* fill, [in] Float64 endOffset,[in] Float64 hpOffset,[out,retval]Float64* slope);
      [helpstring("property ComputeAvgHarpedStrandSlope")] HRESULT ComputeAvgHarpedStrandSlope([in]Float64 distFromStart,[out,retval]Float64* slope);
      [helpstring("property ComputeAvgHarpedStrandSlopeEx")] HRESULT ComputeAvgHarpedStrandSlopeEx([in]Float64 distFromStart, [in]IIndexArray* fill, [in] Float64 endOffset,[in] Float64 hpOffset,[out,retval]Float64* slope);

      [propget,helpstring("property MaxStraightStrands")] HRESULT MaxStraightStrands([out,retval]StrandIndexType* nStrands);
      [propget,helpstring("property MaxHarpedStrands")] HRESULT MaxHarpedStrands([out,retval]StrandIndexType* nStrands);
      [propget,helpstring("property MaxTemporaryStrands")] HRESULT MaxTemporaryStrands([out,retval]StrandIndexType* nStrands);

      [helpstring("method GetStraightStrandCount")] HRESULT GetStraightStrandCount([out,retval] StrandIndexType* nStrands);
      [helpstring("method GetHarpedStrandCount")] HRESULT GetHarpedStrandCount([out,retval] StrandIndexType* nStrands);
      [helpstring("method GetTemporaryStrandCount")] HRESULT GetTemporaryStrandCount([out,retval] StrandIndexType* nStrands);

      [helpstring("method GetStraightStrandCountEx")] HRESULT GetStraightStrandCountEx([in]IIndexArray* fill, [out,retval] StrandIndexType* nStrands);
      [helpstring("method GetHarpedStrandCountEx")] HRESULT GetHarpedStrandCountEx([in]IIndexArray* fill, [out,retval] StrandIndexType* nStrands);
      [helpstring("method GetTemporaryStrandCountEx")] HRESULT GetTemporaryStrandCountEx([in]IIndexArray* fill, [out,retval] StrandIndexType* nStrands);

      // rough count of debonded strands at current fill
      [helpstring("method GetStraightStrandDebondCount")] HRESULT GetStraightStrandDebondCount([out,retval] StrandIndexType* count);

      // Debond straight strands based on Grid index
	   [helpstring("method ClearStraightStrandDebonding")] HRESULT ClearStraightStrandDebonding();
      [helpstring("method DebondStraightStrandByGridIndex")] HRESULT DebondStraightStrandByGridIndex([in]GridIndexType grdIndex,[in]Float64 l1,[in]Float64 l2);
      [helpstring("method GetDebondedStraightStrandsByGridIndex")] HRESULT GetDebondedStraightStrandsByGridIndex([out,retval]IIndexArray** grdIndexes);
      [helpstring("method GetStraightStrandDebondLengthByGridIndex")] HRESULT GetStraightStrandDebondLengthByGridIndex([in]EndType endType,[in]GridIndexType grdIndex,[out]Float64* YCoord,[out]Float64* l1,[out]Float64* l2);

      // Debonded straight strands based on Positions index (i.e., from get_StraightStrandPositions)
      [helpstring("method GetStraightStrandDebondLengthByPositionIndex")] HRESULT GetStraightStrandDebondLengthByPositionIndex([in]EndType endType,[in]StrandIndexType positionIndex,[out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);
      [helpstring("method GetStraightStrandsDebondedByPositionIndex")] HRESULT GetStraightStrandsDebondedByPositionIndex([in]EndType endType,[in]Float64 distFromStart, [out,retval]IIndexArray** positionIndexes);

      [propget,helpstring("property StraightStrandRowsWithStrand")] HRESULT StraightStrandRowsWithStrand([out,retval]RowIndexType* nRows);
      [propget,helpstring("property StraightStrandsInRow")] HRESULT StraightStrandsInRow([in]RowIndexType rowIdx,[out,retval]IIndexArray** gridIndexes);
      [propget,helpstring("property NumStraightStrandsInRow")] HRESULT NumStraightStrandsInRow([in]RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);
      [propget,helpstring("property StraightStrandDebondInRow")] HRESULT StraightStrandDebondInRow([in] RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);
      [helpstring("method IsExteriorStraightStrandDebondedInRow")] HRESULT IsExteriorStraightStrandDebondedInRow([in] RowIndexType rowIndex,[out,retval]VARIANT_BOOL* bResult);

      [propget,helpstring("property HarpedStrandRowsWithStrand")] HRESULT HarpedStrandRowsWithStrand([out,retval]RowIndexType* nRows);
      [propget,helpstring("property HarpedStrandsInRow")] HRESULT HarpedStrandsInRow([in]RowIndexType rowIdx,[out,retval]IIndexArray** gridIndexes);
      [propget,helpstring("property NumHarpedStrandsInRow")] HRESULT NumHarpedStrandsInRow([in]RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);

      [helpstring("method GetStraightStrandDebondAtSections")] HRESULT GetStraightStrandDebondAtSections([out]IDblArray** arrLeft,[out]IDblArray** arrRight);
      [helpstring("method GetStraightStrandDebondAtLeftSection")] HRESULT GetStraightStrandDebondAtLeftSection([in]SectionIndexType sectionIdx,[out,retval]IIndexArray** pstnIndexes);
      [helpstring("method GetStraightStrandDebondAtRightSection")] HRESULT GetStraightStrandDebondAtRightSection([in]SectionIndexType sectionIdx,[out,retval]IIndexArray** pstnIndexes);

      // Distance that a strand is bonded (left and right) for a given location. Also returns strand's Y coordinate
      [helpstring("method GetStraightStrandBondedLengthByPositionIndex")] HRESULT GetStraightStrandBondedLengthByPositionIndex([in]StrandIndexType positionIndex, [in]Float64 distFromStart,
                                                                             [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);

      [helpstring("method GetStraightStrandBondedLengthByGridIndex")] HRESULT GetStraightStrandBondedLengthByGridIndex([in]GridIndexType grdIndex, [in]Float64 distFromStart,
                                                                             [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);
      [propget,helpstring("property RebarLayout")] HRESULT RebarLayout([out,retval]IRebarLayout** rebarLayout);
	};


	[
		object,
		oleautomation,
		uuid(C5CBE002-A27E-408c-91DF-56A6AF5346BC),
		helpstring("BridgeGeometryTool Interface"),
		pointer_default(unique)
	]
	interface IBridgeGeometryTool : IUnknown
	{
	   [helpstring("method PointBySSMbr")] HRESULT PointBySSMbr([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] Float64 distFromStartOfSSMbr,[out,retval] IPoint2d** point);
	   [helpstring("method PointBySegment")] HRESULT PointBySegment([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] SegmentIndexType segIdx, [in] Float64 Xs,[out,retval] IPoint2d** point);
	   [helpstring("method StationAndOffsetBySSMbr")] HRESULT StationAndOffsetBySSMbr([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] Float64 distFromStartOfSSMbr,[out] IStation** station, [out] Float64* offset);
	   [helpstring("method StationAndOffsetBySegment")] HRESULT StationAndOffsetBySegment([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] SegmentIndexType segIdx, [in] Float64 Xs,[out] IStation** station, [out] Float64* offset);
	   [helpstring("method GirderPathOffset")] HRESULT GirderPathOffset([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] SegmentIndexType segIdx,[in] VARIANT varStation, [out,retval] Float64* offset);
	   //[helpstring("method GirderLineBearing")] HRESULT GirderLineBearing([in] IGenericBridge* bridge,[in] SpanIndexType spanIdx,[in] GirderIndexType gdrIdx, [out,retval] IDirection** direction);
	   //[helpstring("method GirderLinePoint")] HRESULT GirderLinePoint([in] IGenericBridge* bridge,[in] Float64 distFromStartOfBridge,[in] GirderIndexType gdrIdx, [out] SpanIndexType* spanIdx, [out] Float64* distFromStartOfSpan);
	   [helpstring("method DeckEdgePoint")] HRESULT DeckEdgePoint([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] IPoint2d** point);
	   [helpstring("method DeckEdgePoints")] HRESULT DeckEdgePoints([in] IGenericBridge* bridge,[in] DirectionType side,[in] CollectionIndexType nPoints,[out,retval] IPoint2dCollection** points);
	   [helpstring("method CurbOffset")] HRESULT CurbOffset([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOffset);
	   [helpstring("method DeckOffset")] HRESULT DeckOffset([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOffset);
      [helpstring("method DeckOverhang")] HRESULT DeckOverhang([in] IGenericBridge* bridge,[in] Float64 station, [in]GirderIDType ssMbrID,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOverhang);
      [helpstring("method DeckOverhangBySSMbr")] HRESULT DeckOverhangBySSMbr([in] IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]Float64 distFromStartOfSSMbr,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOverhang);
      [helpstring("method DeckOverhangBySegment")] HRESULT DeckOverhangBySegment([in] IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in] SegmentIndexType segIdx,[in]Float64 Xs,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOverhang);
      [helpstring("method GirderSpacingBySSMbr")] HRESULT GirderSpacingBySSMbr([in] IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]Float64 distFromStartOfSSMbr,[in]GirderIDType otherSSMbrID,[out,retval]Float64* pSpacing);
      [helpstring("method GirderSpacingBySegment")] HRESULT GirderSpacingBySegment([in] IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in] SegmentIndexType segIdx,[in]Float64 Xs,[in]GirderIDType otherSSMbrID,[out,retval]Float64* pSpacing);
      // Get offset to interior curbs. Other method always return offset of exterior barrier curbs
	   [helpstring("method InteriorCurbOffset")] HRESULT InteriorCurbOffset([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOffset);
	};

	[
		uuid(8B4B8193-D5C8-4e1f-86D1-D7044859B9CC),
		helpstring("FlexRebarLayoutItem")
	]
	coclass FlexRebarLayoutItem
	{
		[default] interface IFlexRebarLayoutItem;
	};

	[
		uuid(7DDC7A24-05FA-4565-92AC-4FFD54D5063D),
		helpstring("EffectiveFlangeWidthDetails Class")
	]
	coclass EffectiveFlangeWidthDetails
	{
		[default] interface IEffectiveFlangeWidthDetails;
	};
		
	[
		uuid(7AF06A24-3EF5-433B-9A03-B22A8404048B),
		helpstring("EffectiveFlangeWidthTool Class")
	]
	coclass EffectiveFlangeWidthTool
	{
		[default] interface IEffectiveFlangeWidthTool;
	};

	[
		uuid(88738282-9CE8-4553-BC7E-4DB1DF3D8809),
		helpstring("SectionCutTool Class")
	]
	coclass SectionCutTool
	{
		[default] interface ISectionCutTool;
	};

	[
	   uuid(6E8068AB-ABC2-4cae-A31B-74ABD7500570),
	   helpstring("PrecastGirder Class")
	]
	coclass PrecastGirder
	{
	   [default] interface IPrecastGirder;
	};

	[
	   uuid(77B0384B-5C9D-46ac-A8B6-AA8ADA58B37D),
	   helpstring("BridgeGeometryTool Class")
	]
	coclass BridgeGeometryTool
	{
	   [default] interface IBridgeGeometryTool;
	};

   [
		uuid(A547E2F5-BE84-49F9-846E-2A5B2C2FD53F),
		helpstring("StrandGrid Class")
	]
	coclass StrandGrid
	{
		[default] interface IStrandGrid;
      interface IStrandGridFiller;
	};

   [
      uuid(A757985C-CC7F-4789-B3F3-03BCCED77970),
      helpstring("StrandFillTool Class")
   ]
   coclass StrandFillTool
   {
      [default] interface IStrandFillTool;
   };

	[
		uuid(2C4F5781-2FD5-4fcc-AC8F-E8CD9C324066),
		helpstring("BridgeDeckRebarLayout")
	]
	coclass BridgeDeckRebarLayout
	{
		[default] interface IBridgeDeckRebarLayout;
	};
};
