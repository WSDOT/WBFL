///////////////////////////////////////////////////////////////////////
// GenericBridgeTools - Tools for manipluating the Generic Bridge Modeling
// Copyright © 1999-2022  Washington State Department of Transportation
//                        Bridge and Structures Office
//
// This library is a part of the Washington Bridge Foundation Libraries
// and was developed as part of the Alternate Route Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the Alternate Route Library Open Source License as 
// published by the Washington State Department of Transportation,
// Bridge and Structures Office.
//
// This program is distributed in the hope that it will be useful,
// but is distributed AS IS, WITHOUT ANY WARRANTY; without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
// PURPOSE.  See the Alternate Route Library Open Source License for more details.
//
// You should have received a copy of the Alternate Route Library Open Source License
// along with this program; if not, write to the Washington State
// Department of Transportation, Bridge and Structures Office,
// P.O. Box 47340, Olympia, WA 98503, USA or e-mail
// Bridge_Support@wsdot.wa.gov
///////////////////////////////////////////////////////////////////////

// GenericBridgeTools.idl : IDL source for GenericBridgeTools.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (GenericBridgeTools.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";
import "WBFLTypes.idl";
import "WBFLTools.idl";
import "WBFLUnitServer.idl";
import "WBFLGeometry.idl";
import "WBFLSections.idl";
import "WBFLCogo.idl";
import "WBFLBridgeGeometry.idl";
import "WBFLGenericBridge.idl";

cpp_quote("#define GBMT_E_UNKNOWNDECKTYPE             MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,512)")
cpp_quote("#define GBMT_E_GIRDERSECTION               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,513)")
cpp_quote("#define GBMT_E_NODECK                      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,514)")
cpp_quote("#define GBMT_E_COMPOSITEDECK               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,515)")
cpp_quote("#define GBMT_E_MATERIAL                    MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,516)")
cpp_quote("#define GBMT_E_SHAPE                       MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,517)")
cpp_quote("#define GBMT_E_REMOVEDEBOND                MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,518)")

[
	uuid(B7AEBB77-85BC-4FB0-BD1F-1078DB8FF85E),
	version(1.0),
	helpstring("WBFLGenericBridgeTools Library")
]
library WBFLGenericBridgeTools
{
	importlib("stdole32.tlb");
	importlib("stdole2.tlb");
   importlib("WBFLGenericBridge.tlb");

   interface IPrecastGirder;

   typedef [public,helpstring("enum LayoutPosition"),uuid(9246CAAE-3CAD-401f-BB00-0DA5EFA41EE2)]
   enum 
   {
	   lpLeft,
	   lpCenter,
	   lpRight
   } LayoutPosition;

   typedef [public,helpstring("enum SectionPropertyMethod"),uuid(B7DC993C-340A-4fb0-A058-6286F9C890B7)]
   enum
   {
      spmGrossNoncomposite,
      spmGross,
      spmTransformedNoncomposite,
      spmTransformed,
      spmNet
   } SectionPropertyMethod;

   typedef [public,helpstring("enum HaunchDepthMethod"),uuid(53E30894-CA84-4372-ABC2-1108348E9CCE)]
   enum
   {
      hdmHaunchIsZero,       // girder directly on slab
      hdmHaunchEqualsFillet, // constant depth equal to fillet
      hdmHaunchIsParabolic   // depth defined by "A" dimensions, roadway, and assumed excess camber
   } HaunchDepthMethod;

   typedef [public,helpstring("enum HarpPointReference"),uuid(9744FFFE-8025-422e-A4C3-9A58B48DD102)] 
   enum 
   {
       hprEndOfGirder    = 0,
	   hprBearing        = 1,
	   hprCenterOfGirder = 2,
   } HarpPointReference;

   typedef [public,helpstring("enum HarpPointMeasure"),uuid(97051264-41BA-4691-9C4E-CDE659BB2C5A)] 
   enum 
   {
       hpmFractionOfSpanLength   = 0,
	   hpmFractionOfGirderLength = 1,
	   hpmAbsoluteDistance       = 2
   } HarpPointMeasure;

   typedef [public,helpstring("enum BarrierSectionCut"),uuid(B87307A0-81D1-41e5-A115-E1CAB0E39A43)]
   enum 
   {
     bscNone,  // don't include barrier in section cut
	  bscStructurallyContinuousOnly, // include only the structurally continuous portion of the barrier
	  bscAll // enclude all components of the barrier
   } BarrierSectionCut;

   typedef [public,helpstring("enum StrandGridType"),uuid(F35F63C1-32EA-4de6-B6D8-1F3A5E9863A4)]
   enum
   {
      sgtEnd, // strand grid is at end of girder
      sgtHarpPoint // strand grid is at harp point
   } StrandGridType;


   typedef [public,helpstring("enum WDebondLocationType"),uuid(56213312-6399-4417-A8F0-1B933056D00E)]
   enum
   {
      wdblEither,  // check debonding at either end
      wdblLeft,    // debonding is at left end
      wdblRight    // debonding is at right end
   } WDebondLocationType;

   typedef [public, helpstring("enum StrandProfileType"), uuid(69390986-1709-4F89-A98F-7A016E25D1EF)]
   enum
   {
      Linear, // strands are always straight between strand grids
      FollowGirder // strands follow the shape of the girder (straight strands maintain constant distance from top face of girder, even when there is precamber)
   } StrandProfileType;


   typedef [public, helpstring("enum StrandType"), uuid(EEFCCCB4-1DFB-4D82-B964-66171F0DDD05)]
   enum
   {
      Straight,
      Harped,
      Temporary
   } StrandType;

	[
		object,
		uuid(B887911C-EC53-4f32-B5E2-9D43C1F8D977),
		oleautomation,
		helpstring("IFlexRebarLayoutItem Interface"),
		pointer_default(unique)
	]
	interface IFlexRebarLayoutItem : IUnknown
	{
	   [propget,helpstring("property Position")] HRESULT Position([out,retval] LayoutPosition* lp);
	   [propput,helpstring("property Position")] HRESULT Position([in] LayoutPosition lp);
	   [propget,helpstring("property LengthFactor")] HRESULT LengthFactor([out,retval] Float64* lf);
	   [propput,helpstring("property LengthFactor")] HRESULT LengthFactor([in] Float64 lf);
	   [propputref,helpstring("property Girder")] HRESULT Girder([in]IPrecastGirder* girder);
	};

	[
		object,
		oleautomation,
		uuid(B3D076FB-B0B0-4791-ADCF-BE1826640996),
		helpstring("SectionCutTool Interface"),
		pointer_default(unique)
	]
	interface ISectionCutTool : IUnknown
	{
      // EffectiveFlangeWidthTool is used to compute the width of the deck when creating shapes and sections
      // after the deck has become composite
	   [propputref,helpstring("property EffectiveFlangeWidthTool")] HRESULT EffectiveFlangeWidthTool([in] IEffectiveFlangeWidthTool* pTool);
	   [propget,helpstring("property EffectiveFlangeWidthTool")] HRESULT EffectiveFlangeWidthTool([out,retval] IEffectiveFlangeWidthTool* *pTool);

      // The "section" methods create a structural section from which stiffness properties can be determined
      // Bridge and Barrier sections are always gross sections
      [helpstring("method CreateGirderSectionBySSMbr")] HRESULT CreateGirderSectionBySSMbr([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]Float64 Xgp,[in]SectionBias sectionBias,[in]SectionCoordinateSystemType coordinateSystem,[in] StageIndexType stageIdx, [in] SectionPropertyMethod sectionPropMethod, [in]HaunchDepthMethod haunchMethod, [in] BOOL bFollowMatingSurfaceProfile, [out]IndexType* beamIdx, [out]IndexType* slabIdx, [out,retval]ISection** section);
	   [helpstring("method CreateGirderSectionBySegment")] HRESULT CreateGirderSectionBySegment([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx,[in]Float64 Xs,[in]SectionBias sectionBias, [in]SectionCoordinateSystemType coordinateSystem, [in] StageIndexType stageIdx, [in] SectionPropertyMethod sectionPropMethod, [in]HaunchDepthMethod haunchMethod, [in]BOOL bFollowMatingSurfaceProfile, [out]IndexType* beamIdx, [out]IndexType* slabIdx ,[out,retval]ISection** section);
	   [helpstring("method CreateBridgeSection")] HRESULT CreateBridgeSection([in]IGenericBridge* bridge,[in]Float64 Xb,[in]SectionBias sectionBias,[in] StageIndexType stageIdx, [in] BarrierSectionCut bsc,[out,retval]ISection** section);
	   [helpstring("method CreateLeftBarrierSection")] HRESULT CreateLeftBarrierSection([in]IGenericBridge* bridge,[in] Float64 station,[in] VARIANT_BOOL bStructuralOnly,[out,retval]ISection** section);
	   [helpstring("method CreateRightBarrierSection")] HRESULT CreateRightBarrierSection([in]IGenericBridge* bridge,[in] Float64 station,[in] VARIANT_BOOL bStructuralOnly,[out,retval]ISection** section);

      [helpstring("method CreateNetDeckSection")] HRESULT CreateNetDeckSection([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx,[in]Float64 Xs, [in]SectionBias sectionBias, [in]SectionCoordinateSystemType coordinateSystem, [in]StageIndexType stageIdx, [in]HaunchDepthMethod haunchMethod,[in] BOOL bFollowMatingSurfaceProfile, [out,retval]ISection** section);

      // creates the gross deck shape used in composite analyses
      [helpstring("method CreateDeckAnalysisShape")] HRESULT CreateDeckAnalysisShape([in]IGenericBridge* bridge,[in]IGirderSection* pSection,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx, [in]Float64 Xs,[in]SectionBias sectionBias, [in]Float64 haunchDepth,[in]BOOL bFollowMatingSurfaceProfile,[in] StageIndexType stageIdx,[out,retval]IShape** shape);

      // The "shape" methods create a shape object that is typically used for creating a graphical representations of the girder or bridge
      [helpstring("method CreateGirderShapeBySSMbr")] HRESULT CreateGirderShapeBySSMbr([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]Float64 Xgp, [in]SectionBias sectionBias, [in]SectionCoordinateSystemType coordinateSystem,[in] VARIANT_BOOL bIncludeDeck,[in]HaunchDepthMethod haunchMethod,[in] BOOL bFollowMatingSurfaceProfile, [out,retval]IShape** ppShape);
	   [helpstring("method CreateGirderShapeBySegment")] HRESULT CreateGirderShapeBySegment([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx,[in]Float64 Xs, [in]SectionBias sectionBias, [in]SectionCoordinateSystemType coordinateSystem,[in] VARIANT_BOOL bIncludeDeck,[in]HaunchDepthMethod haunchMethod, [in]BOOL bFollowMatingSurfaceProfile, [out,retval]IShape** ppShape);
	   [helpstring("method CreateLeftBarrierShape")] HRESULT CreateLeftBarrierShape([in]IGenericBridge* bridge,[in] Float64 station,[in]IDirection* pDirection,[out,retval]IShape** shape);
	   [helpstring("method CreateRightBarrierShape")] HRESULT CreateRightBarrierShape([in]IGenericBridge* bridge,[in] Float64 station,[in]IDirection* pDirection,[out,retval]IShape** shape);
      [helpstring("method CreateSlabShape")] HRESULT CreateSlabShape([in]IGenericBridge* bridge,[in]Float64 station,[in]IDirection* pDirection,[in] VARIANT_BOOL bIncludeHaunch,[out,retval]IShape** shape);
      [helpstring("method CreateLongitudinalJointShapeBySSMbr")] HRESULT CreateLongitudinalJointShapeBySSMbr([in]IGenericBridge* bridge, [in]GirderIDType ssMbrID, [in]Float64 Xgp, [in]SectionCoordinateSystemType coordinateSystem, [out]IShape** ppLeftJointShape,[out]IShape** ppRightJointShape);
      [helpstring("method CreateLongitudinalJointShapeBySegment")] HRESULT CreateLongitudinalJointShapeBySegment([in]IGenericBridge* bridge, [in]GirderIDType ssMbrID, [in]SegmentIndexType segIdx, [in]Float64 Xs, [in]SectionCoordinateSystemType coordinateSystem, [out]IShape** ppLeftJointShape, [out]IShape** ppRightJointShape);

      [helpstring("method GetDeckProperties")] HRESULT GetDeckProperties([in]IGenericBridge* bridge,[in]IndexType nSectionsPerSpan,[out]Float64* pSurfaceArea,[out]Float64* pVolume);
	   [helpstring("method GetStructuralHaunchDepth")] HRESULT GetStructuralHaunchDepth([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx,[in]Float64 Xs,[in]HaunchDepthMethod haunchMethod, [out,retval]Float64* pHaunchDepth);
	};

   // This interface tells how to move harped strands when they are offset
	[
		object,
		oleautomation,
		uuid(0FAD048E-8F77-472a-B2BF-7ED599FA765D),
		helpstring("IStrandMover Interface"),
		pointer_default(unique)
	]
	interface IStrandMover : IUnknown 
	{
      // Top elevation of girder in strand coords (note that cover is below this).
	   [propget, helpstring("property TopElevation")] HRESULT TopElevation([out, retval]Float64* topElev);

      // overall height of the girder section at the location of this strand mover
      [propget, helpstring("property SectionHeight")] HRESULT SectionHeight([out,retval] Float64* pHeight);

      // Max/min Y locations for harped prestressing strands within section at harping points and ends
	   [propget, helpstring("property Hp2StrandElevationBoundaries")] HRESULT HpStrandElevationBoundaries([in]EndType endType,[out]Float64* bottomMin,[out]Float64* topMax);
	   [propget, helpstring("property EndStrandElevationBoundaries")] HRESULT EndStrandElevationBoundaries([in]EndType endType,[out]Float64* bottomMin,[out]Float64* topMax);

      // default increments for moving strands
	   [propget, helpstring("property StrandIncrements")] HRESULT StrandIncrements([out]Float64* endIncrement,[out]Float64* hpIncrement);

      // Test if a strand location is within valid bounds 
	   [helpstring("method TestHp2StrandLocation")] HRESULT TestHpStrandLocation([in]EndType endType,[in]Float64 Hg,[in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]VARIANT_BOOL* isWithin);
	   [helpstring("method TestEndStrandLocation")] HRESULT TestEndStrandLocation([in]EndType endType,[in]Float64 Hg,[in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]VARIANT_BOOL* isWithin);

      // Based on an original location and a Y offset, compute the new strand location
      [helpstring("method TranslateHpStrand")] HRESULT TranslateHpStrand([in]EndType endType, [in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]Float64* newX, [out]Float64* newY);
	   [helpstring("method TranslateEndStrand")] HRESULT TranslateEndStrand([in]EndType endType,[in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]Float64* newX, [out]Float64* newY );
   };

   // Definitions:
   // Strand Grid: A condensed grid of potential strand locations. All x values are 0.0 or more.
   //              For x > 0.0, there is assumed to be a second potiential strand location at -x
   // Strand Grid Index: Index into the condensed strand grid
   // Strand Position: The position of a strand in the fully expanded strand grid
   //                  Strand positions correspond to the strand fill sequence numbers you'll find
   //                  on girder plans. The strands in a girder can be at position 0,1,6,7,10,11
   // Strand Index: Zero based index into the list of strands used in a girder.
   //               For the example given above, we have
   //               index 0 -> strand position 0
   //               index 1 -> strand position 1
   //               index 2 -> strand position 6
   //               index 3 -> strand position 7
   //               index 4 -> strand position 10
   //               index 5 -> strand position 11

	[
		object,
		oleautomation,
		uuid(656F5032-BB18-4644-911A-CD4672EBA5B0),
		helpstring("IStrandGrid Interface"),
		pointer_default(unique)
	]
	interface IStrandGrid : IUnknown
	{
      // Grid points represent holes where strands can go
      // Grid points use a compacted numbering sequence where points with positive X values
      // are placed symmetrically (e.g., represent two actual strand locations)
	   [helpstring("method AddGridPoint")] HRESULT AddGridPoint([in]IPoint2d* point);
	   [helpstring("method AddGridPoints")] HRESULT AddGridPoints([in]IPoint2dCollection* points);
	   [propget, helpstring("property GridPointCount")] HRESULT GridPointCount([out,retval]GridIndexType* count);
	   [propget, helpstring("property GridPoint")] HRESULT GridPoint([in] GridIndexType idx,[out,retval]IPoint2d** point);
	   [propget, helpstring("property GridPoints")] HRESULT GridPoints([out,retval]IPoint2dCollection** point);
	   [helpstring("method RemoveGridPoint")] HRESULT RemoveGridPoint([in] GridIndexType idx);
	   [helpstring("method ClearGridPoints")] HRESULT ClearGridPoints();

	   [helpstring("method GridBoundingBox")] HRESULT GridBoundingBox([out,retval]IRect2d** box);
    };


	[
		object,
		oleautomation,
		uuid(E5DF8437-92B8-4d3e-A3F5-71E46214571D),
		helpstring("IStrandGridFiller Interface"),
		pointer_default(unique)
	]
	interface IStrandGridFiller : IUnknown
	{
      // Functions below have to do with filling of grid points and query for filled strands
      // This is a mostly private interface to facilitate use of the strand grid.
      
      // Max number strands that can be filled
      [propget,helpstring("property MaxStrandCount")] HRESULT MaxStrandCount([out,retval]StrandIndexType* count);

      // Returns a vector of integers GridPointCount long indicating the max number of strands
      // that normally can be placed at each Grid point (1 - if X==0.0, or 2 - if X>0.0)
      [helpstring("method GetMaxStrandFill")] HRESULT GetMaxStrandFill([out,retval]IIndexArray** maxFill);

      // Set or get vector of integers indicated number of strands filled at each Grid point
      // Possible values are 0, 1, or 2. Length of vector is GridPointCount
      // If Grid point has positive X value and 1 is input, the strand is placed at X=0.0
      // If Grid point has zero X value and 2 is input, two strands are placed at X=0.0
      [propget, helpstring("property StrandFill")] HRESULT StrandFill([out,retval]IIndexArray** fill);
      [propputref, helpstring("property StrandFill")] HRESULT StrandFill([in]IIndexArray* fill);

	   [helpstring("method RemoveAllStrands")] HRESULT RemoveAllStrands();

      // Set the strand mover. By default strands just move up or down
      [propputref, helpstring("property StrandMover")] HRESULT StrandMover([in]StrandGridType gridType,[in]EndType endType,[in]IStrandMover* mover);
      [helpstring("method StrandMover")] HRESULT GetStrandMover([out]StrandGridType* gridType,[out]EndType* endType,[out]IStrandMover** mover);

      // adjust strands from the nominal grid locations
      // dx = horizontal adjustment, positive values shifts the strands to the right
      // dy = vertical adjustment, postiive values shifts the strands upwards
      [helpstring("method SetStrandAdjustment")] HRESULT SetStrandAdjustment([in]Float64 dx,[in]Float64 dy);
      [helpstring("method GetStrandAdjustment")] HRESULT GetStrandAdjustment([out]Float64* pdx,[out]Float64* pdy);

      // Return number of currently filled strand locations
	   [helpstring("method GetStrandCount")] HRESULT GetStrandCount([out,retval] StrandIndexType* count);

      // Returns a collection of all currently filled strand locations
      // index 0 in the collection corresponds to strandIndex = 0, index 1 -> strandIndex = 1, etc
	   [helpstring("method GetStrandPositions")] HRESULT GetStrandPositions([out,retval]IPoint2dCollection** points);

      // Convert strand index (defined in IPoint2dCollection's above) to/from Grid index
      [helpstring("method StrandIndexToGridIndex")] HRESULT StrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      // can possibly have one or two strands per grid index. If only one, strandIndex2==INVALID_INDEX
      [helpstring("method GridIndexToStrandIndex")] HRESULT GridIndexToStrandIndex([in] GridIndexType gridIndex, [out] StrandIndexType* strandIndex1, [out] StrandIndexType* strandIndex2);

      // Return CG and bounding box of currently filled strands - adjused for vertical adjustment
	   [propget,helpstring("property CG")] HRESULT CG([out]Float64* cgx, [out]Float64* cgy);
	   [propget,helpstring("property StrandBoundingBox")] HRESULT StrandBoundingBox([out,retval]IRect2d** box);

      // Unadjusted upper and lower bounds for currently filled grid
      // returns zeros if no strands in fill
	   [propget,helpstring("property FilledGridBounds")] HRESULT FilledGridBounds([out]Float64* bottomElev, [out]Float64* topElev);

	   [propget,helpstring("property RowsWithStrand")] HRESULT RowsWithStrand([out,retval]RowIndexType* nRows);
	   [propget,helpstring("property StrandsInRow")] HRESULT StrandsInRow([in]RowIndexType rowIdx,[out,retval]IIndexArray** gridIndexes);
	   [propget,helpstring("property NumStrandsInRow")] HRESULT NumStrandsInRow([in]RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);

	   [propget,helpstring("property StrandRowElevation")] HRESULT StrandRowElevation([in]RowIndexType rowIdx,[out,retval]Float64* pElevation);


      // Ex methods are typically for testing a new fill.
      // they allow input of a temporary fill array. Internal fill array is not changed
	   [helpstring("method GetStrandCountEx")] HRESULT GetStrandCountEx([in]IIndexArray* fill, [out,retval] StrandIndexType* count);
	   [helpstring("method GetStrandPositionsEx")] HRESULT GetStrandPositionsEx([in]IIndexArray* fill, [out,retval]IPoint2dCollection** points);
	   [propget,helpstring("property CGEx")] HRESULT CGEx([in]IIndexArray* fill, [out]Float64* cgx, [out]Float64* cgy);
	   [propget,helpstring("property StrandBoundingBoxEx")] HRESULT StrandBoundingBoxEx([in]IIndexArray* fill, [out,retval]IRect2d** box);
      [helpstring("method StrandIndexToGridIndexEx")] HRESULT StrandIndexToGridIndexEx([in]IIndexArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
	   [propget,helpstring("property FilledGridBoundsEx")] HRESULT FilledGridBoundsEx([in]IIndexArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);

      // Debonding - could go into another interface, but it's handy to have it here
      // count of debonded strands at current fill
      [helpstring("method GetStrandDebondCount")] HRESULT GetStrandDebondCount([in]WDebondLocationType loc, [out,retval] StrandIndexType* count);

      // Debond  strands based on Grid index
      [helpstring("method DebondStrandByGridIndex")] HRESULT DebondStrandByGridIndex([in]GridIndexType grdIndex,[in]Float64 l1,[in]Float64 l2);
      [helpstring("method GetDebondedStrandsByGridIndex")] HRESULT GetDebondedStrandsByGridIndex([out,retval]IIndexArray** grdIndexes);
      [helpstring("method GetDebondLengthByGridIndex")] HRESULT GetDebondLengthByGridIndex([in]GridIndexType grdIndex, [out]Float64* XCoord, [out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);

      // Debonded  strands based on Positions index (i.e., from GetStrandPositions)
      [helpstring("method GetDebondLengthByPositionIndex")] HRESULT GetDebondLengthByPositionIndex([in]StrandIndexType positionIndex,[out]Float64* XCoord,[out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);
      [helpstring("method GetStrandsDebondedByPositionIndex")] HRESULT GetStrandsDebondedByPositionIndex([in]Float64 distFromStart, [in]Float64 girderLength, [out,retval]IIndexArray** positionIndexes);

      // Distance that a strand is bonded (left and right) for a given location. Also returns strand's Y coordinate
      // Note that versions are for position and grid indexing
      [helpstring("method GetBondedLengthByPositionIndex")] HRESULT GetBondedLengthByPositionIndex([in]StrandIndexType positionIndex, [in]Float64 distFromStart, [in]Float64 girderLength,
         [out]Float64* XCoord, [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);

      [helpstring("method GetBondedLengthByGridIndex")] HRESULT GetBondedLengthByGridIndex([in]GridIndexType grdIndex, [in]Float64 distFromStart, [in]Float64 girderLength,
         [out]Float64* XCoord, [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);

      [propget,helpstring("property StrandDebondInRow")] HRESULT StrandDebondInRow([in] RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);
      [helpstring("method IsExteriorStrandDebondedInRow")] HRESULT IsExteriorStrandDebondedInRow([in] RowIndexType rowIndex,[out,retval]VARIANT_BOOL* bResult);

      [helpstring("method GetDebondSections")] HRESULT GetDebondSections([out]IDblArray** arrLeft,[out]IDblArray** arrRight);
      [helpstring("method GetDebondAtLeftSection")] HRESULT GetDebondAtLeftSection([in]SectionIndexType sectionIdx,[out,retval]IIndexArray** strandIndexes);
      [helpstring("method GetDebondAtRightSection")] HRESULT GetDebondAtRightSection([in]SectionIndexType sectionIdx,[out,retval]IIndexArray** strandIndexes);

      [helpstring("method GetDebondedRows")] HRESULT GetDebondedRows([out]IIndexArray** ppRowIndexes); // returns the indicies of rows that have debonded strands
      [helpstring("method GetDebondedConfigurationCountByRow")] HRESULT GetDebondedConfigurationCountByRow([in]RowIndexType rowIdx, [out]IndexType* pConfigCount); // returns number of different debonding configurations in this row
      // Returns a debonding configuration in this row. CG's are in strand coordinates
      [helpstring("method GetDebondConfigurationByRow")] HRESULT GetDebondConfigurationByRow([in]RowIndexType rowIdx, [in]IndexType configIdx, [out]Float64* pLdbStart, [out]Float64* pLdbEnd, [out]Float64* pCgX, [out]Float64* pCgY, [out]IndexType* pnStrands); 

	  [helpstring("method ClearDebonding")] HRESULT ClearDebonding();
   };

   [
      object,
      oleautomation,
      uuid(DBD342C8-9EA4-408c-9CF5-27744DE0CA60),
      helpstring("IStrandFillTool Interface"),
      pointer_default(unique)
   ]
   interface IStrandFillTool : IUnknown
   {
      [helpstring("method ComputeHarpedStrandMaxFill")] HRESULT ComputeHarpedStrandMaxFill([in]IStrandGridFiller* pEndGridFiller,[in]IStrandGridFiller* pHPGridFiller,[out]StrandIndexType* pMaxStrandCount,[out]IIndexArray** ppStrandFill);
   };

   [
      object,
      uuid(8FA01191-9197-4584-83CA-D60535123BC2),
      helpstring("IStrandModel Interface"),
      pointer_default(unique)
   ]
   interface IStrandModel : IUnknown
   {
      [helpstring("method Initialize")] HRESULT Initialize([in]ISuperstructureMemberSegment* segment,[in]IPrecastGirder* pGirder);

      // strand material
      [propputref, helpstring("property StrandMaterial")] HRESULT StrandMaterial([in]StrandType strandType,[in]IPrestressingStrand* pMaterial);
      [propget, helpstring("property StrandMaterial")] HRESULT StrandMaterial([in]StrandType strandType, [out, retval]IPrestressingStrand** ppMaterial);
      
      // strand geometry
      [propput, helpstring("property StraightStrandProfileType")] HRESULT StraightStrandProfileType([in]StrandProfileType profileType);
      [propget, helpstring("property StraightStrandProfileType")] HRESULT StraightStrandProfileType([out, retval]StrandProfileType* pProfileType);
      [propput, helpstring("property TemporaryStrandProfileType")] HRESULT TemporaryStrandProfileType([in]StrandProfileType profileType);
      [propget, helpstring("property TemporaryStrandProfileType")] HRESULT TemporaryStrandProfileType([out, retval]StrandProfileType* pProfileType);

      // harp points
      [helpstring("method SetHarpingPoints")] HRESULT SetHarpingPoints([in]Float64 hp1, [in]Float64 hp2);
      [helpstring("method GetHarpingPoints")] HRESULT GetHarpingPoints([out]Float64* hp1, [out]Float64* hp2);
      [helpstring("method SetEndHarpingPoints")] HRESULT SetEndHarpingPoints([in]Float64 hp1, [in]Float64 hp2);
      [helpstring("method GetEndHarpingPoints")] HRESULT GetEndHarpingPoints([out]Float64* hp1, [out]Float64* hp2);
      [propput, helpstring("property UseMinHarpPointDistance")] HRESULT UseMinHarpPointDistance([in]VARIANT_BOOL bUseMin);
      [propget, helpstring("property UseMinHarpPointDistance")] HRESULT UseMinHarpPointDistance([out, retval]VARIANT_BOOL* bUseMin);
      [propput, helpstring("method MinHarpPointDistance")] HRESULT MinHarpPointDistance([in]Float64 minHpDist);
      [propget, helpstring("method MinHarpPointDistance")] HRESULT MinHarpPointDistance([out, retval]Float64* minHpDist);
      [propput, helpstring("property HarpingPointMeasure")] HRESULT HarpingPointMeasure([in] HarpPointMeasure measure);
      [propget, helpstring("property HarpingPointMeasure")] HRESULT HarpingPointMeasure([out, retval] HarpPointMeasure* measure);
      [propput, helpstring("property EndHarpingPointMeasure")] HRESULT EndHarpingPointMeasure([in] HarpPointMeasure measure);
      [propget, helpstring("property EndHarpingPointMeasure")] HRESULT EndHarpingPointMeasure([out, retval] HarpPointMeasure* measure);
      [propput, helpstring("property HarpingPointReference")] HRESULT HarpingPointReference([in] HarpPointReference hpRef);
      [propget, helpstring("property HarpingPointReference")] HRESULT HarpingPointReference([out, retval] HarpPointReference* hpRef);
      [propput, helpstring("property EndHarpingPointReference")] HRESULT EndHarpingPointReference([in] HarpPointReference hpRef);
      [propget, helpstring("property EndHarpingPointReference")] HRESULT EndHarpingPointReference([out, retval] HarpPointReference* hpRef);
      [helpstring("method GetHarpingPointLocations")] HRESULT GetHarpingPointLocations([out]Float64* hp1, [out]Float64* hp2);
      [helpstring("method GetEndHarpingPointLocations")] HRESULT GetEndHarpingPointLocations([out]Float64* hp1, [out]Float64* hp2);

      // Strands representeded as rows
      [helpstring("method GetStrandRowCount")] HRESULT GetStrandRowCount([in]StrandType strandType, [in]Float64 Xs, [out, retval]RowIndexType* nRows);
      [helpstring("method GetNumStrandsInRow")] HRESULT GetNumStrandsInRow([in]StrandType strandType, [in]Float64 Xs, [in]RowIndexType rowIdx, [out, retval]StrandIndexType* nStrands);
      [helpstring("method GetStrandsInRow")] HRESULT GetStrandsInRow([in]StrandType strandType, [in]Float64 Xs, [in]RowIndexType rowIdx, [out, retval]IIndexArray** ppStrandIndicies);

      [helpstring("method GetUnadjustedStrandRowElevation")] HRESULT GetUnadjustedStrandRowElevation([in]StrandType strandType, [in]Float64 Xs, [in]RowIndexType rowIdx, [out, retval]Float64* fElevation);

      // Debonded strands are not removed
      // Locations are adjusted by offsets
      [helpstring("method GetStrandPositions")] HRESULT GetStrandPositions([in]StrandType strandType, [in]Float64 Xs, [out, retval]IPoint2dCollection** ppPoints);
      [helpstring("method GetStrandCount")] HRESULT GetStrandCount([in]StrandType strandType, [out, retval]StrandIndexType* pStrands);
      [helpstring("method StrandCG")] HRESULT GetStrandCG([in]StrandType strandType,[in] Float64 Xs, [out, retval]IPoint2d** pntCG);
      [helpstring("method ComputeMaxHarpedStrandSlope")] HRESULT ComputeMaxHarpedStrandSlope([in]Float64 Xs, [out, retval]Float64* pSlope);
      [helpstring("method ComputeAvgHarpedStrandSlope")] HRESULT ComputeAvgHarpedStrandSlope([in]Float64 Xs, [out, retval]Float64* pSlope);
      [helpstring("method GetStrandProfile")] HRESULT GetStrandProfile([in]StrandType strandType, [in]StrandIndexType strandIdx, [out, retval]IPoint2dCollection** ppProfile);
      [helpstring("method GetStrandCGProfile")] HRESULT GetStrandCGProfile([in]VARIANT_BOOL bIncludeTempStrands, [out, retval]IPoint2dCollection** ppProfile);

      [helpstring("method StraightStrandBoundingBox")] HRESULT StraightStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);
      [helpstring("method HarpedEndStrandBoundingBox")] HRESULT HarpedEndStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);
      [helpstring("method HarpedHpStrandBoundingBox")] HRESULT HarpedHpStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);

      // Debonded straight strands based on Positions index (i.e., from get_StraightStrandPositions)
      [helpstring("method GetStraightStrandDebondLengthByPositionIndex")] HRESULT GetStraightStrandDebondLengthByPositionIndex([in]Float64 Xs,[in]StrandIndexType positionIndex, [out]Float64* XCoord, [out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);
      [helpstring("method GetStraightStrandsDebondedByPositionIndex")] HRESULT GetStraightStrandsDebondedByPositionIndex([in]Float64 Xs, [out,retval]IIndexArray** positionIndexes);

      // debonding (straight strands only)
      [helpstring("method GetStraightStrandDebondCount")] HRESULT GetStraightStrandDebondCount([in]WDebondLocationType loc, [out, retval]StrandIndexType* pCount);
      [helpstring("method GetDebondingLocations")] HRESULT GetDebondingLocations([in]StrandType strandType,[out]IDblArray** arrLeft, [out]IDblArray** arrRight);
      [helpstring("method GetDebondedStrandsAtSection")] HRESULT GetDebondedStrandsAtSection([in]EndType endType,[in]StrandType strandType,[in]SectionIndexType sectionIdx, [out, retval]IIndexArray** pstnIndexes);
      // Distance that a strand is bonded (left and right) for a given location. Also returns strand's Y coordinate
      [helpstring("method GetStraightStrandBondedLengthByPositionIndex")] HRESULT GetStraightStrandBondedLengthByPositionIndex([in]StrandIndexType positionIndex, [in]Float64 Xs, [out]Float64* XCoord, [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);
      [propget, helpstring("property StraightStrandDebondInRow")] HRESULT StraightStrandDebondInRow([in]Float64 Xs,[in] RowIndexType rowIdx, [out, retval]StrandIndexType* nStrands);
      [helpstring("method IsExteriorStraightStrandDebondedInRow")] HRESULT IsExteriorStraightStrandDebondedInRow([in]Float64 Xs, [in] RowIndexType rowIndex, [out, retval]VARIANT_BOOL* bResult);
      [helpstring("method GetStraightStrandDebondedConfigurationCountByRow")] HRESULT GetStraightStrandDebondedConfigurationCountByRow([in]Float64 Xs, [in]RowIndexType rowIdx, [out]IndexType* pConfigCount); // returns number of different debonding configurations in this row
      [helpstring("method GetStraightStrandDebondConfigurationByRow")] HRESULT GetStraightStrandDebondConfigurationByRow([in]Float64 Xs, [in]RowIndexType rowIdx, [in]IndexType configIdx, [out]Float64* pXstart, [out]Float64* pBondedLength, [out]Float64* pCgX, [out]Float64* pCgY, [out]IndexType* pnStrands); // returns a debonding configuration in this row
      [helpstring("method GetStraightStrandDebondedRows")] HRESULT GetStraightStrandDebondedRows([in]Float64 Xs,[out]IIndexArray** ppRowIndexes); // returns the indicies of rows that have debonded strands
   };

   [
      object,
      uuid(B9B537AA-7043-435E-8EDA-C36D7EA2D86B),
      helpstring("IStrandGridModel"),
      pointer_default(unique)
   ]
   interface IStrandGridModel : IStrandModel
   {
      [helpstring("method SetStrandMovers")] HRESULT SetStrandMovers([in]IStrandMover* pStartStrandMover, [in]IStrandMover* pHp1StrandMover, [in]IStrandMover* pHp2StrandMover, [in]IStrandMover* pEndStrandMover);
      [propputref, helpstring("property StrandMover")] HRESULT StrandMover([in]StrandGridType sgType, [in]EndType endType, [in]IStrandMover* pStrandMover);
      [propget, helpstring("property StrandMover")] HRESULT StrandMover([in]StrandGridType sgType, [in]EndType endType, [out, retval]IStrandMover** ppStrandMover);

      [propget, helpstring("property StraightStrandGrid")] HRESULT StraightStrandGrid([in]EndType endType, [out, retval]IStrandGrid** ptrn);
      [propget, helpstring("property TemporaryStrandGrid")] HRESULT TemporaryStrandGrid([in]EndType endType, [out, retval]IStrandGrid** ptrn);
      [propget, helpstring("property HarpedStrandGridEnd")] HRESULT HarpedStrandGridEnd([in]EndType endType, [out, retval]IStrandGrid** ptrn);
      [propget, helpstring("property HarpedStrandGridHP")] HRESULT HarpedStrandGridHP([in]EndType endType, [out, retval]IStrandGrid** ptrn);

      // Get all strand locations based on current fill, or input fill. 
      // Debonded strands are not removed
      // Locations are adjusted by offset
      [helpstring("method StrandPositionsEx")] HRESULT GetStrandPositionsEx([in]StrandType strandType,[in] Float64 Xs, [in]IIndexArray* fill, [out, retval]IPoint2dCollection** points);
      [helpstring("method StrandCGEx")] HRESULT GetStrandCGEx([in]StrandType strandType, [in] Float64 Xs, [in]IIndexArray* fill,[out, retval]IPoint2d** pntCG);
      [helpstring("method GetStrandCountEx")] HRESULT GetStrandCountEx([in]StrandType strandType, [in]IIndexArray* fill,[out, retval]StrandIndexType* pStrands);

      // Compute bounding boxes of harped and straight strands accounting for vertical offsets for harped strands
      [helpstring("method StraightStrandBoundingBoxEx")] HRESULT StraightStrandBoundingBoxEx([in]EndType endType, [in] IIndexArray* fill, [out,retval]IRect2d** box);
      [helpstring("method HarpedEndStrandBoundingBoxEx")] HRESULT HarpedEndStrandBoundingBoxEx([in]EndType endType, [in] IIndexArray* fill, [out,retval]IRect2d** box);
      [helpstring("method HarpedHpStrandBoundingBoxEx")] HRESULT HarpedHpStrandBoundingBoxEx([in]EndType endType, [in] IIndexArray* fill, [out,retval]IRect2d** box);

      [propput, helpstring("property AllowOddNumberOfHarpedStrands")] HRESULT AllowOddNumberOfHarpedStrands([in]VARIANT_BOOL bUseMin);
      [propget, helpstring("property AllowOddNumberOfHarpedStrands")] HRESULT AllowOddNumberOfHarpedStrands([out, retval]VARIANT_BOOL* bUseMin);

      [propput, helpstring("property UseDifferentHarpedGridsAtEnds")] HRESULT UseDifferentHarpedGridsAtEnds([in]VARIANT_BOOL bUseDifferent);
      [propget, helpstring("property UseDifferentHarpedGridsAtEnds")] HRESULT UseDifferentHarpedGridsAtEnds([out, retval]VARIANT_BOOL* bUseDifferent);

      // default design increments for vertical adjustment of strands at end and harping points
      // NOTE: If this value is less than zero, NO adjustment will be made.
      [propget, helpstring("property HarpedEndAdjustmentIncrement")] HRESULT HarpedEndAdjustmentIncrement([out, retval]Float64* increment);
      [propget, helpstring("property HarpedHpAdjustmentIncrement")] HRESULT HarpedHpAdjustmentIncrement([out, retval]Float64* increment);

      // Returns the top elevation of the strand grids, relative to the top of the girder. Max elevation is 0.0 at the top surface of the girder
      [propget, helpstring("property TopElevation")] HRESULT TopElevation([out, retval]Float64* offset);

      // Vertical adjustments of harped strands
      // Cannot be set to a non-zero value if Increment (above) is negative.
      [propget, helpstring("property HarpedStrandAdjustmentEnd")] HRESULT HarpedStrandAdjustmentEnd([in]EndType endType, [out, retval]Float64* offset);
      [propput, helpstring("property HarpedStrandAdjustmentEnd")] HRESULT HarpedStrandAdjustmentEnd([in]EndType endType, [in]Float64 offset);
      [propget, helpstring("property HarpedStrandAdjustmentHP")] HRESULT HarpedStrandAdjustmentHP([in]EndType endType, [out, retval]Float64* offset);
      [propput, helpstring("property HarpedStrandAdjustmentHP")] HRESULT HarpedStrandAdjustmentHP([in]EndType endType, [in]Float64 offset);

      [helpstring("method GetMaxStrandFill")] HRESULT GetMaxStrandFill([in]StrandType strandType,[out, retval]IIndexArray** fill);

      [propputref, helpstring("property StrandFill")] HRESULT StrandFill([in]StrandType strandType, [in]IIndexArray* fill);
      [propget, helpstring("property StrandFill")] HRESULT StrandFill([in]StrandType strandType,[out, retval]IIndexArray** fill);

      // Convert strand index (defined in IPoint2dCollection's above) to Grid index
      [helpstring("method StrandIndexToGridIndex")] HRESULT StrandIndexToGridIndex([in]StrandType strandType,[in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method StrandIndexToGridIndexEx")] HRESULT StrandIndexToGridIndexEx([in]StrandType strandType, [in]IIndexArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);


      // Compute offset adjustment required in order to put harped strands within proper bounds
      // If zero, no adjustment is required. 
      // If non-zero, add this number to current offset to move current harped strands just enough to fit within cross section boundary
      [helpstring("method HarpedEndStrandBoundaryCheck")] HRESULT HarpedEndStrandBoundaryCheck([in]EndType endType, [out, retval]Float64* adjustment);
      [helpstring("method HarpedHpStrandBoundaryCheck")] HRESULT HarpedHpStrandBoundaryCheck([in]EndType endType, [out, retval]Float64* adjustment);

      // Max allowable up or down strand adjustment to keep strands in bounds
      [helpstring("method GetHarpedEndAdjustmentBounds")] HRESULT GetHarpedEndAdjustmentBounds([in]EndType endType, [out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
      [helpstring("method GetHarpedEndAdjustmentBoundsEx")] HRESULT GetHarpedEndAdjustmentBoundsEx([in]EndType endType, [in] IIndexArray* fill, [out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
      [helpstring("method GetHarpedHpAdjustmentBounds")] HRESULT GetHarpedHpAdjustmentBounds([in]EndType endType, [out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
      [helpstring("method GetHarpedHpAdjustmentBoundsEx")] HRESULT GetHarpedHpAdjustmentBoundsEx([in]EndType endType, [in] IIndexArray* fill, [out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);

      [helpstring("property GetHarpedEndFilledGridBoundsEx")] HRESULT GetHarpedEndFilledGridBoundsEx([in]EndType endType, [in]IIndexArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);
      [helpstring("property GetHarpedHpFilledGridBoundsEx")] HRESULT GetHarpedHpFilledGridBoundsEx([in]EndType endType, [in]IIndexArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);

      [helpstring("method ComputeMaxHarpedStrandSlopeEx")] HRESULT ComputeMaxHarpedStrandSlopeEx([in]Float64 Xs, [in]IIndexArray* fill, [in] Float64 startOffset, [in] Float64 hp1Offset, [in] Float64 hp2Offset, [in] Float64 endOffset, [out, retval]Float64* slope);
      [helpstring("method ComputeAvgHarpedStrandSlopeEx")] HRESULT ComputeAvgHarpedStrandSlopeEx([in]Float64 Xs, [in]IIndexArray* fill, [in] Float64 startOffset, [in] Float64 hp1Offset, [in] Float64 hp2Offset, [in] Float64 endOffset, [out, retval]Float64* slope);

      // Returns the maximum possible number of strands the grid can hold
      [helpstring("method GetMaxStrands")] HRESULT GetMaxStrands([in]StrandType strandType,[out, retval]StrandIndexType* nStrands);

      // Debond straight strands based on Grid index
      [helpstring("method ClearStraightStrandDebonding")] HRESULT ClearStraightStrandDebonding();
      [helpstring("method DebondStraightStrandByGridIndex")] HRESULT DebondStraightStrandByGridIndex([in]GridIndexType grdIndex, [in]Float64 l1, [in]Float64 l2);
      [helpstring("method GetDebondedStraightStrandsByGridIndex")] HRESULT GetDebondedStraightStrandsByGridIndex([out, retval]IIndexArray** grdIndexes);
      [helpstring("method GetStraightStrandDebondLengthByGridIndex")] HRESULT GetStraightStrandDebondLengthByGridIndex([in]EndType endType, [in]GridIndexType grdIndex, [out]Float64* XCoord, [out]Float64* YCoord, [out]Float64* l1, [out]Float64* l2);
      [helpstring("method GetStraightStrandBondedLengthByGridIndex")] HRESULT GetStraightStrandBondedLengthByGridIndex([in]GridIndexType grdIndex, [in]Float64 distFromStart, [out]Float64* XCoord, [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);
   };

   [
      object,
      uuid(934A44A7-8D94-4BE3-B8FA-4E159A817A29),
      helpstring("IStrandPointModel"),
      pointer_default(unique)
   ]
   interface IStrandPointModel : IStrandModel
   {
      [helpstring("method AddStraightStrand")] HRESULT AddStraightStrand([in]Float64 X, [in]Float64 Ys, [in]Float64 Ye, [in]VARIANT_BOOL vbExtendedStart, [in]VARIANT_BOOL vbExtendedEnd, [in]Float64 debondLeft, [in]Float64 debondRight);
      [helpstring("method AddHarpedStrand")] HRESULT AddHarpedStrand([in]Float64 X, [in]Float64 Ys, [in]Float64 Yhp1, [in]Float64 Yhp2, [in]Float64 Ye);
      [helpstring("method AddTemporaryStrand")] HRESULT AddTemporaryStrand([in]Float64 X, [in]Float64 Ys, [in]Float64 Ye);
   };

	[
		object,
		oleautomation,
		uuid(231B2534-7714-459c-A2CE-A2195474A2C2),
		helpstring("IPrecastGirder Interface"),
		pointer_default(unique)
	]
	interface IPrecastGirder : IUnknown
	{
      [helpstring("method Initialize")] HRESULT Initialize([in]ISuperstructureMemberSegment* segment);

      [propget, helpstring("property SpanLength")] HRESULT SpanLength([out, retval] Float64* length);
      [propget, helpstring("property GirderLength")] HRESULT GirderLength([out, retval] Float64* length);
      [propget, helpstring("property LeftEndSize")] HRESULT LeftEndDistance([out, retval] Float64* size);
      [propget, helpstring("property RightEndSize")] HRESULT RightEndDistance([out, retval] Float64* size);
      [propget, helpstring("property LeftBearingOffset")] HRESULT LeftBearingOffset([out, retval] Float64* offset);
      [propget, helpstring("property RightBearingOffset")] HRESULT RightBearingOffset([out, retval] Float64* offset);
      [helpstring("method GetEndPoints")] HRESULT GetEndPoints([out]IPoint2d** pntPier1, [out]IPoint2d** pntEnd1, [out]IPoint2d** pntBrg1, [out]IPoint2d** pntBrg2, [out]IPoint2d** pntEnd2, [out]IPoint2d** pntPier2);

      [propputref, helpstring("property StrandModel")] HRESULT StrandModel([in]IStrandModel* pStrandModel);
      [propget, helpstring("property StrandModel")] HRESULT StrandModel([out, retval]IStrandModel** ppStrandModel);
      [propputref, helpstring("property Tendons")] HRESULT Tendons([in]ITendonCollection* pTendons);
      [propget, helpstring("property Tendons")] HRESULT Tendons([out, retval]ITendonCollection** ppTendons);
      [propget, helpstring("property SuperstructureMemberSegment")] HRESULT SuperstructureMemberSegment([out, retval]ISuperstructureMemberSegment** segment);
      [propget, helpstring("property RebarLayout")] HRESULT RebarLayout([out, retval]IRebarLayout** rebarLayout);
      [propget, helpstring("property ClosureJointRebarLayout")] HRESULT ClosureJointRebarLayout([out, retval]IRebarLayout** rebarLayout);
	};

	[
		object,
		oleautomation,
		uuid(C5CBE002-A27E-408c-91DF-56A6AF5346BC),
		helpstring("BridgeGeometryTool Interface"),
		pointer_default(unique)
	]
	interface IBridgeGeometryTool : IUnknown
	{
	   [helpstring("method PointBySSMbr")] HRESULT PointBySSMbr([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] Float64 distFromStartOfSSMbr,[out,retval] IPoint2d** point);
	   [helpstring("method PointBySegment")] HRESULT PointBySegment([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] SegmentIndexType segIdx, [in] Float64 Xs,[out,retval] IPoint2d** point);
	   [helpstring("method StationAndOffsetBySSMbr")] HRESULT StationAndOffsetBySSMbr([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] Float64 distFromStartOfSSMbr,[out] IStation** station, [out] Float64* offset);
	   [helpstring("method StationAndOffsetBySegment")] HRESULT StationAndOffsetBySegment([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] SegmentIndexType segIdx, [in] Float64 Xs,[out] IStation** station, [out] Float64* offset);
	   [helpstring("method GirderPathOffset")] HRESULT GirderPathOffset([in] IGenericBridge* bridge,[in] GirderIDType ssMbrID, [in] SegmentIndexType segIdx,[in] VARIANT varStation, [out,retval] Float64* offset);
      [helpstring("method GirderPathPoint")] HRESULT GirderPathPoint([in]IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]SegmentIndexType segIdx, [in]VARIANT varStation,[in]VARIANT varDirection,[in]VARIANT_BOOL vbProject,[out,retval]IPoint2d** ppPoint);
	   [helpstring("method DeckEdgePoint")] HRESULT DeckEdgePoint([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] IPoint2d** point);
	   [helpstring("method DeckEdgePoints")] HRESULT DeckEdgePoints([in] IGenericBridge* bridge,[in] DirectionType side,[in] CollectionIndexType nPoints,[out,retval] IPoint2dCollection** points);
	   [helpstring("method CurbOffset")] HRESULT CurbOffset([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out]IStation** ppOffsetStation,[out] Float64* pOffset);
	   [helpstring("method DeckOffset")] HRESULT DeckOffset([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out]IStation** ppOffsetStation,[out] Float64* pOffset);
      [helpstring("method DeckOverhang")] HRESULT DeckOverhang([in] IGenericBridge* bridge,[in] Float64 station, [in]GirderIDType ssMbrID,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOverhang);
      [helpstring("method DeckOverhangBySSMbr")] HRESULT DeckOverhangBySSMbr([in] IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]Float64 distFromStartOfSSMbr,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOverhang);
      [helpstring("method DeckOverhangBySegment")] HRESULT DeckOverhangBySegment([in] IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in] SegmentIndexType segIdx,[in]Float64 Xs,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOverhang);
      [helpstring("method GirderSpacingBySSMbr")] HRESULT GirderSpacingBySSMbr([in] IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in]Float64 distFromStartOfSSMbr,[in]GirderIDType otherSSMbrID,[out,retval]Float64* pSpacing);
      [helpstring("method GirderSpacingBySegment")] HRESULT GirderSpacingBySegment([in] IGenericBridge* bridge,[in]GirderIDType ssMbrID,[in] SegmentIndexType segIdx,[in]Float64 Xs,[in]GirderIDType otherSSMbrID,[out,retval]Float64* pSpacing);
      // Get offset to interior curbs. Other method always return offset of exterior barrier curbs
	   [helpstring("method InteriorCurbOffset")] HRESULT InteriorCurbOffset([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out]IStation** ppOffsetStation,[out] Float64* pOffset);
	   [helpstring("method CurbLinePoint")] HRESULT CurbLinePoint([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] IPoint2d** point);
	};

	[
		uuid(8B4B8193-D5C8-4e1f-86D1-D7044859B9CC),
		helpstring("FlexRebarLayoutItem")
	]
	coclass FlexRebarLayoutItem
	{
		[default] interface IFlexRebarLayoutItem;
	};

	[
		uuid(7DDC7A24-05FA-4565-92AC-4FFD54D5063D),
		helpstring("EffectiveFlangeWidthDetails Class")
	]
	coclass EffectiveFlangeWidthDetails
	{
		[default] interface IEffectiveFlangeWidthDetails;
	};
		
	[
		uuid(7AF06A24-3EF5-433B-9A03-B22A8404048B),
		helpstring("EffectiveFlangeWidthTool Class")
	]
	coclass EffectiveFlangeWidthTool
	{
		[default] interface IEffectiveFlangeWidthTool;
	};

	[
		uuid(88738282-9CE8-4553-BC7E-4DB1DF3D8809),
		helpstring("SectionCutTool Class")
	]
	coclass SectionCutTool
	{
		[default] interface ISectionCutTool;
	};

	[
	   uuid(6E8068AB-ABC2-4cae-A31B-74ABD7500570),
	   helpstring("PrecastGirder Class")
	]
	coclass PrecastGirder
	{
	   [default] interface IPrecastGirder;
	};

	[
	   uuid(77B0384B-5C9D-46ac-A8B6-AA8ADA58B37D),
	   helpstring("BridgeGeometryTool Class")
	]
	coclass BridgeGeometryTool
	{
	   [default] interface IBridgeGeometryTool;
	};

   [
      uuid(F8541730-D6F9-4CB5-9921-411476988622),
      helpstring("StrandGridModel Class")
   ]
   coclass StrandGridModel
   {
      [default] interface IStrandGridModel;
   };

   [
      uuid(C4B902B2-8EB1-44D1-A24E-8C2DDC7BC294),
      helpstring("StrandPointModel Class")
   ]
   coclass StrandPointModel
   {
      [default] interface IStrandPointModel;
   };

   [
		uuid(A547E2F5-BE84-49F9-846E-2A5B2C2FD53F),
		helpstring("StrandGrid Class")
	]
	coclass StrandGrid
	{
		[default] interface IStrandGrid;
      interface IStrandGridFiller;
	};

   [
      uuid(A757985C-CC7F-4789-B3F3-03BCCED77970),
      helpstring("StrandFillTool Class")
   ]
   coclass StrandFillTool
   {
      [default] interface IStrandFillTool;
   };

	[
		uuid(2C4F5781-2FD5-4fcc-AC8F-E8CD9C324066),
		helpstring("BridgeDeckRebarLayout")
	]
	coclass BridgeDeckRebarLayout
	{
		[default] interface IBridgeDeckRebarLayout;
	};
};
