///////////////////////////////////////////////////////////////////////
// GenericBridgeTools - Tools for manipluating the Generic Bridge Modeling
// Copyright © 1999-2011  Washington State Department of Transportation
//                        Bridge and Structures Office
//
// This library is a part of the Washington Bridge Foundation Libraries
// and was developed as part of the Alternate Route Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the Alternate Route Library Open Source License as 
// published by the Washington State Department of Transportation,
// Bridge and Structures Office.
//
// This program is distributed in the hope that it will be useful,
// but is distributed AS IS, WITHOUT ANY WARRANTY; without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
// PURPOSE.  See the Alternate Route Library Open Source License for more details.
//
// You should have received a copy of the Alternate Route Library Open Source License
// along with this program; if not, write to the Washington State
// Department of Transportation, Bridge and Structures Office,
// P.O. Box 47340, Olympia, WA 98503, USA or e-mail
// Bridge_Support@wsdot.wa.gov
///////////////////////////////////////////////////////////////////////

// GenericBridgeTools.idl : IDL source for GenericBridgeTools.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (GenericBridgeTools.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";
import "WBFLTypes.idl";
import "WBFLTools.idl";
import "WBFLUnitServer.idl";
import "WBFLGeometry.idl";
import "WBFLSections.idl";
import "WBFLCogo.idl";
//import "WBFLGenericBridge.idl";

cpp_quote("#include <WBFLGenericBridge.h>")
cpp_quote("#define GBMT_E_UNKNOWNDECKTYPE             MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,512)")
cpp_quote("#define GBMT_E_GIRDERSECTION               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,513)")
cpp_quote("#define GBMT_E_NODECK                      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,514)")
cpp_quote("#define GBMT_E_COMPOSITEDECK               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,515)")
cpp_quote("#define GBMT_E_MATERIAL                    MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,516)")
cpp_quote("#define GBMT_E_SHAPE                       MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,517)")
cpp_quote("#define GBMT_E_REMOVEDEBOND                MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,518)")

interface IRebarLayoutItem;


[
	uuid(B7AEBB77-85BC-4FB0-BD1F-1078DB8FF85E),
	version(1.0),
	helpstring("WBFLGenericBridgeTools Library")
]
library WBFLGenericBridgeTools
{
	importlib("stdole32.tlb");
	importlib("stdole2.tlb");
   importlib("WBFLGenericBridge.tlb");

   // forward declaration
   interface IRebarLayout;

   typedef [public,helpstring("enum HarpPointReference"),uuid(9744FFFE-8025-422e-A4C3-9A58B48DD102)] 
   enum 
   {
       hprEndOfGirder    = 0,
	   hprBearing        = 1,
	   hprCenterOfGirder = 2,
   } HarpPointReference;

   typedef [public,helpstring("enum HarpPointMeasure"),uuid(97051264-41BA-4691-9C4E-CDE659BB2C5A)] 
   enum 
   {
       hpmFractionOfSpanLength   = 0,
	   hpmFractionOfGirderLength = 1,
	   hpmAbsoluteDistance       = 2
   } HarpPointMeasure;

   typedef [public,helpstring("enum RebarRowOrientation"),uuid(28251F79-72F8-4d9d-85EB-55426AC53CC6)]
   enum 
   {
		rroRight,   // horizontal row towards the right, anchor at left edge
		rroHCenter, // horizontal row, anchor at center
		rroLeft,    // horizontal row towards the left, anchor at right edge
		rroDown,    // vertical row downwards, anchor at top
		rroVCenter, // vertical row, anchor at center
		rroUp       // vertical row upwards, anchor at bottom
   } RebarRowOrientation;

   typedef [public,helpstring("enum LayoutPosition"),uuid(9246CAAE-3CAD-401f-BB00-0DA5EFA41EE2)]
   enum 
   {
	   lpLeft,
	   lpCenter,
	   lpRight
   } LayoutPosition;

   typedef [public,helpstring("enum MaterialSpec"),uuid(6033AA61-EB06-469e-8743-CFA09545FE96)]
   enum 
   {
      msA615,
      msA706
   } MaterialSpec;

   typedef [public,helpstring("enum RebarGrade"),uuid(3DB21D7F-CA67-453a-9E62-FE9989BBBEA7)]
   enum 
   {
		Grade40,
		Grade60,
		Grade75,
      Grade80
   } RebarGrade;

   typedef [public,helpstring("enum BarSize"),uuid(FCC0993E-988B-4bf2-A708-094AC20B51BA)]
   enum 
   {
		bs3 = 3, 
		bs4 = 4,
		bs5 = 5,
		bs6 = 6,
		bs7 = 7,
		bs8 = 8,
		bs9 = 9,
		bs10 = 10,
		bs11 = 11,
		bs14 = 14,
		bs18 = 18
   } BarSize;

   typedef [public,helpstring("enum BarrierSectionCut"),uuid(B87307A0-81D1-41e5-A115-E1CAB0E39A43)]
   enum 
   {
      bscNone,  // don't include barrier in section cut
	  bscStructurallyContinuousOnly, // include only the structurally continuous portion of the barrier
	  bscAll // enclude all components of the barrier
   } BarrierSectionCut;

   [
      object,
	  oleautomation,
	  uuid(262B5A19-8911-45de-A53D-DC7CDB73809E),
	  helpstring("IEffectiveFlangeWidthDetails"),
	  pointer_default(unique)
   ]
   interface IEffectiveFlangeWidthDetails : IUnknown
   {
	  [propput] HRESULT EffectiveSpanLength([in] Float64 length);
	  [propget] HRESULT EffectiveSpanLength([out,retval] Float64* length);
	  [propput] HRESULT SlabThickness([in] Float64 tSlab);
	  [propget] HRESULT SlabThickness([out,retval] Float64* tSlab);
	  [] HRESULT AddFlangeParameters([in]Float64 tWeb,[in]Float64 wFlange,[in]Float64 lSpacing,[in]Float64 rSpacing);
	  [propget] HRESULT FlangeCount([out,retval]FlangeIndexType* nFlange);
	  [] HRESULT GetFlangeParameters([in] FlangeIndexType flangeIdx,[out]Float64* tWeb,[out]Float64* wFlange,[out]Float64* lSpacing,[out]Float64* rSpacing);

	  [] HRESULT EffectiveFlangeWidth([out,retval] Float64* effFlangeWidth);
   };

	[
		object,
		oleautomation,
		uuid(ACD48CEC-704A-417D-B070-30DA37BAFFB4),
		helpstring("IEffectiveFlangeWidthTool Interface"),
		pointer_default(unique)
	]
	interface IEffectiveFlangeWidthTool : IUnknown
	{
	   [helpstring("method TributaryFlangeWidth")] HRESULT TributaryFlangeWidth([in]IGenericBridge* bridge,[in]SpanIndexType span,[in]GirderIndexType gdr,[in]Float64 location, [out,retval]Float64 *tribFlangeWidth);
	   [helpstring("method TributaryFlangeWidthEx")] HRESULT TributaryFlangeWidthEx([in]IGenericBridge* bridge,[in]SpanIndexType span,[in]GirderIndexType gdr,[in]Float64 location,[out] Float64* twLeft,[out]Float64* twRight,[out]Float64 *tribFlangeWidth);
	   [helpstring("method EffectiveFlangeWidth")] HRESULT EffectiveFlangeWidth([in]IGenericBridge* bridge,[in]SpanIndexType span,[in]GirderIndexType gdr,[in]Float64 location, [out,retval]Float64 *effFlangeWidth);
	   [helpstring("method EffectiveFlangeWidthEx")] HRESULT EffectiveFlangeWidthEx([in]IGenericBridge* bridge,[in]SpanIndexType span,[in]GirderIndexType gdr,[in]Float64 location, [out,retval]IEffectiveFlangeWidthDetails** details);
	};

	[
		object,
		oleautomation,
		uuid(B3D076FB-B0B0-4791-ADCF-BE1826640996),
		helpstring("SectionCutTool Interface"),
		pointer_default(unique)
	]
	interface ISectionCutTool : IUnknown
	{
	   [propputref,helpstring("property EffectiveFlangeWidthTool")] HRESULT EffectiveFlangeWidthTool([in] IEffectiveFlangeWidthTool* pTool);
	   [propget,helpstring("property EffectiveFlangeWidthTool")] HRESULT EffectiveFlangeWidthTool([out,retval] IEffectiveFlangeWidthTool* *pTool);
	   [helpstring("method CreateGirderSection")] HRESULT CreateGirderSection([in]IGenericBridge* bridge,[in]SpanIndexType span,[in]GirderIndexType gdr,[in]Float64 location,[in] BSTR stage, [out,retval]ISection** section);
	   [helpstring("method CreateBridgeSection")] HRESULT CreateBridgeSection([in]IGenericBridge* bridge,[in]Float64 distFromStartOfBridge,[in] BSTR stage, [in] BarrierSectionCut bsc,[out,retval]ISection** section);
	   [helpstring("method CreateLeftBarrierShape")] HRESULT CreateLeftBarrierShape([in]IGenericBridge* bridge,[in] Float64 station,[out,retval]IShape** shape);
	   [helpstring("method CreateRightBarrierShape")] HRESULT CreateRightBarrierShape([in]IGenericBridge* bridge,[in] Float64 station,[out,retval]IShape** shape);
	   [helpstring("method CreateLeftBarrierSection")] HRESULT CreateLeftBarrierSection([in]IGenericBridge* bridge,[in] Float64 station,[in] VARIANT_BOOL bStructuralOnly,[out,retval]ICompositeSectionItem** section);
	   [helpstring("method CreateRightBarrierSection")] HRESULT CreateRightBarrierSection([in]IGenericBridge* bridge,[in] Float64 station,[in] VARIANT_BOOL bStructuralOnly,[out,retval]ICompositeSectionItem** section);
	   [helpstring("method CreateSlabShape")] HRESULT CreateSlabShape([in]IGenericBridge* bridge,[in]Float64 station,[out,retval]IShape** shape);
	};

   // This interface tells how to move harped strands when they are offset
	[
		object,
		oleautomation,
		uuid(0FAD048E-8F77-472a-B2BF-7ED599FA765D),
		helpstring("IStrandMover Interface"),
		pointer_default(unique)
	]
	interface IStrandMover : IUnknown 
	{
      // Top elevation of girder in strand coords (note that cover is below this).
	   [propget, helpstring("property TopElevation")] HRESULT TopElevation([out, retval]Float64* topElev);

      // Max/min Y locations for harped prestressing strands within section at harping points and ends
	   [propget, helpstring("property HpStrandElevationBoundaries")] HRESULT HpStrandElevationBoundaries([out]Float64* bottomMin,[out]Float64* topMax);
	   [propget, helpstring("property EndStrandElevationBoundaries")] HRESULT EndStrandElevationBoundaries([out]Float64* bottomMin,[out]Float64* topMax);

      // default increments for moving strands
	   [propget, helpstring("property StrandIncrements")] HRESULT StrandIncrements([out]Float64* endIncrement,[out]Float64* hpIncrement);

      // Test if a strand location is within valid bounds 
	   [helpstring("method TestHpStrandLocation")] HRESULT TestHpStrandLocation([in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]VARIANT_BOOL* isWithin);
	   [helpstring("method TestEndStrandLocation")] HRESULT TestEndStrandLocation([in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]VARIANT_BOOL* isWithin);

      // Based on an original location and a Y offset, compute the new strand location
	   [helpstring("method TranslateStrand")] HRESULT TranslateStrand([in]Float64 originalX, [in]Float64 originalY, [in]Float64 Yoffset, [out]Float64* newX, [out]Float64* newY );
   }

   // Definitions:
   // Strand Grid: A condensed grid of potential strand locations. All x values are 0.0 or more.
   //              For x > 0.0, there is assumed to be a second potiential strand location at -x
   // Strand Grid Index: Index into the condensed strand grid
   // Strand Position: The position of a strand in the fully expanded strand grid
   //                  Strand positions correspond to the strand fill sequence numbers you'll find
   //                  on girder plans. The strands in a girder can be at position 0,1,6,7,10,11
   // Strand Index: Zero based index into the list of strands used in a girder.
   //               For the example given above, we have
   //               index 0 -> strand position 0
   //               index 1 -> strand position 1
   //               index 2 -> strand position 6
   //               index 3 -> strand position 7
   //               index 4 -> strand position 10
   //               index 5 -> strand position 11

	[
		object,
		oleautomation,
		uuid(656F5032-BB18-4644-911A-CD4672EBA5B0),
		helpstring("IStrandGrid Interface"),
		pointer_default(unique)
	]
	interface IStrandGrid : IUnknown
	{
      // Grid points represent holes where strands can go
      // Grid points use a compacted numbering sequence where points with positive X values
      // are placed symmetrically (e.g., represent two actual strand locations)
	   [helpstring("method AddGridPoint")] HRESULT AddGridPoint([in]IPoint2d* point);
	   [helpstring("method AddGridPoints")] HRESULT AddGridPoints([in]IPoint2dCollection* points);
	   [propget, helpstring("property GridPointCount")] HRESULT GridPointCount([out,retval]GridIndexType* count);
	   [propget, helpstring("property GridPoint")] HRESULT GridPoint([in] GridIndexType idx,[out,retval]IPoint2d** point);
	   [propget, helpstring("property GridPoints")] HRESULT GridPoints([out,retval]IPoint2dCollection** point);
	   [helpstring("method RemoveGridPoint")] HRESULT RemoveGridPoint([in] GridIndexType idx);
	   [helpstring("method ClearGridPoints")] HRESULT ClearGridPoints();

	   [helpstring("method GridBoundingBox")] HRESULT GridBoundingBox([out,retval]IRect2d** box);
    }


	[
		object,
		oleautomation,
		uuid(E5DF8437-92B8-4d3e-A3F5-71E46214571D),
		helpstring("IStrandGridFiller Interface"),
		pointer_default(unique)
	]
	interface IStrandGridFiller : IUnknown
	{
      // Functions below have to do with filling of grid points and query for filled strands
      // This is a mostly private interface to facilitate use of the strand grid.
      
      // Max number strands that can be filled
      [propget,helpstring("property MaxStrandCount")] HRESULT MaxStrandCount([out,retval]StrandIndexType* count);

      // Returns a vector of integers GridPointCount long indicating the max number of strands
      // that normally can be placed at each Grid point (1 - if X==0.0, or 2 - if X>0.0)
      [helpstring("method GetMaxStrandFill")] HRESULT GetMaxStrandFill([out,retval]ILongArray** maxFill);

      // Set or get vector of integers indicated number of strands filled at each Grid point
      // Possible values are 0, 1, or 2. Length of vector is GridPointCount
      // If Grid point has positive X value and 1 is input, the strand is placed at X=0.0
      // If Grid point has zero X value and 2 is input, two strands are placed at X=0.0
      [propget, helpstring("property StrandFill")] HRESULT StrandFill([out,retval]ILongArray** fill);
      [propput, helpstring("property StrandFill")] HRESULT StrandFill([in]ILongArray* fill);

	   [helpstring("method RemoveAllStrands")] HRESULT RemoveAllStrands();

      // Set the strand mover. By default strands just move up or down
      [propput, helpstring("property StrandMover")] HRESULT StrandMover([in]IStrandMover* mover);

      // adjust strands upward or downward (up is positive)
      [propget, helpstring("property VerticalStrandAdjustment")] HRESULT VerticalStrandAdjustment([out,retval]Float64* adjust);
      [propput, helpstring("property VerticalStrandAdjustment")] HRESULT VerticalStrandAdjustment([in]Float64 adjust);

      // Return number of currently filled strand locations
	   [helpstring("method GetStrandCount")] HRESULT GetStrandCount([out,retval] StrandIndexType* count);

      // Returns a collection of all currently filled strand locations
      // index 0 in the collection corresponds to strandIndex = 0, index 1 -> strandIndex = 1, etc
	   [helpstring("method GetStrandPositions")] HRESULT GetStrandPositions([out,retval]IPoint2dCollection** points);

      // Convert strand index (defined in IPoint2dCollection's above) to Grid index
      [helpstring("method StrandIndexToGridIndex")] HRESULT StrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);

      // Return CG and bounding box of currently filled strands - adjused for vertical adjustment
	   [propget,helpstring("property CG")] HRESULT CG([out]Float64* cgx, [out]Float64* cgy);
	   [propget,helpstring("property StrandBoundingBox")] HRESULT StrandBoundingBox([out,retval]IRect2d** box);

      // Unadjusted upper and lower bounds for currently filled grid
      // returns zeros if no strands in fill
	   [propget,helpstring("property FilledGridBounds")] HRESULT FilledGridBounds([out]Float64* bottomElev, [out]Float64* topElev);

	   [propget,helpstring("property RowsWithStrand")] HRESULT RowsWithStrand([out,retval]RowIndexType* nRows);
	   [propget,helpstring("property StrandsInRow")] HRESULT StrandsInRow([in]RowIndexType rowIdx,[out,retval]ILongArray** gridIndexes);
	   [propget,helpstring("property NumStrandsInRow")] HRESULT NumStrandsInRow([in]RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);

      // Ex methods are typically for testing a new fill.
      // they allow input of a temporary fill array. Internal fill array is not changed
	   [helpstring("method GetStrandCountEx")] HRESULT GetStrandCountEx([in]ILongArray* fill, [out,retval] StrandIndexType* count);
	   [helpstring("method GetStrandPositionsEx")] HRESULT GetStrandPositionsEx([in]ILongArray* fill, [out,retval]IPoint2dCollection** points);
	   [propget,helpstring("property CGEx")] HRESULT CGEx([in]ILongArray* fill, [out]Float64* cgx, [out]Float64* cgy);
	   [propget,helpstring("property StrandBoundingBoxEx")] HRESULT StrandBoundingBoxEx([in]ILongArray* fill, [out,retval]IRect2d** box);
      [helpstring("method StrandIndexToGridIndexEx")] HRESULT StrandIndexToGridIndexEx([in]ILongArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
	   [propget,helpstring("property FilledGridBoundsEx")] HRESULT FilledGridBoundsEx([in]ILongArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);

      // Debonding - could go into another interface, but it's handy to have it here
      // rough count of debonded strands at current fill
      [helpstring("method GetStrandDebondCount")] HRESULT GetStrandDebondCount([out,retval] StrandIndexType* count);

      // Debond  strands based on Grid index
      [helpstring("method DebondStrandByGridIndex")] HRESULT DebondStrandByGridIndex([in]GridIndexType grdIndex,[in]Float64 l1,[in]Float64 l2);
      [helpstring("method GetDebondedStrandsByGridIndex")] HRESULT GetDebondedStrandsByGridIndex([out,retval]ILongArray** grdIndexes);
      [helpstring("method GetDebondLengthByGridIndex")] HRESULT GetDebondLengthByGridIndex([in]GridIndexType grdIndex, [out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);

      // Debonded  strands based on Positions index (i.e., from GetStrandPositions)
      [helpstring("method GetDebondLengthByPositionIndex")] HRESULT GetDebondLengthByPositionIndex([in]StrandIndexType positionIndex,[out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);
      [helpstring("method GetStrandsDebondedByPositionIndex")] HRESULT GetStrandsDebondedByPositionIndex([in]Float64 distFromStart, [in]Float64 girderLength, [out,retval]ILongArray** positionIndexes);

      // Distance that a strand is bonded (left and right) for a given location. Also returns strand's Y coordinate
      // Note that versions are for position and grid indexing
      [helpstring("method GetBondedLengthByPositionIndex")] HRESULT GetBondedLengthByPositionIndex([in]StrandIndexType positionIndex, [in]Float64 distFromStart, [in]Float64 girderLength,
                                                                             [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);

      [helpstring("method GetBondedLengthByGridIndex")] HRESULT GetBondedLengthByGridIndex([in]GridIndexType grdIndex, [in]Float64 distFromStart, [in]Float64 girderLength,
                                                                             [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);

      [propget,helpstring("property StrandDebondInRow")] HRESULT StrandDebondInRow([in] RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);
      [helpstring("method IsExteriorStrandDebondedInRow")] HRESULT IsExteriorStrandDebondedInRow([in] RowIndexType rowIndex,[out,retval]VARIANT_BOOL* bResult);

      [helpstring("method GetDebondSections")] HRESULT GetDebondSections([out]IDblArray** arrLeft,[out]IDblArray** arrRight);
      [helpstring("method GetDebondAtLeftSection")] HRESULT GetDebondAtLeftSection([in]SectionIndexType sectionIdx,[out,retval]ILongArray** strandIndexes);
      [helpstring("method GetDebondAtRightSection")] HRESULT GetDebondAtRightSection([in]SectionIndexType sectionIdx,[out,retval]ILongArray** strandIndexes);

	  [helpstring("method ClearDebonding")] HRESULT ClearDebonding();
   }


	[
		object,
		oleautomation,
		uuid(231B2534-7714-459c-A2CE-A2195474A2C2),
		helpstring("IPrecastGirder Interface"),
		pointer_default(unique)
	]
	interface IPrecastGirder : IUnknown
	{
      [helpstring("method Initialize")] HRESULT Initialize([in]IGenericBridge* bridge, [in]IStrandMover* strandMover, [in]SpanIndexType spanIdx,[in]GirderIndexType gdrIdx);

      [propget,helpstring("property StraightStrandGrid")] HRESULT StraightStrandGrid([in]EndType endType,[out,retval]IStrandGrid** ptrn);
      [propget,helpstring("property TemporaryStrandGrid")] HRESULT TemporaryStrandGrid([in]EndType endType,[out,retval]IStrandGrid** ptrn);
      [propget,helpstring("property HarpedStrandGridEnd")] HRESULT HarpedStrandGridEnd([in]EndType endType,[out,retval]IStrandGrid** ptrn);
      [propget,helpstring("property HarpedStrandGridHP")] HRESULT HarpedStrandGridHP([in]EndType endType,[out,retval]IStrandGrid** ptrn);

	   [propput,helpstring("property AllowOddNumberOfHarpedStrands")] HRESULT AllowOddNumberOfHarpedStrands([in]VARIANT_BOOL bUseMin);
	   [propget,helpstring("property AllowOddNumberOfHarpedStrands")] HRESULT AllowOddNumberOfHarpedStrands([out,retval]VARIANT_BOOL* bUseMin);

      // default design increments for vertical adjustment of strands at end and harping points
      // NOTE: If this value is less than zero, NO adjustment will be made.
      [propget,helpstring("property HarpedEndAdjustmentIncrement")] HRESULT HarpedEndAdjustmentIncrement([out,retval]Float64* increment);
      [propget,helpstring("property HarpedHpAdjustmentIncrement")] HRESULT HarpedHpAdjustmentIncrement([out,retval]Float64* increment);

      // max elevation of girder (girder Top) bottom is at 0.0
      [propget,helpstring("property TopElevation")] HRESULT TopElevation([out,retval]Float64* offset);

      // Vertical adjustments of harped strands
      // Cannot be set to a non-zero value if Increment (above) is negative.
      [propget,helpstring("property HarpedStrandAdjustmentEnd")] HRESULT HarpedStrandAdjustmentEnd([out,retval]Float64* offset);
      [propput,helpstring("property HarpedStrandAdjustmentEnd")] HRESULT HarpedStrandAdjustmentEnd([in]Float64 offset);
      [propget,helpstring("property HarpedStrandAdjustmentHP")] HRESULT HarpedStrandAdjustmentHP([out,retval]Float64* offset);
      [propput,helpstring("property HarpedStrandAdjustmentHP")] HRESULT HarpedStrandAdjustmentHP([in]Float64 offset);

	   [helpstring("method SetHarpingPoints")] HRESULT SetHarpingPoints([in]Float64 hp1,[in]Float64 hp2);
	   [helpstring("method GetHarpingPoints")] HRESULT GetHarpingPoints([out]Float64* hp1,[out]Float64* hp2);
	   [propput,helpstring("property UseMinHarpPointDistance")] HRESULT UseMinHarpPointDistance([in]VARIANT_BOOL bUseMin);
	   [propget,helpstring("property UseMinHarpPointDistance")] HRESULT UseMinHarpPointDistance([out,retval]VARIANT_BOOL* bUseMin);
	   [propput,helpstring("method MinHarpPointDistance")] HRESULT MinHarpPointDistance([in]Float64 minHpDist);
	   [propget,helpstring("method MinHarpPointDistance")] HRESULT MinHarpPointDistance([out,retval]Float64* minHpDist);
	   [propput,helpstring("property HarpingPointMeasure")] HRESULT HarpingPointMeasure([in] HarpPointMeasure measure);
	   [propget,helpstring("property HarpingPointMeasure")] HRESULT HarpingPointMeasure([out,retval] HarpPointMeasure* measure);
	   [propput,helpstring("property HarpingPointReference")] HRESULT HarpingPointReference([in] HarpPointReference hpRef);
	   [propget,helpstring("property HarpingPointReference")] HRESULT HarpingPointReference([out,retval] HarpPointReference* hpRef);
	   [helpstring("method GetHarpingPointLocations")] HRESULT GetHarpingPointLocations([out]Float64* hp1,[out]Float64* hp2);

      [propget,helpstring("property SpanLength")] HRESULT SpanLength([out,retval] Float64* length);
      [propget,helpstring("property GirderLength")] HRESULT GirderLength([out,retval] Float64* length);
      [propget,helpstring("property LeftEndSize")] HRESULT LeftEndSize([out,retval] Float64* size);
      [propget,helpstring("property RightEndSize")] HRESULT RightEndSize([out,retval] Float64* size);
      [propget,helpstring("property LeftBearingOffset")] HRESULT LeftBearingOffset([out,retval] Float64* offset);
      [propget,helpstring("property RightBearingOffset")] HRESULT RightBearingOffset([out,retval] Float64* offset);
      [helpstring("method GetEndPoints")] HRESULT GetEndPoints([out]IPoint2d** pntPier1,[out]IPoint2d** pntEnd1,[out]IPoint2d** pntBrg1,[out]IPoint2d** pntBrg2,[out]IPoint2d** pntEnd2,[out]IPoint2d** pntPier2);

      [propget,helpstring("property StraightMaxStrandFill")] HRESULT StraightMaxStrandFill([out,retval]ILongArray** fill);
      [propget,helpstring("property HarpedMaxStrandFill")] HRESULT HarpedMaxStrandFill([out,retval]ILongArray** fill);
      [propget,helpstring("property TemporaryMaxStrandFill")] HRESULT TemporaryMaxStrandFill([out,retval]ILongArray** fill);

      [propget,helpstring("property StraightStrandFill")] HRESULT StraightStrandFill([out,retval]ILongArray** fill);
      [propput,helpstring("property StraightStrandFill")] HRESULT StraightStrandFill([in]ILongArray* fill);
      [propget,helpstring("property HarpedStrandFill")] HRESULT HarpedStrandFill([out,retval]ILongArray** fill);
      [propput,helpstring("property HarpedStrandFill")] HRESULT HarpedStrandFill([in]ILongArray* fill);
      [propget,helpstring("property TemporaryStrandFill")] HRESULT TemporaryStrandFill([out,retval]ILongArray** fill);
      [propput,helpstring("property TemporaryStrandFill")] HRESULT TemporaryStrandFill([in]ILongArray* fill);

      // Get all strand locations based on current fill, or input fill. 
      // Debonded strands are not removed
      // Locations are adjusted by offset
      [propget,helpstring("property StraightStrandPositions")] HRESULT StraightStrandPositions([in] Float64 distFromStart, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property StraightStrandPositionsEx")] HRESULT StraightStrandPositionsEx([in] Float64 distFromStart, [in]ILongArray* fill, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property HarpedStrandPositions")] HRESULT HarpedStrandPositions([in] Float64 distFromStart, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property HarpedStrandPositionsEx")] HRESULT HarpedStrandPositionsEx([in] Float64 distFromStart, [in]ILongArray* fill, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property TempStrandPositions")] HRESULT TempStrandPositions([in] Float64 distFromStart, [out,retval]IPoint2dCollection** points);
      [propget,helpstring("property TempStrandPositionsEx")] HRESULT TempStrandPositionsEx([in] Float64 distFromStart, [in]ILongArray* fill, [out,retval]IPoint2dCollection** points);

      // Convert strand index (defined in IPoint2dCollection's above) to Grid index
      [helpstring("method StraightStrandIndexToGridIndex")] HRESULT StraightStrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method StraightStrandIndexToGridIndexEx")] HRESULT StraightStrandIndexToGridIndexEx([in]ILongArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method HarpedStrandIndexToGridIndex")] HRESULT HarpedStrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method HarpedStrandIndexToGridIndexEx")] HRESULT HarpedStrandIndexToGridIndexEx([in]ILongArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method TemporaryStrandIndexToGridIndex")] HRESULT TemporaryStrandIndexToGridIndex([in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);
      [helpstring("method TemporaryStrandIndexToGridIndexEx")] HRESULT TemporaryStrandIndexToGridIndexEx([in]ILongArray* fill, [in] StrandIndexType strandIndex, [out,retval] GridIndexType* gridIndex);

      // Compute bounding boxes of harped and straight strands accounting for vertical offsets for harped strands
	   [helpstring("method StraightStrandBoundingBox")] HRESULT StraightStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);
	   [helpstring("method StraightStrandBoundingBoxEx")] HRESULT StraightStrandBoundingBoxEx([in]EndType endType, [in] ILongArray* fill, [out,retval]IRect2d** box);
	   [helpstring("method HarpedEndStrandBoundingBox")] HRESULT HarpedEndStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);
	   [helpstring("method HarpedEndStrandBoundingBoxEx")] HRESULT HarpedEndStrandBoundingBoxEx([in]EndType endType, [in] ILongArray* fill, [out,retval]IRect2d** box);
	   [helpstring("method HarpedHpStrandBoundingBox")] HRESULT HarpedHpStrandBoundingBox([in]EndType endType, [out,retval]IRect2d** box);
	   [helpstring("method HarpedHpStrandBoundingBoxEx")] HRESULT HarpedHpStrandBoundingBoxEx([in]EndType endType, [in] ILongArray* fill, [out,retval]IRect2d** box);

      // Compute offset adjustment required in order to put harped strands within proper bounds
      // If zero, no adjustment is required. 
      // If non-zero, add this number to current offset to move current harped strands just enough to fit within cross section boundary
	   [helpstring("method HarpedEndStrandBoundaryCheck")] HRESULT HarpedEndStrandBoundaryCheck([out,retval]Float64* adjustment);
	   [helpstring("method HarpedHpStrandBoundaryCheck")] HRESULT HarpedHpStrandBoundaryCheck([out,retval]Float64* adjustment);

      // Max allowable up or down strand adjustment to keep strands in bounds
	   [helpstring("method GetHarpedEndAdjustmentBounds")] HRESULT GetHarpedEndAdjustmentBounds([out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
	   [helpstring("method GetHarpedEndAdjustmentBoundsEx")] HRESULT GetHarpedEndAdjustmentBoundsEx([in] ILongArray* fill, [out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
	   [helpstring("method GetHarpedHpAdjustmentBounds")] HRESULT GetHarpedHpAdjustmentBounds([out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);
	   [helpstring("method GetHarpedHpAdjustmentBoundsEx")] HRESULT GetHarpedHpAdjustmentBoundsEx([in] ILongArray* fill, [out]Float64* DownwardAdjustment, [out]Float64* UpwardAdjustment);

	   [helpstring("property GetHarpedEndFilledGridBoundsEx")] HRESULT GetHarpedEndFilledGridBoundsEx([in]ILongArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);
	   [helpstring("property GetHarpedHpFilledGridBoundsEx")] HRESULT GetHarpedHpFilledGridBoundsEx([in]ILongArray* fill, [out]Float64* bottomElev, [out]Float64* topElev);

      [helpstring("property ComputeMaxHarpedStrandSlope")] HRESULT ComputeMaxHarpedStrandSlope([in]Float64 distFromStart,[out,retval]Float64* slope);
      [helpstring("property ComputeMaxHarpedStrandSlopeEx")] HRESULT ComputeMaxHarpedStrandSlopeEx([in]Float64 distFromStart, [in]ILongArray* fill, [in] Float64 endOffset,[in] Float64 hpOffset,[out,retval]Float64* slope);
      [helpstring("property ComputeAvgHarpedStrandSlope")] HRESULT ComputeAvgHarpedStrandSlope([in]Float64 distFromStart,[out,retval]Float64* slope);
      [helpstring("property ComputeAvgHarpedStrandSlopeEx")] HRESULT ComputeAvgHarpedStrandSlopeEx([in]Float64 distFromStart, [in]ILongArray* fill, [in] Float64 endOffset,[in] Float64 hpOffset,[out,retval]Float64* slope);

      [propget,helpstring("property MaxStraightStrands")] HRESULT MaxStraightStrands([out,retval]StrandIndexType* nStrands);
      [propget,helpstring("property MaxHarpedStrands")] HRESULT MaxHarpedStrands([out,retval]StrandIndexType* nStrands);
      [propget,helpstring("property MaxTemporaryStrands")] HRESULT MaxTemporaryStrands([out,retval]StrandIndexType* nStrands);

      [helpstring("method GetStraightStrandCount")] HRESULT GetStraightStrandCount([out,retval] StrandIndexType* nStrands);
      [helpstring("method GetHarpedStrandCount")] HRESULT GetHarpedStrandCount([out,retval] StrandIndexType* nStrands);
      [helpstring("method GetTemporaryStrandCount")] HRESULT GetTemporaryStrandCount([out,retval] StrandIndexType* nStrands);

      [helpstring("method GetStraightStrandCountEx")] HRESULT GetStraightStrandCountEx([in]ILongArray* fill, [out,retval] StrandIndexType* nStrands);
      [helpstring("method GetHarpedStrandCountEx")] HRESULT GetHarpedStrandCountEx([in]ILongArray* fill, [out,retval] StrandIndexType* nStrands);
      [helpstring("method GetTemporaryStrandCountEx")] HRESULT GetTemporaryStrandCountEx([in]ILongArray* fill, [out,retval] StrandIndexType* nStrands);

      // rough count of debonded strands at current fill
      [helpstring("method GetStraightStrandDebondCount")] HRESULT GetStraightStrandDebondCount([out,retval] StrandIndexType* count);

      // Debond straight strands based on Grid index
	   [helpstring("method ClearStraightStrandDebonding")] HRESULT ClearStraightStrandDebonding();
      [helpstring("method DebondStraightStrandByGridIndex")] HRESULT DebondStraightStrandByGridIndex([in]GridIndexType grdIndex,[in]Float64 l1,[in]Float64 l2);
      [helpstring("method GetDebondedStraightStrandsByGridIndex")] HRESULT GetDebondedStraightStrandsByGridIndex([out,retval]ILongArray** grdIndexes);
      [helpstring("method GetStraightStrandDebondLengthByGridIndex")] HRESULT GetStraightStrandDebondLengthByGridIndex([in]GridIndexType grdIndex,[out]Float64* YCoord,[out]Float64* l1,[out]Float64* l2);

      // Debonded straight strands based on Positions index (i.e., from get_StraightStrandPositions)
      [helpstring("method GetStraightStrandDebondLengthByPositionIndex")] HRESULT GetStraightStrandDebondLengthByPositionIndex([in]StrandIndexType positionIndex,[out]Float64* YCoord, [out]Float64* l1,[out]Float64* l2);
      [helpstring("method GetStraightStrandsDebondedByPositionIndex")] HRESULT GetStraightStrandsDebondedByPositionIndex([in]Float64 distFromStart, [out,retval]ILongArray** positionIndexes);

      [propget,helpstring("property StraightStrandRowsWithStrand")] HRESULT StraightStrandRowsWithStrand([out,retval]RowIndexType* nRows);
      [propget,helpstring("property StraightStrandsInRow")] HRESULT StraightStrandsInRow([in]RowIndexType rowIdx,[out,retval]ILongArray** gridIndexes);
      [propget,helpstring("property NumStraightStrandsInRow")] HRESULT NumStraightStrandsInRow([in]RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);
      [propget,helpstring("property StraightStrandDebondInRow")] HRESULT StraightStrandDebondInRow([in] RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);
      [helpstring("method IsExteriorStraightStrandDebondedInRow")] HRESULT IsExteriorStraightStrandDebondedInRow([in] RowIndexType rowIndex,[out,retval]VARIANT_BOOL* bResult);

      [propget,helpstring("property HarpedStrandRowsWithStrand")] HRESULT HarpedStrandRowsWithStrand([out,retval]RowIndexType* nRows);
      [propget,helpstring("property HarpedStrandsInRow")] HRESULT HarpedStrandsInRow([in]RowIndexType rowIdx,[out,retval]ILongArray** gridIndexes);
      [propget,helpstring("property NumHarpedStrandsInRow")] HRESULT NumHarpedStrandsInRow([in]RowIndexType rowIdx,[out,retval]StrandIndexType* nStrands);

      [helpstring("method GetStraightStrandDebondAtSections")] HRESULT GetStraightStrandDebondAtSections([out]IDblArray** arrLeft,[out]IDblArray** arrRight);
      [helpstring("method GetStraightStrandDebondAtLeftSection")] HRESULT GetStraightStrandDebondAtLeftSection([in]SectionIndexType sectionIdx,[out,retval]ILongArray** pstnIndexes);
      [helpstring("method GetStraightStrandDebondAtRightSection")] HRESULT GetStraightStrandDebondAtRightSection([in]SectionIndexType sectionIdx,[out,retval]ILongArray** pstnIndexes);

      // Distance that a strand is bonded (left and right) for a given location. Also returns strand's Y coordinate
      [helpstring("method GetStraightStrandBondedLengthByPositionIndex")] HRESULT GetStraightStrandBondedLengthByPositionIndex([in]StrandIndexType positionIndex, [in]Float64 distFromStart,
                                                                             [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);

      [helpstring("method GetStraightStrandBondedLengthByGridIndex")] HRESULT GetStraightStrandBondedLengthByGridIndex([in]GridIndexType grdIndex, [in]Float64 distFromStart,
                                                                             [out]Float64* YCoord, [out]Float64* leftBond, [out]Float64* rightBond);
      [propget,helpstring("property RebarLayout")] HRESULT RebarLayout([out,retval]IRebarLayout** rebarLayout);
	};


	[
		object,
		oleautomation,
		uuid(C5CBE002-A27E-408c-91DF-56A6AF5346BC),
		helpstring("BridgeGeometryTool Interface"),
		pointer_default(unique)
	]
	interface IBridgeGeometryTool : IUnknown
	{
	   [helpstring("method Point")] HRESULT Point([in] IGenericBridge* bridge,[in] SpanIndexType spanIdx,[in] GirderIndexType gdrIdx, [in] Float64 distFromStartOfGirder,[out] IPoint2d** point);
	   [helpstring("method StationAndOffset")] HRESULT StationAndOffset([in] IGenericBridge* bridge,[in] SpanIndexType spanIdx,[in] GirderIndexType gdrIdx, [in] Float64 distFromStartOfGirder,[out] IStation** station, [out] Float64* offset);
	   [helpstring("method GirderPathOffset")] HRESULT GirderPathOffset([in] IGenericBridge* bridge,[in] SpanIndexType spanIdx,[in] GirderIndexType gdrIdx, [in] VARIANT varStation, [out,retval] Float64* offset);
	   [helpstring("method GirderLineBearing")] HRESULT GirderLineBearing([in] IGenericBridge* bridge,[in] SpanIndexType spanIdx,[in] GirderIndexType gdrIdx, [out,retval] IDirection** direction);
	   [helpstring("method GirderLinePoint")] HRESULT GirderLinePoint([in] IGenericBridge* bridge,[in] Float64 distFromStartOfBridge,[in] GirderIndexType gdrIdx, [out] SpanIndexType* spanIdx, [out] Float64* distFromStartOfSpan);
	   [helpstring("method DeckEdgePoint")] HRESULT DeckEdgePoint([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] IPoint2d** point);
	   [helpstring("method DeckEdgePoints")] HRESULT DeckEdgePoints([in] IGenericBridge* bridge,[in] DirectionType side,[in] CollectionIndexType nPoints,[out,retval] IPoint2dCollection** points);
	   [helpstring("method CurbOffset")] HRESULT CurbOffset([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOffset);
	   [helpstring("method DeckOffset")] HRESULT DeckOffset([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOffset);
	   [helpstring("method DeckOverhang")] HRESULT DeckOverhang([in] IGenericBridge* bridge,[in] Float64 station,[in] IDirection* direction,[in] DirectionType side,[out,retval] Float64* pOverhang);
      [helpstring("method DeckOverhangFromGirder")] HRESULT DeckOverhangFromGirder([in] IGenericBridge* bridge,[in] SpanIndexType spanIdx,[in] GirderIndexType gdrIdx,[in] Float64 distFromStartOfGirder,[in] DirectionType side,[out] Float64* pOverhang);
	};

	[
		object,
		uuid(6D610B2E-6D62-45d9-AE5D-2F8159D4B2CC),
		oleautomation,
		helpstring("IRebar Interface"),
		pointer_default(unique)
	]
	interface IRebar : IMaterial
	{
		[helpstring("method Init")] HRESULT Init([in] BSTR name,[in] Float64 Es,[in] Float64 density,[in] Float64 fpu,[in] Float64 fpy,[in] Float64 db,[in] Float64 Ab);
		[propget, helpstring("property Name")] HRESULT Name([out,retval] BSTR* name);
		[propput, helpstring("property Name")] HRESULT Name([in] BSTR name);
		[propget, helpstring("property UltimateStrength")] HRESULT UltimateStrength([out,retval] Float64* fpu);
		[propput, helpstring("property UltimateStrength")] HRESULT UltimateStrength([in] Float64 fpu);
		[propget, helpstring("property YieldStrength")] HRESULT YieldStrength([out,retval] Float64* fpy);
		[propput, helpstring("property YieldStrength")] HRESULT YieldStrength([in] Float64 fpy);
		[propget, helpstring("property NominalDiameter")] HRESULT NominalDiameter([out,retval] Float64* db);
		[propput, helpstring("property NominalDiameter")] HRESULT NominalDiameter([in] Float64 db);
		[propget, helpstring("property NominalArea")] HRESULT NominalArea([out,retval] Float64* Ab);
		[propput, helpstring("property NominalArea")] HRESULT NominalArea([in] Float64 Ab);
	};

	[
		object,
		uuid(E873B37D-4E71-4e72-9ED0-1B05E5AC6089),
		oleautomation,
		helpstring("IRebarFactory Interface"),
		pointer_default(unique)
	]
	interface IRebarFactory : IUnknown
	{
	   [helpstring("method CreateRebar")] HRESULT CreateRebar([in] MaterialSpec spec, [in] RebarGrade grade, [in] BarSize size, [in] IUnitConvert* convert, [out,retval] IRebar** rebar);
	};

	[
		object,
		uuid(450B480F-A093-4e5e-BA48-A405055A3844),
		oleautomation,
		helpstring("IRebarSectionItem Interface"),
		pointer_default(unique)
	]
	interface IRebarSectionItem : IUnknown
	{
		[propget,helpstring("property Location")] HRESULT Location([out,retval]IPoint2d** location);
		[propget,helpstring("property DistFromStart")] HRESULT DistFromStart([out,retval] Float64* dist);
		[propget,helpstring("property DistFromEnd")] HRESULT DistFromEnd([out,retval] Float64* dist);
		[propget,helpstring("property Rebar")] HRESULT Rebar([out,retval] IRebar** rebar);
	};

	[
	   object,
	   uuid(9FD3BB0E-1AE0-4421-B44C-76AF46077068),
	   helpstring("IEnumRebarSectionItem Interface"),
       oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumRebarSectionItem : IUnknown
	{
       [helpstring("Clone")] HRESULT Clone([out] IEnumRebarSectionItem** ppenum);
 	   [helpstring("Next")]  HRESULT Next([in] ULONG celt, [out] IRebarSectionItem** rgelt, [in,out] ULONG* pceltFetched);
	   [helpstring("Reset")] HRESULT Reset();
	   [helpstring("Skip")]  HRESULT Skip([in] ULONG celt);
	};

	[
		object,
		uuid(BC1C7976-D479-4c25-9869-A449B0EDAFBC),
		oleautomation,
		helpstring("IRebarSection Interface"),
		pointer_default(unique)
	]
	interface IRebarSection : IUnknown
	{
		[helpstring("method Add")] HRESULT Add([in]IRebarSectionItem* item);
		[propget,helpstring("property Count")] HRESULT Count([out,retval] CollectionIndexType* count);
		[propget,helpstring("property Item")] HRESULT Item([in]CollectionIndexType idx,[out,retval]IRebarSectionItem** item);
        [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);  
        [propget, restricted, helpstring("property _EnumRebarSectionItem")] HRESULT _EnumRebarSectionItem([out,retval]IEnumRebarSectionItem** enumRSI);
	};

	[
		object,
		uuid(70D6E658-49B9-491d-B4DF-156457A835B8),
		oleautomation,
		helpstring("IRebarPattern Interface"),
		pointer_default(unique)
	]
	interface IRebarPattern : IUnknown
	{
		[propputref,helpstring("property Rebar")] HRESULT Rebar([in]IRebar* rebar);
		[propget,helpstring("property Rebar")] HRESULT Rebar([out,retval]IRebar** rebar);
		[propputref,helpstring("property RebarLayoutItem")] HRESULT RebarLayoutItem([in]IRebarLayoutItem* rebarLayoutItem);
		[propget,helpstring("property Count")] HRESULT Count([out,retval]CollectionIndexType* count);
		[propget,helpstring("property Location")] HRESULT Location([in] Float64 distFromStartOfPattern,[in]CollectionIndexType barIdx,[out,retval]IPoint2d** location);
	};

	[
		object,
		uuid(200FB0A9-E906-4b1e-A2D0-01BBE933CB6C),
		oleautomation,
		helpstring("IRebarPattern Interface"),
		pointer_default(unique)
	]
	interface IRebarRowPattern : IRebarPattern
	{
		[propput,helpstring("property AnchorPoint")] HRESULT AnchorPoint([in] EndType endType,[in]IPoint2d* anchorPt);
		[propget,helpstring("property AnchorPoint")] HRESULT AnchorPoint([in] EndType endType,[out,retval]IPoint2d** anchorPt);
		[propput,helpstring("property Count")] HRESULT Count([in]RowIndexType count);
		[propput,helpstring("property Spacing")] HRESULT Spacing([in]Float64 spacing);
		[propget,helpstring("property Spacing")] HRESULT Spacing([out,retval]Float64* spacing);
		[propput,helpstring("property Oreintation")] HRESULT Orientation([in]RebarRowOrientation oreintation);
		[propget,helpstring("property Oreintation")] HRESULT Orientation([out,retval]RebarRowOrientation* oreintation);
	};

	[
	   object,
	   uuid(61D6DF2E-6BA5-4ba4-B045-F57DFC16F973),
	   helpstring("IEnumRebarPatterns Interface"),
       oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumRebarPatterns : IUnknown
	{
       [helpstring("Clone")] HRESULT Clone([out] IEnumRebarPatterns** ppenum);
 	   [helpstring("Next")]  HRESULT Next([in] ULONG celt, [out] IRebarPattern** rgelt, [in,out] ULONG* pceltFetched);
	   [helpstring("Reset")] HRESULT Reset();
	   [helpstring("Skip")]  HRESULT Skip([in] ULONG celt);
	};

	[
	   object,
	   uuid(63465C7F-7036-43c3-95C1-D49A13271A68),
	   oleautomation,
	   helpstring("IRebarLayoutZone Interface"),
	   pointer_default(unique)
	]
	interface IRebarLayoutItem : IUnknown
	{
	   [helpstring("method ContainsLocation")] HRESULT ContainsLocation([in] Float64 distFromGdrStart,[out,retval] VARIANT_BOOL* bResult);
	   [propget,helpstring("property Start")] HRESULT Start([out,retval]Float64* start);
	   [propget,helpstring("property Length")] HRESULT Length([out,retval]Float64* length);
	   [propget,helpstring("property Count")] HRESULT Count([out,retval]CollectionIndexType* count);
	   [propget,helpstring("property Item")] HRESULT Item([in] CollectionIndexType idx,[out,retval]IRebarPattern** pattern);
	   [helpstring("mehtod AddRebarPattern")] HRESULT AddRebarPattern([in]IRebarPattern* pattern);
       [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);  
       [propget, restricted, helpstring("property _EnumRebarPatterns")] HRESULT _EnumRebarPatterns([out,retval]IEnumRebarPatterns** enumRebarPatterns);
	};

	[
	   object,
	   uuid(216C0A97-4C1C-4584-BCD9-5F5C9CFB6511),
	   helpstring("IEnumRebarLayoutItems Interface"),
       oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumRebarLayoutItems : IUnknown
	{
       [helpstring("Clone")] HRESULT Clone([out] IEnumRebarLayoutItems** ppenum);
 	   [helpstring("Next")]  HRESULT Next([in] ULONG celt, [out] IRebarLayoutItem** rgelt, [in,out] ULONG* pceltFetched);
	   [helpstring("Reset")] HRESULT Reset();
	   [helpstring("Skip")]  HRESULT Skip([in] ULONG celt);
	};

	[
		object,
		uuid(B887911C-EC53-4f32-B5E2-9D43C1F8D977),
		oleautomation,
		helpstring("IFlexRebarLayoutItem Interface"),
		pointer_default(unique)
	]
	interface IFlexRebarLayoutItem : IRebarLayoutItem
	{
	   [propget,helpstring("property Position")] HRESULT Position([out,retval] LayoutPosition* lp);
	   [propput,helpstring("property Position")] HRESULT Position([in] LayoutPosition lp);
	   [propget,helpstring("property LengthFactor")] HRESULT LengthFactor([out,retval] Float64* lf);
	   [propput,helpstring("property LengthFactor")] HRESULT LengthFactor([in] Float64 lf);
	   [propputref,helpstring("property Girder")] HRESULT Girder([in]IPrecastGirder* girder);
	};

	[
		object,
		uuid(455C735E-09FD-443a-BE17-7237AA1BA045),
		oleautomation,
		helpstring("IRebarLayout Interface"),
		pointer_default(unique)
	]
	interface IRebarLayout : IUnknown
	{
		[helpstring("method CreateRebarSection")] HRESULT CreateRebarSection([in] Float64 cutLocation,[out,retval]IRebarSection** section);
		[propget,helpstring("property Item")] HRESULT Item([in]CollectionIndexType idx,[out,retval]IRebarLayoutItem** rli);
		[propget,helpstring("property Count")] HRESULT Count([out,retval] CollectionIndexType* count);
		[helpstring("method Add")] HRESULT Add([in]IRebarLayoutItem* rli);
        [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);  
        [propget, restricted, helpstring("property _EnumRebarLayoutItems")] HRESULT _EnumRebarLayoutItems([out,retval]IEnumRebarLayoutItems** enumRebarLayoutItems);
	};


	[
		uuid(7DDC7A24-05FA-4565-92AC-4FFD54D5063D),
		helpstring("EffectiveFlangeWidthDetails Class")
	]
	coclass EffectiveFlangeWidthDetails
	{
		[default] interface IEffectiveFlangeWidthDetails;
	};
		
	[
		uuid(7AF06A24-3EF5-433B-9A03-B22A8404048B),
		helpstring("EffectiveFlangeWidthTool Class")
	]
	coclass EffectiveFlangeWidthTool
	{
		[default] interface IEffectiveFlangeWidthTool;
	};

	[
		uuid(88738282-9CE8-4553-BC7E-4DB1DF3D8809),
		helpstring("SectionCutTool Class")
	]
	coclass SectionCutTool
	{
		[default] interface ISectionCutTool;
	};

	[
	   uuid(6E8068AB-ABC2-4cae-A31B-74ABD7500570),
	   helpstring("PrecastGirder Class")
	]
	coclass PrecastGirder
	{
	   [default] interface IPrecastGirder;
	};

	[
	   uuid(77B0384B-5C9D-46ac-A8B6-AA8ADA58B37D),
	   helpstring("BridgeGeometryTool Class")
	]
	coclass BridgeGeometryTool
	{
	   [default] interface IBridgeGeometryTool;
	};
	[
		uuid(E01789C1-EC18-4c75-B42A-8DDB495C7326),
		helpstring("Rebar")
	]
	coclass Rebar
	{
		[default] interface IRebar;
		[default, source] interface IMaterialEvents;
	};

	[
		uuid(ED89484D-303E-452a-8165-8A6666200BAC),
		helpstring("RebarSectionItem")
	]
	coclass RebarSectionItem
	{
		[default] interface IRebarSectionItem;
	};

	[
		uuid(3D0BCC3C-1A32-44c5-A97E-55BD12DC62F1),
		helpstring("RebarSection")
	]
	coclass RebarSection
	{
		[default] interface IRebarSection;
	};

	[
		uuid(5F9006C8-B6A7-488e-88BB-24304ED93E4D),
		helpstring("RebarRowPattern")
	]
	coclass RebarRowPattern
	{
		[default] interface IRebarRowPattern;
	};

	[
		uuid(8B4B8193-D5C8-4e1f-86D1-D7044859B9CC),
		helpstring("FlexRebarLayoutItem")
	]
	coclass FlexRebarLayoutItem
	{
		[default] interface IFlexRebarLayoutItem;
	};

	[
		uuid(33813283-3F28-4291-AE33-AAD126881A38),
		helpstring("RebarLayout")
	]
	coclass RebarLayout
	{
		[default] interface IRebarLayout;
	};

	[
		uuid(867B7B93-BFF7-4879-980C-B1A2DC8C5DCC),
		helpstring("RebarFactory")
	]
	coclass RebarFactory
	{
		[default] interface IRebarFactory;
	};
	[
		uuid(A547E2F5-BE84-49F9-846E-2A5B2C2FD53F),
		helpstring("StrandGrid Class")
	]
	coclass StrandGrid
	{
		[default] interface IStrandGrid;
      interface IStrandGridFiller;
	};
};
