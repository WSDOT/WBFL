///////////////////////////////////////////////////////////////////////
// WBFLTools - Utility Tools for the WBFL
// Copyright © 1999-2021  Washington State Department of Transportation
//                        Bridge and Structures Office
//
// This library is a part of the Washington Bridge Foundation Libraries
// and was developed as part of the Alternate Route Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the Alternate Route Library Open Source License as 
// published by the Washington State Department of Transportation,
// Bridge and Structures Office.
//
// This program is distributed in the hope that it will be useful,
// but is distributed AS IS, WITHOUT ANY WARRANTY; without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
// PURPOSE.  See the Alternate Route Library Open Source License for more details.
//
// You should have received a copy of the Alternate Route Library Open Source License
// along with this program; if not, write to the Washington State
// Department of Transportation, Bridge and Structures Office,
// P.O. Box 47340, Olympia, WA 98503, USA or e-mail
// Bridge_Support@wsdot.wa.gov
///////////////////////////////////////////////////////////////////////

// WBFLTools.idl : IDL source for WBFLTools.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (WBFLTools.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";
import "WBFLTypes.idl";


#include <WbflTools.hh>
#include "StrStorage2.hh"

cpp_quote("/////////////////////////////////////////////////////////////////////////////")
cpp_quote("// ILogFile status codes")
cpp_quote("#define LOGFILE_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0200)")
cpp_quote("#define LOGFILE_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x020F)")
cpp_quote("")
cpp_quote("#define LOGFILE_E_CANTOPEN           (LOGFILE_E_FIRST+0)")
cpp_quote("// unable to open the log file")
cpp_quote("")
cpp_quote("#define LOGFILE_E_BADWRITE           (LOGFILE_E_FIRST+1)")
cpp_quote("// error occured while logging message")
cpp_quote("")
cpp_quote("#define LOGFILE_E_NOLOGFILE          (LOGFILE_E_FIRST+2)")
cpp_quote("// invalid cookie was used")


cpp_quote("/////////////////////////////////////////////////////////////////////////////")
cpp_quote("// IStructuredLoad status codes")
cpp_quote("#define STRLOAD_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0200)")
cpp_quote("#define STRLOAD_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x020F)")
cpp_quote("")
cpp_quote("#define STRLOAD_E_CANTOPEN           (STRLOAD_E_FIRST+0)")
cpp_quote("// unable to open the structured storage")
cpp_quote("")
cpp_quote("#define STRLOAD_E_INVALIDFORMAT      (STRLOAD_E_FIRST+1)")
cpp_quote("// invalid structured storage format")
cpp_quote("")
cpp_quote("#define STRLOAD_E_BADVERSION         (STRLOAD_E_FIRST+2)")
cpp_quote("// invalid version number encountered")
cpp_quote("")
cpp_quote("#define STRLOAD_E_FILENOTFOUND       (STRLOAD_E_FIRST+3)")
cpp_quote("// the specified file was not found")
cpp_quote("")
cpp_quote("#define STRLOAD_E_USERDEFINED        (STRLOAD_E_FIRST+4)")
cpp_quote("// a user defined error occured")
cpp_quote("")
cpp_quote("#define STRLOAD_E_CLASS_NOT_REGISTERED (STRLOAD_E_FIRST+5)")
cpp_quote("// class was not registered and cannot be created")
cpp_quote("")
cpp_quote("#define STRLOAD_E_CLASS_ISTRUCTUREDSTORAGE2 (STRLOAD_E_FIRST+6)")
cpp_quote("// the class does not support the IStructuredStorage2 interface")


cpp_quote("/////////////////////////////////////////////////////////////////////////////")
cpp_quote("// IStructuredSave status codes")
cpp_quote("#define STRSAVE_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0200)")
cpp_quote("#define STRSAVE_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x020F)")
cpp_quote("")
cpp_quote("#define STRSAVE_E_CANTOPEN                (STRSAVE_E_FIRST+0)")
cpp_quote("// unable to open the structured storage")
cpp_quote("")
cpp_quote("#define STRSAVE_E_BADWRITE                (STRSAVE_E_FIRST+1)")
cpp_quote("// could not write to stream")
cpp_quote("")
cpp_quote("#define STRSAVE_E_INITIALIZING_THE_PARSER (STRSAVE_E_FIRST+2)")
cpp_quote("// problem firing up the parser")
cpp_quote("")
cpp_quote("#define STRSAVE_E_INVALID_VARIANT_TYPE    (STRSAVE_E_FIRST+3)")
cpp_quote("// Invalid variant type passed in by client or in xml file")
cpp_quote("")
cpp_quote("#define STRSAVE_E_FILE_NOT_OPEN           (STRSAVE_E_FIRST+4)")
cpp_quote("// tried to write to file that's not open")
cpp_quote("")
cpp_quote("#define STRSAVE_E_IPERSIST                (STRSAVE_E_FIRST+5)")
cpp_quote("// classes saved must support IPersist")
cpp_quote("")
cpp_quote("#define STRSAVE_E_CLASS_ISTRUCTUREDSTORAGE2 (STRSAVE_E_FIRST+6)")
cpp_quote("// the class does not support the IStructuredStorage2 interface")
cpp_quote("")
cpp_quote("#define STRSAVE_E_MUST_HAVE_ONE_UNIT        (STRSAVE_E_FIRST+7)")
cpp_quote("// all structured storage documents must have at least on unit ")
cpp_quote("")
cpp_quote("#define STRSAVE_E_ONLY_ONE_UNIT             (STRSAVE_E_FIRST+8)")
   
[
	uuid(B9507D8C-7100-11D3-89BB-006097C68A9C),
	version(1.00),
    helpfile("WBFLTools.chm"),
    helpcontext(IDH_WbflTools),
	helpstring("WBFLTools Library")
]
library WBFLTools
{
	importlib("stdole32.tlb");
	importlib("stdole2.tlb");

   /// Constant defining the license agreement type
   typedef [public,helpstring("enum LicenseType"),helpcontext(IDH_LicenseType),uuid(AB6DF408-C7B1-11D3-8A1D-006097C68A9C)] 
   enum 
   {
      ltAROSL = 1, ///< Alternate Route Open Source License
      ltARLOSL = 2 ///< Alternate Route Library Open Source License
   } LicenseType;

   /// Constant indicating the user's acceptance of the license agreement
   typedef [public,helpstring("enum AcceptanceType"),helpcontext(IDH_AcceptanceType),uuid(AB6DF409-C7B1-11D3-8A1D-006097C68A9C)] 
   enum 
   {
      atAccept = 1, ///< The user accepts the license agreement
      atReject = 2  ///< The user rejects the license agreement
   } AcceptanceType;

   /// Interface for loading data that was saved to file storage with IStructuredSave
   [
      uuid(0131A8C2-26EB-11D2-8EB0-006097DF3C68),
      helpstring("IStructuredLoad Interface"),
      pointer_default(unique)
   ]
   interface IStructuredLoad : IUnknown
   {
      /// Opens the file storage for reading
      [helpstring("method Open")] HRESULT Open([in] LPCTSTR name);

      /// Read the beginning of a storage unit
      [helpstring("method BeginUnit")] HRESULT BeginUnit([in] LPCTSTR name);

      /// Read the end of a storage unit, advancing to the next storage unit
      [helpstring("method EndUnit")] HRESULT EndUnit();

      /// Returns the version number of the current storage unit.
      [propget, helpstring("property Version")] HRESULT Version([out, retval] Float64 *pVal);

      /// Returns the version number of the current storage unit's parent storage unit
      [propget, helpstring("property ParentVersion")] HRESULT ParentVersion([out, retval] Float64 *pVal);

      /// Reads the version number of the top most storage unit
      [propget, helpstring("property TopVersion")] HRESULT TopVersion([out, retval] Float64 *pVal);

      /// Returns the name of the current storage unit's parent storage unit
      [propget, helpstring("property ParentUnit")] HRESULT ParentUnit([out, retval]BSTR* pParentUnit);

      /// Reads a property from the current storage unit
      ///
      /// \note Before calling this method you must set the variant type for the property
      /// \code
      /// VARIANT var;
      /// var.vt = VT_R8;
      /// pLoad->get_Property(_T("MyProperty"),&var);
      /// Float64 value = var.dblVal;
      /// \endcode
      [propget, helpstring("property Property")] HRESULT Property([in] LPCTSTR name, [out, retval] VARIANT *pVal);

      /// Returns S_OK if at the end of the structured storage, otherwise S_FALSE
      [helpstring("method EndOfStorage")] HRESULT EndOfStorage();

      /// Closes the storage unit
      [helpstring("method Close")] HRESULT Close();

      /// Retreives the XML string for an entire storage unit
      [helpstring("mehtod LoadRawUnit")] HRESULT LoadRawUnit([out] BSTR* pbstrUnit);
   };

   /// Interface for saving data to a structured file storage object
   [
      uuid(0131A8C4-26EB-11D2-8EB0-006097DF3C68),
      helpstring("IStructuredSave Interface"),
      pointer_default(unique)
   ]
   interface IStructuredSave : IUnknown
   {
      /// Open the structured storage
      [helpstring("method Open")] HRESULT Open([in] LPCTSTR name);

      /// Creates a storage unit
      /// \note Even though the version is a floating point number, use integer values. International users use different formats to represent numbers (e.g. commas instead of decimal point, spaces, etc.) This causes problems with the version number assumptions in the implementation.
      [helpstring("method BeginUnit")] HRESULT BeginUnit(
         [in] LPCTSTR name, ///< name of storage unit. 
         [in] Float64 ver ///< storage unit version.
      );

      /// Call this method to advance to the next storage unit
      [helpstring("method EndUnit")] HRESULT EndUnit();

      /// Returns the version number of the current storage unit.
      [propget, helpstring("property Version")] HRESULT Version([out, retval] Float64 *pVal);

      /// Returns the version number of the current storage unit's parent storage unit
      [propget, helpstring("property ParentVersion")] HRESULT ParentVersion([out, retval] Float64 *pVal);

      /// Returns the name of the current storage unit's parent storage unit
      [propget, helpstring("property ParentUnit")] HRESULT ParentUnit([out, retval]BSTR* pParentUnit);

      /// Reads the version number of the top most storage unit
      [propget, helpstring("property TopVersion")] HRESULT TopVersion([out, retval] Float64 *pVal);

      /// Writes a property to the current storage unit
      ///
      /// \note You must set the variant type before storing this property. This is done automatically if your use the CComVariant object
      /// \code
      /// pSave->put_Property(_T("MyProperty"),CComVariant(value));
      /// \endcode
      [propput, helpstring("property Property")] HRESULT Property([in] LPCTSTR name, [in] VARIANT newVal);

      /// Closes the storage unit
      [helpstring("method Close")] HRESULT Close();

      /// Saves a raw XML string that represents a complete storage unit
      [helpstring("mehtod SaveRawUnit")] HRESULT SaveRawUnit([in]LPCTSTR unitXML);
   };

   /// Objects that need structured storage services should implement this interface.
   [
      object,
      uuid(5693D0F4-AC55-11d4-8B4B-006097C68A9C),
      helpstring("IStructuredStorage Interface"),
      pointer_default(unique)
   ]
   interface IStructuredStorage : IUnknown
   {
      /// Called when data is to be loaded
      [helpstring("method Load")] HRESULT Load(
         [in] IStructuredLoad* load ///< A StructuredLoad object providing structured storage services
      );

      /// Called when data is to be saved
      [helpstring("method Save")] HRESULT Save(
         [in] IStructuredSave* save ///< A StructuredSave object providing structured storage services
      );
   };

   /// Interface for loading data that was saved to file storage with IStructuredSave2.
   ///
   /// Objects implementing this interface must be OLE Automation compatible
	[
      object,	
		uuid(88110BF6-AC46-11d4-8B4B-006097C68A9C),
	   oleautomation,
		helpstring("IStructuredLoad2 Interface"),
		pointer_default(unique)
	]
	interface IStructuredLoad2 : IUnknown
	{
      /// Opens the file storage for reading
      [helpstring("method Open"), helpcontext(IDH_Load_Open)] HRESULT Open([in] BSTR bstrFile);

      /// Read the beginning of a storage unit
      [helpstring("method BeginUnit"), helpcontext(IDH_Load_Begin_Unit)] HRESULT BeginUnit([in] BSTR bstrUnit);

      /// Read the end of a storage unit, advancing to the next storage unit
      [helpstring("method EndUnit"), helpcontext(IDH_Load_End_Unit)] HRESULT EndUnit([out,retval]VARIANT_BOOL* bEnd);
      
      /// Returns the version number of the current storage unit.
      [propget,helpstring("property Version"), helpcontext(IDH_Load_Version)] HRESULT Version([out, retval] Float64 *pVal);

      /// Reads the version number of the top most storage unit
      [propget,helpstring("property TopVersion"), helpcontext(IDH_Load_TopVersion)] HRESULT TopVersion([out, retval] Float64 *pVal);

      /// Reads a property from the current storage unit
      /// \note Unlike IStructuredLoad::Property, the variant type need not be set prior to retreiving the property
      [propget,helpstring("property Property"), helpcontext(IDH_Load_Property)] HRESULT Property([in] BSTR bstrPropName, [out, retval] VARIANT *pVal);

      /// Returns S_OK if at the end of the structured storage, otherwise S_FALSE
      [helpstring("method EndOfStorage"), helpcontext(IDH_Load_End_Of_Storage2)] HRESULT EndOfStorage([out,retval]VARIANT_BOOL* bEnd);

      /// Closes the storage unit
      [helpstring("method Close"), helpcontext(IDH_Load_Close)] HRESULT Close();
	};
   
   /// Interface for saving data to a structured file storage object
   ///
   /// Objects implementing this interface must be OLE Automation compatible
   [
        object,	
		uuid(88110BF7-AC46-11d4-8B4B-006097C68A9C),
	   oleautomation,
		helpstring("IStructuredSave2 Interface"),
		pointer_default(unique)
	]
	interface IStructuredSave2 : IUnknown
	{
      /// Open the structured storage
      [helpstring("method Open"), helpcontext(IDH_Save_Open)] HRESULT Open([in] BSTR bstrFileName);

      /// Creates a storage unit
      /// \note Even though the version is a floating point number, use integer values. International users use different formats to represent numbers (e.g. commas instead of decimal point, spaces, etc.) This causes problems with the version number assumptions in the implementation.
      [helpstring("method BeginUnit"), helpcontext(IDH_Save_Begin_Unit)] HRESULT BeginUnit(
         [in] BSTR bstrUnit, ///< name of storage unit
         [in] Float64 ver ///< storage unit version
      );

      /// Call this method to advance to the next storage unit
      [helpstring("method EndUnit"), helpcontext(IDH_Save_End_Unit)] HRESULT EndUnit();

      /// Returns the version number of the current storage unit.
      [propget, helpstring("property Version"), helpcontext(IDH_Save_Version)] HRESULT Version([out, retval] Float64 *pVal);

      /// Reads the version number of the top most storage unit
      [propget, helpstring("property TopVersion"), helpcontext(IDH_Save_TopVersion)] HRESULT TopVersion([out, retval] Float64 *pVal);
      
      /// Writes a property to the current storage unit
      [propput, helpstring("property Property"), helpcontext(IDH_Save_Property)] HRESULT Property([in] BSTR bstrPropName, [in] VARIANT newVal);

      /// Closes the storage unit
      [helpstring("method Close"), helpcontext(IDH_Save_Close)] HRESULT Close();
	};

   /// OLE Automation compatible objects that need structured storage services should implement this interface.
   [
   object,
   oleautomation,
   uuid(5693D0F5-AC55-11d4-8B4B-006097C68A9C),
   helpstring("IStructuredStorage2 Interface"),
   pointer_default(unique)
   ]
   interface IStructuredStorage2 : IUnknown
   {
      /// Called when data is to be loaded
      [helpstring("method Load"), helpcontext(IDH_ISS2_Load)] HRESULT Load(
         [in] IStructuredLoad2* load ///< A StructuredLoad2 object providing structured storage services
      );

      /// Called when data is to be saved
      [helpstring("method Save"), helpcontext(IDH_ISS2_Save)] HRESULT Save(
         [in] IStructuredSave2* save ///< A StructuredSave2 object providing structured storage services
      );
   }; 

   /// Interface defining the behavior of log file services.
   [
      uuid(0BC4B500-27FF-11d2-8EB2-006097DF3C68),
      helpstring("ILogFile Interface"),
      pointer_default(unique)
   ]
   interface ILogFile : IUnknown
   {
      /// Opens a log file
      [helpstring("method Open")] HRESULT Open(
         [in] LPCTSTR name,  ///< name of the log file
         [out] DWORD* pdwCookie ///< cookie identifying the log file
      );

      /// Property indicating if the line endings are added to messages. If True, line ends are added to log messages, otherwise logging assumes messages passed to LogMessage contain line endings.
      [propput, helpstring("property EndLines")] HRESULT EndLines([in] BOOL bEndLines);
      [propget, helpstring("property EndLines")] HRESULT EndLines([out, retval] BOOL* pbEndLines);

      /// Logs a message
      [helpstring("method LogMessage")] HRESULT LogMessage(
         [in] DWORD dwCookie,  ///< a cookie that identifies a log file
         [in] LPCTSTR msg ///< the message to log
      );

      /// Closes a log file
      [helpstring("method Close")] HRESULT Close(
         [in] DWORD dwCookie ///< a cookie that identifies a log file
      );
   };

   /// Mohr's circle computations
   ///
   /// Mohr's circle equations
   /// \f[ Center = \left( \frac{\sigma_{ii} + \sigma_{jj}}{2} \right) \f]
   /// \f[ Radius = \sqrt{ \left( \frac{\sigma_{ii} - \sigma_{jj}}{2} \right)^2 + \sigma_{ij}^2} \f]
   /// \f[ \sigma_{Max/Min} = \left( \frac{\sigma_{ii} + \sigma_{jj}}{2} \right) \pm \sqrt{ \left( \frac{\sigma_{ii} - \sigma_{jj}}{2} \right)^2 + \sigma_{ij}^2} \f]
   /// \f[ \tan{2\theta_p} = \frac{2\sigma_{ij}}{\sigma_{ii} - \sigma_{jj}} \f]
   ///
   /// Stress Transformations
   /// \f[ \sigma_{xx} = \frac{\sigma_{ii} + \sigma_{jj}}{2} + \frac{\sigma_{ii} - \sigma_{jj}}{2}\cos{2\theta} + \sigma_{ij}\sin{2\theta} \f]
   /// \f[ \sigma_{xy} = -\frac{\sigma_{ii} - \sigma_{jj}}{2}\sin{2\theta} + \sigma_{ij}\cos{2\theta} \f]
   /// \f[ \sigma_{xx} + \sigma_{yy} = \sigma_{ii} + \sigma_{jj} \f]
   ///
   /// Strain Transformations
   /// \f[ \epsilon_{xx} = \frac{\epsilon_{ii} + \epsilon_{jj}}{2} + \frac{\epsilon_{ii} - \epsilon_{jj}}{2}\cos{2\theta} + \frac{\epsilon_{ij}}{2}\sin{2\theta} \f]
   /// \f[ \frac{\epsilon_{xy}}{2} = -\frac{\epsilon_{ii} - \epsilon_{jj}}{2}\sin{2\theta} + \frac{\epsilon_{ij}}{2}\cos{2\theta} \f]
   /// \f[ \epsilon_{xx} + \epsilon_{yy} = \epsilon_{ii} + \epsilon_{jj} \f]
   ///
   /// Inertial Transformations
   /// \f[ I_{xx} = \frac{I_{ii} + I_{jj}}{2} + \frac{I_{ii} - I_{jj}}{2}\cos{2\theta} + I_{ij}\sin{2\theta} \f]
   /// \f[ I_{xy} = -\frac{I_{ii} - I_{jj}}{2}\sin{2\theta} + I_{ij}\cos{2\theta} \f]
   /// \f[ I_{xx} + I_{yy} = I_{ii} + I_{jj} \f]
   ///
   /// \note For strains transformations, you must divide the shearing strain by 2.0 before using. Computing shear strains must be multipled by 2.0
   [
		object,
		uuid(E590D200-FF47-11D2-8CDF-F43C3928A334),
		oleautomation,
		helpstring("IMohrCircle Interface"),
		pointer_default(unique)
	]
	interface IMohrCircle : IUnknown
	{
      /// Stress in the "i" direction
		[propget, helpcontext(IDH_MohrCircle_Sii),helpstring("property Sii")] HRESULT Sii([out, retval] Float64 *sii);
		[propput, helpcontext(IDH_MohrCircle_Sii),helpstring("property Sii")] HRESULT Sii([in] Float64 sii);

      /// Stress in the "j" direction
		[propget, helpcontext(IDH_MohrCircle_Sjj),helpstring("property Sjj")] HRESULT Sjj([out, retval] Float64 *sjj);
		[propput, helpcontext(IDH_MohrCircle_Sjj),helpstring("property Sjj")] HRESULT Sjj([in] Float64 sjj);

      /// Shear stress
		[propget, helpcontext(IDH_MohrCircle_Sij),helpstring("property Sij")] HRESULT Sij([out, retval] Float64 *sij);
		[propput, helpcontext(IDH_MohrCircle_Sij),helpstring("property Sij")] HRESULT Sij([in] Float64 sij);

      /// Normal stress the corresponds to the center of the circle
		[propget, helpcontext(IDH_MohrCircle_Center),helpstring("property Center")] HRESULT Center([out, retval] Float64 *center);

      /// Radius of the circle
		[propget, helpcontext(IDH_MohrCircle_Radius),helpstring("property Radius")] HRESULT Radius([out, retval] Float64 *radius);

      /// Direction of the principle axes. The direction is measured counter-clockwise from the positive i direction, in radians.
		[propget, helpcontext(IDH_MohrCircle_PrincipleDirection),helpstring("property PrincipleDirection")] HRESULT PrincipleDirection([out, retval] Float64 *dir);

      /// Maximum principle normal stress
		[propget, helpcontext(IDH_MohrCircle_Smax),helpstring("property Smax")] HRESULT Smax([out, retval] Float64 *Smax);

      /// Minimum principle normal stress
      [propget, helpcontext(IDH_MohrCircle_Smin),helpstring("property Smin")] HRESULT Smin([out, retval] Float64 *Smin);

      /// Maximum shear stress
      [propget, helpcontext(IDH_MohrCircle_Tmax),helpstring("property Tmax")] HRESULT Tmax([out, retval] Float64 *Tmax);

      /// Computes the state of stress at a given angle
		[helpcontext(IDH_MohrCircle_ComputeState),helpstring("method ComputeState")] 
      HRESULT ComputeState(
         [in] Float64 angle, ///< angle of stress plane
         [out] Float64* S11, ///< normal stress in direction 1
         [out] Float64* S22, ///< normal stress in direction 2
         [out] Float64* S12 ///< shear stress
      );

      /// Computes the normal stress in the X-direction for the specified orientation of the stress plane.
		[helpcontext(IDH_MohrCircle_ComputeSxx),helpstring("method ComputeSxx")] HRESULT ComputeSxx([in] Float64 angle,[out,retval]Float64* sxx);

      /// Computes the shear stress for the specified orientation of the stress plane.
      [helpcontext(IDH_MohrCircle_ComputeSxy),helpstring("method ComputeSxy")] HRESULT ComputeSxy([in] Float64 angle,[out,retval]Float64* sxy);

      /// Computes the normal stress in the Y-direction for the specified orientation of the stress plane.
      [helpcontext(IDH_MohrCircle_ComputeSyy),helpstring("method ComputeSyy")] HRESULT ComputeSyy([in] Float64 angle,[out,retval]Float64* syy);
	};

   /// Alternate Route Project license notification tool.
   ///
   /// This object is a Wizard that displays the Alternate Route Project license and disclaimers to the user of an Alternate Route Project application. If you develop an Alternate Route Project application, we ask that you use this object to display the license notice whenever the program starts.
   [
		object,
		uuid(27F9E27F-7102-11D3-89BB-006097C68A9C),
		oleautomation,
		helpstring("IARPNotice Interface"),
		pointer_default(unique)
	]
	interface IARPNotice : IUnknown
	{
      /// Displays the Alternate Route Project license notice.
		[helpcontext(IDH_ArpNotice_Show),helpstring("method Show")] 
      HRESULT Show(
         [in] VARIANT_BOOL bGiveChoice, ///< Specifies if the notice should give the user a choice of accepting the license. If VARIANT_TRUE, the last step of the wizard will have an "I Accept" button and a "Cancel", otherwise it will have a "Finish" button.
         [in] LicenseType lt, ///< Indicates which license to display
         [out,retval] AcceptanceType* lResult ///< Result indicating the user's acceptance of the license agreement. If lResult is atAccept, the user has accepted the license (the "I Accept" or "Finish" button was pressed). If lResult is atReject, the user has not accepted the license (the "Cancel" button was pressed).
      );

      /// State of the "Don't show me this again" check box on the Disclaimer page
      ///
      /// It is your responsibility to save the state of the "Don't show me this again" check box between uses of this object. This includes saving the state between application runs. The system registry is a good place to save this information.
		[propget, helpcontext(IDH_ArpNotice_ShowAgain),helpstring("property ShowAgain")] HRESULT ShowAgain([out, retval] VARIANT_BOOL *pVal);
		[propput, helpcontext(IDH_ArpNotice_ShowAgain),helpstring("property ShowAgain")] HRESULT ShowAgain([in] VARIANT_BOOL newVal);
	};

   /// Interface for objects that provide error logging services.
   ///
   /// Multiple log files can be created and managed
   [
      object,
      uuid(FF5644CF-0E91-4b71-9AD6-3B50162AEA01),
      oleautomation,
      helpstring("IWBFLErrorLog Interface"),
      pointer_default(unique)
   ]
   interface IWBFLErrorLog : IUnknown
   {
      /// Opens a log
      [helpstring("method Open")] HRESULT Open(
         [in] BSTR fileName, ///< name of log file
         [out,retval] DWORD* dwCookie ///< cookie to use for subsequent logging operations
      );

      /// Logs a message to the file
      [helpstring("method LogMessage")] HRESULT LogMessage(
         [in]DWORD dwCookie, ///< cookie identifying the logfile
         [in] BSTR msg ///< the message to be logged
      );

      /// Closes a log
      [helpstring("method Close")] HRESULT Close(
         [in] DWORD dwCookie ///< cookie identifying the logfile
      );
   };

   /// Interface for a generalized progress monitor.
   ///
   /// The progress monitor does not have to be a graphical user interface element. It could be a file, the console window, or other.
   /// Multiple objects can interact with the progress monitor. Each object is identified by a "cookie".
   [
      object,
      uuid(B9CDE114-D5D8-4acc-A764-DF0C2863E028),
      oleautomation,
      helpstring("IProgressMonitor Interface"),
      pointer_default(unique)
   ]
   interface IProgressMonitor : IUnknown
   {
      // Sets the gauge value
      [propput, helpstring("Value of gauge from 0-100")]
      HRESULT GaugeValue(
         [in]long cookie, ///< identifies an object using the progress monitor
         [in] long newVal ///< the new guage value
      );

      // Sets the current display message
      [propput, helpstring("Message to be displayed")]
      HRESULT Message(
         [in]long cookie, ///< identifies an object using the progress monitor 
         [in] BSTR newVal ///< the new progress message
      );

      /// Returns VARIANT_TRUE if a monitored process was cancelled, otherwise VARIANT_FALSE
      [propget, helpstring("Check this value to see if process was cancelled")]
      HRESULT WasCancelled([out, retval] VARIANT_BOOL *pVal);
   };

   /// Implement this interface on objects that need to indicate progress with a progress monitor.
   [
      object,
      uuid(A6F2C304-53CF-4033-BC49-193B50077F3E),
      oleautomation,
      helpstring("ISupportProgressMonitor Interface"),
      pointer_default(unique)
   ]
   interface ISupportProgressMonitor : IUnknown
   {
      /// Initializes the object with a progress monitor and an identifing "cookie".
      ///
      /// The object calls the methods on IProgressMonitor as it progresses through whatever lengthy process needs monitoring.
      /// The monitored process must termining if IProgressMonitor::WasCancelled indicates an external event signaled cancellation (such as a button press in the UI)
      [helpstring("Initialize the ProgressMonitor")] HRESULT InitializeProgressMonitor(
         [in]IProgressMonitor* newVal,  ///< The progress monitor that will be providing progress feedback
         [in]long cookie ///< the cookie that must be used when calling methods on the IProgressMonitor interface
      );
   };

   /// Interface that defines the attributes of a progress window.
	[
		object,
		uuid(0A64ECCB-ABA8-4F70-98CC-5C5D69A25505),
		oleautomation,
		helpstring("IProgressMonitorWindow Interface"),
      helpcontext(IDH_ProgressMonitorWindow),
		pointer_default(unique)
	]
	interface IProgressMonitorWindow : IUnknown
	{
      /// Property that indicates if the progress window has a Cancel button
		[propget, helpcontext(IDH_ProgressMonitorWindow_HasCancel), helpstring("property HasCancel")] 
      HRESULT HasCancel([out, retval] VARIANT_BOOL *pVal);
		[propput, helpcontext(IDH_ProgressMonitorWindow_HasCancel), helpstring("property HasCancel")] 
      HRESULT HasCancel([in] VARIANT_BOOL newVal);

      /// Property that indicates if the progress window has a guage
      [propget, helpcontext(IDH_ProgressMonitorWindow_HasGauge), helpstring("property HasGauge")]
      HRESULT HasGauge([out, retval] VARIANT_BOOL *pVal);
      [propput, helpcontext(IDH_ProgressMonitorWindow_HasGauge), helpstring("property HasGauge")]
      HRESULT HasGauge([in] VARIANT_BOOL newVal);

      /// Shows the progress window
		[helpcontext(IDH_ProgressMonitorWindow_Show), helpstring("method Show")] 
      HRESULT Show(
         [in]BSTR initialMessage, ///< the first message to show in the progress window
         [in]HWND hParent ///< a handle to the parent window of the progress window
      );

      /// Hides the progress window. The progress window can be shown again by calling Show.
		[helpcontext(IDH_ProgressMonitorWindow_Hide), helpstring("method Hide")] 
      HRESULT Hide();

      /// Close the progress window and causes puts the progress into a Cancelled state
		[helpcontext(IDH_ProgressMonitorWindow_Close), helpstring("method Close")] 
      HRESULT Close();
	};

   /// Progress monitor objects can implement this interface to provide logging services.
   ///
   /// Objects using a progress monitor can query for this interface. If available, logging services
   /// can be enabled by opening a log file.
	[
		object,
		uuid(D530ADC7-94D0-43a6-901E-BDEEAD53AE79),
		oleautomation,
		helpstring("ILogProgressToFile Interface"),
      helpcontext(IDH_ILogProgressToFile),
		pointer_default(unique)
	]
	interface ILogProgressToFile : IUnknown
	{
      /// Opens a log file. Once open, progress monitor will write messages, gauge updates, and events to the log file
		[helpcontext(IDH_ILogProgressToFile_OpenLogFile), helpstring("method OpenLogFile")] 
      HRESULT OpenLogFile(BSTR FileName);

      /// Closes the log file. Closing the file stops all logging.
		[ helpcontext(IDH_ILogProgressToFile_CloseLogFile),helpstring("method CloseLogFile")] 
      HRESULT CloseLogFile();
	};

   /// Interface used to enumerate values in a container
	[
	   object,
	   uuid(79E6350B-7E91-475a-A54E-05D8AA65605B),
	   helpstring("IEnumLongArray Interface"),
	   oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumLongArray : IUnknown
	{
      /// Clone the enumerator
       [helpstring("Clone"),]
	   HRESULT Clone([out] IEnumLongArray** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] LONG* rgelt, ///< Array of size celt (or larger) of elements of interest
         [in, out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")]
	   HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// Interface for sequence container of LONG
	[
		object,
		uuid(B0BF1679-929A-466C-8F95-A7D6FA825307),
		oleautomation,
		helpstring("ILongArray Interface - An array of longs"),
      helpcontext(IDH_LongArray),
		pointer_default(unique)
	]
	interface ILongArray : IUnknown
	{
      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
		[propget, helpcontext(IDH_LongArray_Item), helpstring("property Item")] 
      HRESULT Item([in]CollectionIndexType index, [out, retval] LONG *item);
      
      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propput, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [in] LONG item);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, helpcontext(IDH_LongArray), helpstring("returns an standard COM enumerator for the collection.")]
		HRESULT _NewEnum([out, retval] IUnknown** retval);  

      /// Returns an enumeration object for the items in the array
		[propget, helpcontext(IDH_LongArray), helpstring("property _EnumElements")] 
		HRESULT _EnumElements([out, retval] IEnumLongArray* *pVal);

      /// Removes all elements from the array
		[helpcontext(IDH_LongArray_Clear), helpstring("method Clear")] 
      HRESULT Clear();

      /// Number of items in the array
		[propget, helpcontext(IDH_LongArray_Count), helpstring("property Count")] 
      HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Clones the array
		[helpcontext(IDH_LongArray_Clone), helpstring("method Clone")] 
      HRESULT Clone([out,retval]ILongArray* *clone);

      // Redimensions the size of the array, filling new elements with the default item
		[helpcontext(IDH_LongArray_ReDim), helpstring("method ReDim")] 
      HRESULT ReDim([in]CollectionIndexType size);

      /// Searches the array for the specified item and retrieves its index
      ///
      /// Returns S_OK if successful, otherwise E_FAIL
		[helpcontext(IDH_LongArray_Find), helpstring("method Find")] 
      HRESULT Find([in]LONG value, [out,retval]CollectionIndexType* fndIndex);

      /// Adds an item to the array
		[helpcontext(IDH_LongArray_Add), helpstring("method Add")] 
      HRESULT Add([in]LONG item);

      /// Removes an item from the array at the specified index. All items beyond the index are moved up one position.
		[helpcontext(IDH_LongArray_Remove), helpstring("method Remove")] 
      HRESULT Remove([in]CollectionIndexType index);

      /// Inserts an item into the array at the specified index.
		[helpcontext(IDH_LongArray_Insert), helpstring("method Insert")] 
      HRESULT Insert([in]CollectionIndexType index, [in]LONG item);

      /// Reserves space for a specified number of items.
      ///
      /// Reserving space does not create new items in the array. It only allocates space for them.
      /// This method can be called with the number of items to be inserted into the array is known in advance, making calls to Add faster.
		[helpcontext(IDH_LongArray_Reserve), helpstring("method Reserve")] 
      HRESULT Reserve([in]CollectionIndexType count);
	};

   /// Interface used to enumerate values in a container
   [
	   object,
	   uuid(6189734A-45B5-4a71-8DC1-68B030035B52),
	   helpstring("IEnumIDArray Interface"),
	   oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumIDArray : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone"),]
	   HRESULT Clone([out] IEnumIDArray** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
      HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IDType* rgelt, ///< Array of size celt (or larger) of elements of interest
         [in, out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")]
      HRESULT Reset();

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// Interface for sequence container of IDType
   [
		object,
		uuid(8F36811E-3E9D-406a-AF6E-99AE377796BD),
		oleautomation,
		helpstring("IIDArray Interface - An array of longs"),
      helpcontext(IDH_LongArray),
		pointer_default(unique)
	]
	interface IIDArray : IUnknown
	{
      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propget, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [out, retval] IDType *item);

      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propput, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [in] IDType item);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, helpcontext(IDH_LongArray), helpstring("returns an standard COM enumerator for the collection.")]
      HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an enumeration object for the items in the array
      [propget, helpcontext(IDH_LongArray), helpstring("property _EnumElements")]
      HRESULT _EnumElements([out, retval] IEnumIDArray* *pVal);

      /// Removes all elements from the array
      [helpcontext(IDH_LongArray_Clear), helpstring("method Clear")]
      HRESULT Clear();

      /// Number of items in the array
      [propget, helpcontext(IDH_LongArray_Count), helpstring("property Count")]
      HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Clones the array
      [helpcontext(IDH_LongArray_Clone), helpstring("method Clone")]
      HRESULT Clone([out, retval]IIDArray* *clone);

      // Redimensions the size of the array, filling new elements with the default item
      [helpcontext(IDH_LongArray_ReDim), helpstring("method ReDim")]
      HRESULT ReDim([in]CollectionIndexType size);

      /// Searches the array for the specified item and retrieves its index
      ///
      /// Returns S_OK if successful, otherwise E_FAIL
      [helpcontext(IDH_LongArray_Find), helpstring("method Find")]
      HRESULT Find([in]IDType value, [out, retval]CollectionIndexType* fndIndex);

      /// Adds an item to the array
      [helpcontext(IDH_LongArray_Add), helpstring("method Add")]
      HRESULT Add([in]IDType item);

      /// Removes an item from the array at the specified index. All items beyond the index are moved up one position.
      [helpcontext(IDH_LongArray_Remove), helpstring("method Remove")]
      HRESULT Remove([in]CollectionIndexType index);

      /// Inserts an item into the array at the specified index.
      [helpcontext(IDH_LongArray_Insert), helpstring("method Insert")]
      HRESULT Insert([in]CollectionIndexType index, [in]IDType item);

      /// Reserves space for a specified number of items.
      ///
      /// Reserving space does not create new items in the array. It only allocates space for them.
      /// This method can be called with the number of items to be inserted into the array is known in advance, making calls to Add faster.
      [helpcontext(IDH_LongArray_Reserve), helpstring("method Reserve")]
      HRESULT Reserve([in]CollectionIndexType count);
	};


   /// Interface used to enumerate values in a container
   [
	   object,
	   uuid(E069B7E0-762D-4f4c-9A77-48A98AC82585),
	   helpstring("IEnumIndexArray Interface"),
	   oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumIndexArray : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone"),]
	   HRESULT Clone([out] IEnumIndexArray** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
      HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] CollectionIndexType* rgelt, ///< Array of size celt (or larger) of elements of interest
         [in, out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")]
      HRESULT Reset();

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// Interface for sequence container of IndexType
   [
		object,
		uuid(C074A733-E1AB-419f-811F-56D192517490),
		oleautomation,
		helpstring("IIndexArray Interface - An array of indices"),
      helpcontext(IDH_LongArray),
		pointer_default(unique)
	]
	interface IIndexArray : IUnknown
	{
      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propget, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [out, retval] IndexType *item);

      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propput, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [in] IndexType item);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, helpcontext(IDH_LongArray), helpstring("returns an standard COM enumerator for the collection.")]
      HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an enumeration object for the items in the array
      [propget, helpcontext(IDH_LongArray), helpstring("property _EnumElements")]
      HRESULT _EnumElements([out, retval] IEnumIndexArray* *pVal);

      /// Removes all elements from the array
      [helpcontext(IDH_LongArray_Clear), helpstring("method Clear")]
      HRESULT Clear();

      /// Number of items in the array
      [propget, helpcontext(IDH_LongArray_Count), helpstring("property Count")]
      HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Clones the array
      [helpcontext(IDH_LongArray_Clone), helpstring("method Clone")]
      HRESULT Clone([out, retval]IIndexArray* *clone);

      // Redimensions the size of the array, filling new elements with the default item
      [helpcontext(IDH_LongArray_ReDim), helpstring("method ReDim")]
      HRESULT ReDim([in]CollectionIndexType size);

      /// Searches the array for the specified item and retrieves its index
      ///
      /// Returns S_OK if successful, otherwise E_FAIL
      [helpcontext(IDH_LongArray_Find), helpstring("method Find")]
      HRESULT Find([in]IndexType value, [out, retval]CollectionIndexType* fndIndex);

      /// Adds an item to the array
      [helpcontext(IDH_LongArray_Add), helpstring("method Add")]
      HRESULT Add([in]IndexType item);

      /// Removes an item from the array at the specified index. All items beyond the index are moved up one position.
      [helpcontext(IDH_LongArray_Remove), helpstring("method Remove")]
      HRESULT Remove([in]CollectionIndexType index);

      /// Inserts an item into the array at the specified index.
      [helpcontext(IDH_LongArray_Insert), helpstring("method Insert")]
      HRESULT Insert([in]CollectionIndexType index, [in]IndexType item);

      /// Reserves space for a specified number of items.
      ///
      /// Reserving space does not create new items in the array. It only allocates space for them.
      /// This method can be called with the number of items to be inserted into the array is known in advance, making calls to Add faster.
      [helpcontext(IDH_LongArray_Reserve), helpstring("method Reserve")]
      HRESULT Reserve([in]CollectionIndexType count);

      /// Clears the array and assigns a value to the first numElements in the array
      [helpcontext(IDH_LongArray_Assign), helpstring("method Assign")]
      HRESULT Assign(
         [in]CollectionIndexType numElements,  ///< number of elements to assign value
         [in]IndexType value ///< value to be assined to the first numElements in the array
      );
   };

   /// Interface used to enumerate values in a container
   [
	   object,
	   uuid(EB880B96-ACFF-4d1c-BFFD-FC032A3E1D00),
	   helpstring("IEnumDblArray Interface"),
	   oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumDblArray : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone"),]
	   HRESULT Clone([out] IEnumDblArray** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
      HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] Float64* rgelt, ///< Array of size celt (or larger) of elements of interest
         [in, out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")]
      HRESULT Reset();

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };


   /// Interface for sequence container of Float64 (double)
   [
		object,
		uuid(CABA1F9A-CEE0-40E6-91CA-18D3F4FC0718),
		oleautomation,
		helpstring("IDblArray Interface"),
      helpcontext(IDH_DblArray),
		pointer_default(unique)
	]
	interface IDblArray : IUnknown
	{
      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propget, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [out, retval] Float64 *item);

      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propput, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [in] Float64 item);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, helpcontext(IDH_LongArray), helpstring("returns an standard COM enumerator for the collection.")]
      HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an enumeration object for the items in the array
      [propget, helpcontext(IDH_LongArray), helpstring("property _EnumElements")]
      HRESULT _EnumElements([out, retval] IEnumDblArray* *pVal);

      /// Removes all elements from the array
      [helpcontext(IDH_LongArray_Clear), helpstring("method Clear")]
      HRESULT Clear();

      /// Number of items in the array
      [propget, helpcontext(IDH_LongArray_Count), helpstring("property Count")]
      HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Clones the array
      [helpcontext(IDH_LongArray_Clone), helpstring("method Clone")]
      HRESULT Clone([out, retval]IDblArray* *clone);

      // Redimensions the size of the array, filling new elements with the default item
      [helpcontext(IDH_LongArray_ReDim), helpstring("method ReDim")]
      HRESULT ReDim([in]CollectionIndexType size);

      /// Adds an item to the array
      [helpcontext(IDH_LongArray_Add), helpstring("method Add")]
      HRESULT Add([in]Float64 item);

      /// Removes an item from the array at the specified index. All items beyond the index are moved up one position.
      [helpcontext(IDH_LongArray_Remove), helpstring("method Remove")]
      HRESULT Remove([in]CollectionIndexType index);

      /// Inserts an item into the array at the specified index.
      [helpcontext(IDH_LongArray_Insert), helpstring("method Insert")]
      HRESULT Insert([in]CollectionIndexType index, [in]Float64 item);

      /// Reserves space for a specified number of items.
      ///
      /// Reserving space does not create new items in the array. It only allocates space for them.
      /// This method can be called with the number of items to be inserted into the array is known in advance, making calls to Add faster.
      [helpcontext(IDH_LongArray_Reserve), helpstring("method Reserve")]
      HRESULT Reserve([in]CollectionIndexType count);
   };

   /// Interface used to enumerate values in a container
   [
	   object,
	   uuid(68F75050-236A-4a73-B1D1-25A48221CFEF),
	   helpstring("IEnumBstrArray Interface"),
	   oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumBstrArray : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone"),]
	   HRESULT Clone([out] IEnumBstrArray** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
      HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] BSTR* rgelt, ///< Array of size celt (or larger) of elements of interest
         [in, out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")]
      HRESULT Reset();

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// Interface for sequence container of BSTR
   [
		object,
		uuid(505C846A-96F9-42FD-8202-C06170538E65),
		oleautomation,
		helpstring("IBstrArray Interface"),
      helpcontext(IDH_BStrArray),
		pointer_default(unique)
	]
	interface IBstrArray : IUnknown
	{
      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propget, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [out, retval] BSTR *item);

      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propput, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [in] BSTR item);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, helpcontext(IDH_LongArray), helpstring("returns an standard COM enumerator for the collection.")]
      HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an enumeration object for the items in the array
      [propget, helpcontext(IDH_LongArray), helpstring("property _EnumElements")]
      HRESULT _EnumElements([out, retval] IEnumBstrArray* *pVal);

      /// Removes all elements from the array
      [helpcontext(IDH_LongArray_Clear), helpstring("method Clear")]
      HRESULT Clear();

      /// Number of items in the array
      [propget, helpcontext(IDH_LongArray_Count), helpstring("property Count")]
      HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Clones the array
      [helpcontext(IDH_LongArray_Clone), helpstring("method Clone")]
      HRESULT Clone([out, retval]IBstrArray* *clone);

      // Redimensions the size of the array, filling new elements with the default item
      [helpcontext(IDH_LongArray_ReDim), helpstring("method ReDim")]
      HRESULT ReDim([in]CollectionIndexType size);

      /// Searches the array for the specified item and retrieves its index
      ///
      /// Returns S_OK if successful, otherwise E_FAIL
      [helpcontext(IDH_LongArray_Find), helpstring("method Find")]
      HRESULT Find([in]BSTR value, [out, retval]CollectionIndexType* fndIndex);

      /// Adds an item to the array
      [helpcontext(IDH_LongArray_Add), helpstring("method Add")]
      HRESULT Add([in]BSTR item);

      /// Removes an item from the array at the specified index. All items beyond the index are moved up one position.
      [helpcontext(IDH_LongArray_Remove), helpstring("method Remove")]
      HRESULT Remove([in]CollectionIndexType index);

      /// Inserts an item into the array at the specified index.
      [helpcontext(IDH_LongArray_Insert), helpstring("method Insert")]
      HRESULT Insert([in]CollectionIndexType index, [in]BSTR item);

      /// Reserves space for a specified number of items.
      ///
      /// Reserving space does not create new items in the array. It only allocates space for them.
      /// This method can be called with the number of items to be inserted into the array is known in advance, making calls to Add faster.
      [helpcontext(IDH_LongArray_Reserve), helpstring("method Reserve")]
      HRESULT Reserve([in]CollectionIndexType count);
   };

   /// Interface used to enumerate values in a container
   [
	   object,
	   uuid(ADD1A335-0A98-4ae5-9C7C-7DAEB7718DE3),
	   helpstring("IEnumUnkArray Interface"),
	   oleautomation,nonextensible,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumUnkArray : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone"),]
	   HRESULT Clone([out] IEnumUnkArray** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
      HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IUnknown** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in, out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")]
      HRESULT Reset();

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };


   /// Interface for sequence container of objects
   [
		object,
		uuid(F7E15329-3F3B-4161-9C9C-43ED3F9B689C),
		oleautomation,
		helpstring("IUnkArray Interface"),
      helpcontext(IDH_UnkArray),
		pointer_default(unique)
	]
	interface IUnkArray : IUnknown
	{
      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propget, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [out, retval] IUnknown* *item);

      /// Item at the specified position in the array
      /// \param index index of the item to retrieve
      /// \param item the item
      [propput, helpcontext(IDH_LongArray_Item), helpstring("property Item")]
      HRESULT Item([in]CollectionIndexType index, [in] IUnknown* item);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, helpcontext(IDH_LongArray), helpstring("returns an standard COM enumerator for the collection.")]
      HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an enumeration object for the items in the array
      [propget, helpcontext(IDH_LongArray), helpstring("property _EnumElements")]
      HRESULT _EnumElements([out, retval] IEnumUnkArray* *pVal);

      /// Removes all elements from the array
      [helpcontext(IDH_LongArray_Clear), helpstring("method Clear")]
      HRESULT Clear();

      /// Number of items in the array
      [propget, helpcontext(IDH_LongArray_Count), helpstring("property Count")]
      HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Clones the array
      [helpcontext(IDH_LongArray_Clone), helpstring("method Clone")]
      HRESULT Clone([out, retval]IUnkArray* *clone);

      /// Adds an item to the array
      [helpcontext(IDH_LongArray_Add), helpstring("method Add")]
      HRESULT Add([in]IUnknown* item);

      /// Removes an item from the array at the specified index. All items beyond the index are moved up one position.
      [helpcontext(IDH_LongArray_Remove), helpstring("method Remove")]
      HRESULT Remove([in]CollectionIndexType index);

      /// Inserts an item into the array at the specified index.
      [helpcontext(IDH_LongArray_Insert), helpstring("method Insert")]
      HRESULT Insert([in]CollectionIndexType index, [in]IUnknown* item);

      /// Reserves space for a specified number of items.
      ///
      /// Reserving space does not create new items in the array. It only allocates space for them.
      /// This method can be called with the number of items to be inserted into the array is known in advance, making calls to Add faster.
      [helpcontext(IDH_LongArray_Reserve), helpstring("method Reserve")]
      HRESULT Reserve([in]CollectionIndexType count);
   };


   /// A Mohr's Circle object.
   /// Implements the IMohrCircle interface
   [
		uuid(E590D201-FF47-11D2-8CDF-F43C3928A334),
      helpcontext(IDH_MohrCircle),
		helpstring("MohrCircle Class")
	]
	coclass MohrCircle
	{
		[default] interface IMohrCircle;
	};

   /// Alternate Route Project license notification tool.
   ///
   /// This object is a Wizard that displays the Alternate Route Project license and disclaimers to the user of an Alternate Route Project application. If you develop an Alternate Route Project application, we ask that you use this object to display the license notice whenever the program starts.
   /// Implements the IARPNotice interface.
   [
		uuid(27F9E280-7102-11D3-89BB-006097C68A9C),
		helpcontext(IDH_ArpNotice),
		helpstring("ARPNotice Class")
	]
	coclass ARPNotice
	{
		[default] interface IARPNotice;
	};

   /// Object that loads information from file storage that was previous saved with the IStructuredSave interface.
   ///
   /// Implements the IStrucutredLoad interface.
   [
      uuid(0131A8C3-26EB-11D2-8EB0-006097DF3C68),
      helpstring("StructuredLoad Class")
   ]
   coclass StructuredLoad
   {
      [default] interface IStructuredLoad;
   };

   /// Object that saves information to file storage.
   ///
   /// Implements the IStrucutredSave interface.
   [
      uuid(0131A8C5-26EB-11D2-8EB0-006097DF3C68),
      helpstring("StructuredSave Class")
   ]
   coclass StructuredSave
   {
      [default] interface IStructuredSave;
   };
   
   /// Object that saves information to file storage.
   ///
   /// Implements the IStrucutredSave2 interface.
   [
		uuid(043B36E6-64EE-11d5-B017-00105A9AF985),
		helpstring("StructuredSave2 Class")
	]
	coclass StructuredSave2
	{
		[default] interface IStructuredSave2;
	};

   /// Object that loads information from file storage that was previous saved with the IStructuredSave2 interface.
   ///
   /// Implements the IStrucutredLoad2 interface.
   [
		uuid(043B36E7-64EE-11d5-B017-00105A9AF985),
		helpstring("StructuredLoad2 Class")
	]
	coclass StructuredLoad2
	{
		[default] interface IStructuredLoad2;
	};

   /// Object that provides concurrent error logging services to multiple log files.
   ///
   /// Implements the IWBFLErrorLog interface
   [
      uuid(49E8A61D-E83B-4b60-B0D7-96B0D1A96CC3),
      helpstring("ErrorLog Class")
   ]
   coclass WBFLErrorLog
   {
      [default] interface IWBFLErrorLog;
   };

   /// Object that provides a progress monitor window
   ///
   /// Implements the IProgressMonitorWindow, IProgressMonitor, and ILogProgressToFile interfaces.
   [
		uuid(8C63C999-10B8-43B5-A7CC-72B6AC48283F),
		helpstring("ProgressMonitorWindow Class")
	]
	coclass ProgressMonitorWindow
	{
		[default] interface IProgressMonitorWindow;
      interface IProgressMonitor;
      interface ILogProgressToFile;
	};

   /// Array of LONG values
   ///
   /// Implements the ILongArray interface
	[
		uuid(51EAE330-F430-492C-95A1-A755D76A8C4F),
		helpstring("ILongArray Class")
	]
	coclass LongArray
	{
		[default] interface ILongArray;
	};

   /// Array of IDType values
   ///
   /// Implements the IIDArray interface
   [
		uuid(78227B01-D41C-47e7-BE49-6A8CF2EB833A),
		helpstring("IIDArray Class")
	]
	coclass IDArray
	{
		[default] interface IIDArray;
	};

   /// Array of IndexType values
   ///
   /// Implements the IIndexArray interface
   [
		uuid(0AA0835E-C025-48c6-A9DD-CD33C0BBFB7B),
		helpstring("IIndexArray Class")
	]
	coclass IndexArray
	{
		[default] interface IIndexArray;
	};

   /// Array of Float64 (double) values
   ///
   /// Implements the IDblArray interface
   [
		uuid(851D2378-0F8C-4040-8E84-B26C5E7F9528),
		helpstring("DblArray Class")
	]
	coclass DblArray
	{
		[default] interface IDblArray;
	};

   /// Array of BSTR values
   ///
   /// Implements the IBstrArray interface
   [
		uuid(FA223DB0-69C7-4FB6-90CC-0C20BE566982),
		helpstring("BstrArray Class")
	]
	coclass BstrArray
	{
		[default] interface IBstrArray;
	};

   /// Array of objects
   ///
   /// Implements the IUnkArray interface.
   /// \note Object can be of any type. They are stored in this container through their IUnknown interface.
   [
		uuid(88D26763-7BD5-4F92-A064-7497A72E7D81),
		helpstring("UnkArray Class")
	]
	coclass UnkArray
	{
		[default] interface IUnkArray;
	};


   /// Provides general file logging services
   ///
   /// Implements the ILogFile interface.
   [
      uuid(E58AB440-3AC4-4BDC-AB7C-5D3BAA61F986),
      helpstring("LogFile Class")
   ]
   coclass LogFile
   {
      [default] interface ILogFile;
   };
};
