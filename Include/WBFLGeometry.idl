///////////////////////////////////////////////////////////////////////
// Geometry - Geometric Modeling Library
// Copyright © 1999-2023  Washington State Department of Transportation
//                        Bridge and Structures Office
//
// This library is a part of the Washington Bridge Foundation Libraries
// and was developed as part of the Alternate Route Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the Alternate Route Library Open Source License as 
// published by the Washington State Department of Transportation,
// Bridge and Structures Office.
//
// This program is distributed in the hope that it will be useful,
// but is distributed AS IS, WITHOUT ANY WARRANTY; without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
// PURPOSE.  See the Alternate Route Library Open Source License for more details.
//
// You should have received a copy of the Alternate Route Library Open Source License
// along with this program; if not, write to the Washington State
// Department of Transportation, Bridge and Structures Office,
// P.O. Box 47340, Olympia, WA 98503, USA or e-mail
// Bridge_Support@wsdot.wa.gov
///////////////////////////////////////////////////////////////////////

// Geometry.idl : IDL source for Geometry.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (Geometry.tlb) and marshalling code.

// wingdi.h defines a fuction called Rectangle. We have to exclude wingdi.h or
// this file won't compile because of a conflict between the GDI fuction and the
// Rectangle object.


import "oaidl.idl";
import "ocidl.idl";
import "WBFLTypes.idl";

// Context Help IDs
#include <Geometry.hh>
#include <Primitives.hh>

cpp_quote("#define GEOMETRY_E_NOTNORMALIZED             MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,512)")
cpp_quote("#define GEOMETRY_E_ZEROMAGNITUDE             MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,513)")
cpp_quote("#define GEOMETRY_E_MAGNITUDELESSTHANZERO     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,514)")
cpp_quote("#define GEOMETRY_E_SAMEPOINTS                MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,515)")
cpp_quote("#define GEOMETRY_E_NOSOLUTIONS               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,516)")
cpp_quote("#define GEOMETRY_E_RADIUS                    MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,517)")
cpp_quote("#define GEOMETRY_E_DIMENSION                 MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,518)")
cpp_quote("#define GEOMETRY_E_MIDORDINATE               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,519)")
cpp_quote("#define GEOMETRY_E_ANGLE                     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,520)")
cpp_quote("#define GEOMETRY_E_DISTANCE                  MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,521)")
cpp_quote("#define GEOMETRY_E_COINCIDENTPOINTS          MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,522)")
cpp_quote("#define GEOMETRY_E_COLINEAR                  MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,523)")

[
	uuid(55B8EF8A-FADF-11D2-8CDF-9849C70CC734),
	version(1.0),
   helpfile("WBFLGeometry.chm"),
   helpcontext(IDH_WbflGeometryLibrary),
	helpstring("WBFLGeometry Library")
]
library WBFLGeometry
{
	importlib("stdole32.tlb");
	importlib("stdole2.tlb");

   /// Constant defining a locator point.
   ///
   /// A rectangle can be draw around every shape. This rectangle is called the bounding box. There are 9 key points on this box, called locator points.
   /// Additionally, a shape can designate a hook point to assist in locating the shape.
   /// \image html LocatorPoints.jpg
   typedef
   [
      public,
      uuid(7615DFC0-0013-11d3-8CDF-8BF0A4AD5B35),
      helpstring("enum LocatorPointType"),
	  helpcontext(IDH_LocatorPointType)
   ] 
   enum 
   {
      lpHookPoint = 0, ///< the hook point
      lpTopLeft = 1,   ///< top left corner of the bounding box
      lpTopCenter = 2, ///< mid-point of the top edge of the bounding box
      lpTopRight = 3, ///< top right corner of the bounding box
      lpCenterLeft = 4, ///< mid-point of the left edge of the bounding box
      lpCenterCenter = 5, ///< center point of the bounding box
      lpCenterRight = 6, ///< mid-point of the right edge of the bounding box
      lpBottomLeft = 7, ///< bottom left corner of the bounding box
      lpBottomCenter = 8, ///< mid-point of the bottom edge of the bounding box
      lpBottomRight = 9 ///< bottom right corner of the bounding box
   } LocatorPointType;

   /// Designates a coordinate system for variant section properties.
   typedef
   [
      public,
      uuid(FABE04A0-FF96-11d2-8CDF-F43C3928A334),
      helpstring("enum CoordinateSystemType"),
	  helpcontext(IDH_CoordinateSystemType)
   ] 
   enum 
   {
 	   csCentroidal = 0, ///< centroidal coordinate system
 	   csGlobal     = 1, ///< global coordinate system
 	   csPrinciple  = 2, ///< principle axes coordinate system
       csUser       = 3 ///< an arbritary user defined coordinate system
   } CoordinateSystemType;

   /// Designates a type of coordinate transformation
   typedef [public,helpstring("enum XformType"),helpcontext(IDH_XformType),uuid(D03C2CC0-5DD8-11d3-8CDF-A057587EDC05)] 
   enum 
   {
      xfrmOldToNew = 1, ///< Transform coordinate from the original coordinate system to the new coordinate system
      xfrmNewToOld = 2  ///< Transform coordinate from the new coordinate system to the original coordinate system.
   } XformType;

   /// Designates the orientation of a traffic barrier shape.
   typedef
   [
      public,
      uuid(C64376A0-03CF-11d3-8CDF-EBFB6612CA35),
      helpstring("enum TrafficBarrierOrientation"),
	  helpcontext(IDH_TrafficBarrierOrientation)
   ] 
   enum 
   {
 	   tboLeft, ///< Traffic barrier shape is oriented so it is on the left side of a roadway.
      tboRight ///< Traffic barrier shape is oriented so it is on the right side of a roadway.
   } TrafficBarrierOrientation;

   /// Designates common beam shapes
   typedef
   [
      public,
      uuid(FDC9A761-CA46-4364-87DE-E0A90A750A14),
      helpstring("enum BeamShapeType")
   ]
   enum
   {
      AASHTO_TypeI,   ///< AASHTO Type I precast girder shape
      AASHTO_TypeII,  ///< AASHTO Type II precast girder shape
      AASHTO_TypeIII, ///< AASHTO Type III precast girder shape
      AASHTO_TypeIV,  ///< AASHTO Type IV precast girder shape
      AASHTO_TypeV,   ///< AASHTO Type V precast girder shape
      AASHTO_TypeVI,  ///< AASHTO Type VI precast girder shape
      AASHTO_BT54,    ///< AASHTO BT54 precast girder shape
      AASHTO_BT63,    ///< AASHTO BT63 precast girder shape
      AASHTO_BT72,    ///< AASHTO BT72 precast girder shape
      WSDOT_W42G,     ///< WSDOT W42G precast girder shape
      WSDOT_W50G,     ///< WSDOT W50G precast girder shape
      WSDOT_W58G,     ///< WSDOT W58G precast girder shape
      WSDOT_W74G,     ///< WSDOT W74G precast girder shape
      WSDOT_WF36G,    ///< WSDOT WF36G precast girder shape
      WSDOT_WF42G,    ///< WSDOT WF42G precast girder shape
      WSDOT_WF50G,    ///< WSDOT WF50G precast girder shape
      WSDOT_WF58G,    ///< WSDOT WF58G precast girder shape
      WSDOT_WF66G,    ///< WSDOT WF66G precast girder shape
      WSDOT_WF74G,    ///< WSDOT WF74G precast girder shape
      WSDOT_WF83G,    ///< WSDOT WF83G precast girder shape
      WSDOT_WF95G,    ///< WSDOT WF95G precast girder shape
      WSDOT_WF100G,   ///< WSDOT WF100G precast girder shape
      TxDOT_Tx28,     ///< TxDOT Tx28 precast girder shape
      TxDOT_Tx34,     ///< TxDOT Tx34 precast girder shape
      TxDOT_Tx40,     ///< TxDOT Tx40 precast girder shape
      TxDOT_Tx46,     ///< TxDOT Tx46 precast girder shape
      TxDOT_Tx54,     ///< TxDOT Tx54 precast girder shape
      TxDOT_Tx62,     ///< TxDOT Tx62 precast girder shape
      TxDOT_Tx70,     ///< TxDOT Tx70 precast girder shape

      WSDOT_U54G4,    ///< WSDOT U54G4 precast tub girder shape
      WSDOT_U54G5,    ///< WSDOT U54G5 precast tub girder shape
      WSDOT_U54G6,    ///< WSDOT U54G6 precast tub girder shape
      WSDOT_U66G4,    ///< WSDOT U66G4 precast tub girder shape
      WSDOT_U66G5,    ///< WSDOT U66G5 precast tub girder shape 
      WSDOT_U66G6,    ///< WSDOT U66G6 precast tub girder shape
      WSDOT_U78G4,    ///< WSDOT U78G4 precast tub girder shape
      WSDOT_U78G5,    ///< WSDOT U78G5 precast tub girder shape
      WSDOT_U78G6,    ///< WSDOT U78G6 precast tub girder shape
      WSDOT_UF60G4,   ///< WSDOT UF60G4 precast tub girder shape
      WSDOT_UF60G5,   ///< WSDOT UF60G5 precast tub girder shape
      WSDOT_UF60G6,   ///< WSDOT UF60G6 precast tub girder shape
      WSDOT_UF72G4,   ///< WSDOT UF72G4 precast tub girder shape
      WSDOT_UF72G5,   ///< WSDOT UF72G5 precast tub girder shape
      WSDOT_UF72G6,   ///< WSDOT UF72G6 precast tub girder shape
      WSDOT_UF84G4,   ///< WSDOT UF84G4 precast tub girder shape
      WSDOT_UF84G5,   ///< WSDOT UF84G5 precast tub girder shape
      WSDOT_UF84G6,   ///< WSDOT UF84G6 precast tub girder shape
      TxDOT_U40,      ///< TxDOT U40 precast tub girder shape
      TxDOT_U54,      ///< TxDOT U54 precast tub girder shape
   } BeamShapeType;

   // FORWARD DECLARATIONS
   interface ISize2d;
   interface ISize3d;
   interface IVector3d;

   /// Interface defining a point in a two dimensional Cartesian coordinate system.
	[
		object,
		uuid(55B8EF96-FADF-11D2-8CDF-9849C70CC734),
      oleautomation,
      helpcontext(IDH_IPoint2d),
		helpstring("IPoint2d Interface"),
		pointer_default(unique)
	]
	interface IPoint2d : IUnknown
	{
      /// Horizontal coordinate
		[propget, helpstring("property X"),helpcontext(IDH_IPoint2d_X)]
      HRESULT X([out, retval] Float64 *x);

		[propput, helpstring("property X"),helpcontext(IDH_IPoint2d_X)]
      HRESULT X([in] Float64 x);

      /// Vertical coordinate
      [propget, helpstring("property Y"),helpcontext(IDH_IPoint2d_Y)]
      HRESULT Y([out, retval] Float64 *y);

		[propput, helpstring("property Y"),helpcontext(IDH_IPoint2d_Y)]
      HRESULT Y([in] Float64 y);

      /// Moves this point to (x,y).
		[helpstring("method Move"), helpcontext(IDH_IPoint2d_Move)]
      HRESULT Move([in] Float64 x,[in] Float64 y);

      /// Moves this point to the location defined by another point
		[helpstring("method MoveEx"), helpcontext(IDH_IPoint2d_MoveEx)]
      HRESULT MoveEx(
         [in] IPoint2d* to ///< the point to move this point to
      );

      /// Offsets this point by the amount (dx,dy).
      /// \image html Point2d/Offset.jpg
		[helpstring("method Offset"), helpcontext(IDH_IPoint2d_Offset)]
      HRESULT Offset(
         [in] Float64 dx, ///< Horizontal offset
         [in] Float64 dy ///< Vertical offset
      );

      /// Offsets this point by the amount the specified size.
      /// \image html Point2d/Offset.jpg
      [helpstring("method OffsetEx"), helpcontext(IDH_IPoint2d_OffsetEx)]
      HRESULT OffsetEx(
         [in] ISize2d* size ///< Size2d object providing the offset dimensions
      );

      /// Repositions the point by rotating it about another point.
      /// \image html Point2d/Rotate.jpg
      [helpstring("method Rotate"), helpcontext(IDH_IPoint2d_Rotate)]
      HRESULT Rotate(
         [in] Float64 cx, ///< Horizontal coordinate of center point
         [in] Float64 cy, ///< Vertical coordinate of center point
         [in] Float64 angle ///< Rotation angle, measured counter-clockwise from the positive X axis.
      );

      /// Repositions the point by rotating it about another point.
      /// \image html Point2d/Rotate.jpg
      [helpstring("method RotateEx"), helpcontext(IDH_IPoint2d_RotateEx)]
      HRESULT RotateEx(
         [in] IPoint2d* center, ///< Center of rotation
         [in] Float64 angle ///< Rotation angle, measured counter-clockwise from the positive X axis.
      );

      /// Returns S_OK if pOther is at the same location as this point, otherwise returns S_FALSE.
      [helpstring("method SameLocation"),helpcontext(IDH_IPoint2d_SameLocation)]
      HRESULT SameLocation([in]IPoint2d* pOther);

      /// Returns the X and Y coordinates of this point through the pX and pY parameters.
      [helpstring("method Location"),helpcontext(IDH_IPoint2d_Location)]
      HRESULT Location([out]Float64* pX,[out]Float64* pY);

      /// Returns the distance between this point and a point defined by (x,y)
      [helpstring("method Distance"),helpcontext(IDH_IPoint2d_Distance)]
      HRESULT Distance([in]Float64 x,[in]Float64 y,[out,retval]Float64* pDistance);

      /// Returns the distance between this point and pOther
      [helpstring("method DistanceEx"),helpcontext(IDH_IPoint2d_DistanceEx)]
      HRESULT DistanceEx([in]IPoint2d* pOther,[out,retval]Float64* pDistance);

      /// Returns a size object defined by this point and (x,y)
      [helpstring("method Size")]
      HRESULT Size([in]Float64 x, [in]Float64 y, [out, retval]ISize2d** ppSize);

      /// Returns a size object defined by this point and another point object
      [helpstring("method SizeEx")]
      HRESULT SizeEx([in]IPoint2d* pPoint, [out, retval]ISize2d** ppSize);

      /// Creates a clone of this object
      [helpstring("method Clone")/*,helpcontext(IDH_IPoint2d_Location)*/]
      HRESULT Clone([out,retval]IPoint2d** ppPoint);
   };

   /// Interface defining a size representing the vertical and horizontal extents of a rectangular region
   [
		object,
		uuid(55B8EF97-FADF-11D2-8CDF-9849C70CC734),
		oleautomation,
		helpstring("ISize2d Interface"),
      helpcontext(IDH_ISize2d),
		pointer_default(unique)
	]
	interface ISize2d : IUnknown
	{
      /// The horizontal extentions
		[propget, helpstring("property Dx"), helpcontext(IDH_ISize2d_Dx)]
      HRESULT Dx([out, retval] Float64 *dx);

		[propput, helpstring("property Dx"), helpcontext(IDH_ISize2d_Dx)]
      HRESULT Dx([in] Float64 dx);

      /// The vertical extents
		[propget, helpstring("property Dy"), helpcontext(IDH_ISize2d_Dy)]
      HRESULT Dy([out, retval] Float64 *dy);

		[propput, helpstring("property Dy"), helpcontext(IDH_ISize2d_Dy)]
      HRESULT Dy([in] Float64 dy);

      /// Length of the diagonal
		[propget, helpstring("property Magnitude"),helpcontext(IDH_ISize2d_Magnitude)]
      HRESULT Magnitude([out, retval] Float64 *mag);

      /// Modifies the dimensions by multipying Dx and Dy by a scaling factor
      /// Scaling factors greater than 1.0 enlarge the dimensions
		[helpstring("method Scale"),helpcontext(IDH_ISize2d_Scale)]
      HRESULT Scale([in] Float64 factor);

      /// Returns the dimensions
      [helpstring("method Dimensions"),helpcontext(IDH_ISize2d_Dimensions)]
      HRESULT Dimensions(
         [out]Float64* pDx, ///< horizontal extent
         [out]Float64* pDy  ///< vertical extent
      );

      /// Creates a clone of this object
      [helpstring("method Clone")/*,helpcontext(IDH_ISize2d_Clone)*/]
      HRESULT Clone([out,retval]ISize2d** clone);
   };


   /// Interface defining a rectangular region
   [
		object,
		uuid(55B8EF98-FADF-11D2-8CDF-9849C70CC734),
		oleautomation,
      helpcontext(IDH_IRect2d),
		helpstring("IRect2d Interface"),
		pointer_default(unique)
	]
	interface IRect2d : IUnknown
	{
      /// Location of the left edge of a rectangle
		[propget, helpstring("property Left"), helpcontext(IDH_IRect2d_Left)]
      HRESULT Left([out, retval] Float64 *pVal);

		[propput, helpstring("property Left"), helpcontext(IDH_IRect2d_Left)]
      HRESULT Left([in] Float64 newVal);

      /// Location of the right edge of a rectangle
      [propget, helpstring("property Right"), helpcontext(IDH_IRect2d_Right)]
      HRESULT Right([out, retval] Float64 *pVal);

		[propput, helpstring("property Right"), helpcontext(IDH_IRect2d_Right)]
      HRESULT Right([in] Float64 newVal);

      /// Location of the top edge of a rectangle
      [propget, helpstring("property Top"), helpcontext(IDH_IRect2d_Top)]
      HRESULT Top([out, retval] Float64 *pVal);

		[propput, helpstring("property Top"), helpcontext(IDH_IRect2d_Top)]
      HRESULT Top([in] Float64 newVal);

      /// Location of the bottom edge of a rectangle
      [propget, helpstring("property Bottom"), helpcontext(IDH_IRect2d_Bottom)]
      HRESULT Bottom([out, retval] Float64 *pVal);

		[propput, helpstring("property Bottom"), helpcontext(IDH_IRect2d_Bottom)]
      HRESULT Bottom([in] Float64 newVal);

      /// Area of a rectangle
		[propget, helpstring("property Area"), helpcontext(IDH_IRect2d_Area)]
      HRESULT Area([out, retval] Float64 *pVal);

      /// Bottom left point of a rectangle
      [propget, helpstring("property BottomLeft"), helpcontext(IDH_IRect2d_BottomLeft)]
      HRESULT BottomLeft([out, retval] IPoint2d* *pVal);

      /// Bottom center point of a rectangle
      [propget, helpstring("property BottomCenter"), helpcontext(IDH_IRect2d_BottomCenter)]
      HRESULT BottomCenter([out, retval] IPoint2d* *pVal);

      /// Bottom right point of a rectangle
      [propget, helpstring("property BottomRight"), helpcontext(IDH_IRect2d_BottomRight)]
      HRESULT BottomRight([out, retval] IPoint2d* *pVal);

      /// Center point of a rectangle
      [propget, helpstring("property CenterCenter"), helpcontext(IDH_IRect2d_CenterCenter)]
      HRESULT CenterCenter([out, retval] IPoint2d* *pVal);

      /// Center point on left edge of a rectangle
      [propget, helpstring("property CenterLeft"), helpcontext(IDH_IRect2d_CenterLeft)]
      HRESULT CenterLeft([out, retval] IPoint2d* *pVal);

      /// Center point on right edge of a rectangle
      [propget, helpstring("property CenterRight"), helpcontext(IDH_IRect2d_CenterRight)]
      HRESULT CenterRight([out, retval] IPoint2d* *pVal);

      /// Top left point of a rectangle
      [propget, helpstring("property TopLeft"), helpcontext(IDH_IRect2d_TopLeft)]
      HRESULT TopLeft([out, retval] IPoint2d* *pVal);

      /// Center point on top edge of a rectangle
      [propget, helpstring("property TopCenter"), helpcontext(IDH_IRect2d_TopCenter)]
      HRESULT TopCenter([out, retval] IPoint2d* *pVal);

      /// Top right point of a rectangle
      [propget, helpstring("property TopRight"), helpcontext(IDH_IRect2d_TopRight)]
      HRESULT TopRight([out, retval] IPoint2d* *pVal);

      /// Enlarges the rectangle to contain a specified point
		[helpstring("method BoundPoint"), helpcontext(IDH_IRect2d_BoundPoint)]
      HRESULT BoundPoint(
         [in] Float64 x, ///< horizontal location of bounding point
         [in] Float64 y  ///< vertical location of bounding point
      );

      /// Enlarges the rectangle to contain a specified point
      [helpstring("method BoundPointEx"), helpcontext(IDH_IRect2d_BoundPointEx)]
      HRESULT BoundPointEx(
         [in]IPoint2d* pPoint ///< the bounding point
      );

      /// Width of a rectangle
		[propget, helpstring("property Width"), helpcontext(IDH_IRect2d_Width)]
      HRESULT Width([out, retval] Float64 *pVal);
      
      /// Height of a rectangle
      [propget, helpstring("property Height"), helpcontext(IDH_IRect2d_Height)]
      HRESULT Height([out, retval] Float64 *pVal);

      /// Inflates a rectangle by subtracting dx from Left, adding dx to Right, subtracting dy from Bottom and adding dy to Top
		[helpstring("method Inflate"), helpcontext(IDH_IRect2d_Inflate)]
      HRESULT Inflate(
         [in] Float64 dx, ///< amount to inflate the rectangle horizontally
         [in] Float64 dy  ///< amount to inflate the rectangle vertically
      );

      /// Inflates a rectangle by subtracting pSize.dx from Left, adding pSize.dx to Right, subtracting size.dy from Bottom and adding size.dy to Top
      [helpstring("method InflateEx"), helpcontext(IDH_IRect2d_InflateEx)]
      HRESULT InflateEx(
         [in] ISize2d* pSize ///< Size2d object that defines the amount to inflate the rectangle
      );

      /// Normalizes the rectangle by making Left < Right and Bottom < Top.
		[helpstring("method Normalize"), helpcontext(IDH_IRect2d_Normalize)]
      HRESULT Normalize();

      /// Moves the rectangle by the amount dx and dy
		[helpstring("method Offset"), helpcontext(IDH_IRect2d_Offset)]
      HRESULT Offset(
         [in] Float64 dx, ///< horizontal offset
         [in] Float64 dy  ///< vertical offset
      );

      /// Moves the rectangle by the amount pSize.dx and pSize.dy
      [helpstring("method OffsetEx"), helpcontext(IDH_IRect2d_OffsetEx)]
      HRESULT OffsetEx(
         [in] ISize2d* pSize ///< amount to offset the rectangle
      );

      /// Creates a rectangle that is the intersection of this rectangle and another rectangle
      /// \image html Rect2d/Intersect.jpg
		[helpstring("method Intersect"), helpcontext(IDH_IRect2d_Intersect)]
      HRESULT Intersect(
         [in] IRect2d* pRect,  ///< the rectangle to intersect with this rectangle
         [out,retval] IRect2d** ppIntersection ///< the resulting rectangular intersection
      );

      /// Modifies this rectangle to be the union of this rectangle and another rectangle
      /// \image html Rect2d/Union.jpg
		[helpstring("method Union"), helpcontext(IDH_IRect2d_Union)]
      HRESULT Union(
         [in] IRect2d* pRect ///< The rectangle to form a union with this rectangle
      );

      /// Creates a rectangle thas is the union of this rectangle and another rectangle
      /// \image html Rect2d/Union.jpg
      [helpstring("method UnionBy"), helpcontext(IDH_IRect2d_UnionBy)]
      HRESULT UnionBy(
         [in] IRect2d* pRect,  ///< the rectangle to form a union with this rectangle
         [out,retval] IRect2d** ppUnion ///< the resulting rectangular union
      );

      /// Creates a Size2d object from this rectangle
		[helpstring("method Size"), helpcontext(IDH_IRect2d_Size)]
      HRESULT Size([out,retval] ISize2d** ppSize);

      /// Sets Left, Right, Top, and Bottom to zero
		[helpstring("method SetEmpty"), helpcontext(IDH_IRect2d_SetEmpty)]
      HRESULT SetEmpty();

      /// Sets Left, Right, Top, and Bottom to zero
      [helpstring("method SetNull"), helpcontext(IDH_IRect2d_SetNull)]
      HRESULT SetNull();

      /// Determines if a point is contained within this rectangle.
      /// Points that touch the top or right edges are not contained within this rectangle
		[helpstring("method ContainsPoint"), helpcontext(IDH_IRect2d_ContainsPoint)]
      HRESULT ContainsPoint(
         [in] IPoint2d* pPoint, ///< point to be tested for containment
         [out,retval] VARIANT_BOOL* pbResult ///< VARIANT_TRUE if the point is contained in this rectangle, otherwise VARIANT_FALSE
      );

      /// Determines if a rectangle is contained entirely within this rectangle
		[helpstring("method ContainsRect"), helpcontext(IDH_IRect2d_ContainsRect)]
      HRESULT ContainsRect(
         [in] IRect2d* pRect, ///< rectangle to test for containment
         [out,retval] VARIANT_BOOL* pbResult ///< VARIANT_TRUE if the rectangle is contained entirely within this rectangle, otherwise VARIANT_FALSE
      );

      /// Determines if any part of a rectangle touches this rectangle
		[helpstring("method Touches"), helpcontext(IDH_IRect2d_Touches)]
      HRESULT Touches(
         [in] IRect2d* pRect, ///< rectangle to test
         [out,retval] VARIANT_BOOL* pbResult ///< VARIANT_TRUE if the rectangle touches this rectangle, otherwise VARIANT_FALSE
      );

      /// Returns VARIANT_TRUE if this is a null rectangle
		[helpstring("method IsNull"), helpcontext(IDH_IRect2d_IsNull)]
      HRESULT IsNull([out,retval] VARIANT_BOOL* pbResult);

      /// Returns VARIANT_TRUE if this rectangle is normalized
      [helpstring("method IsNormalized"), helpcontext(IDH_IRect2d_IsNormalized)]
      HRESULT IsNormalized([out,retval] VARIANT_BOOL* pbResult);

      /// Creates a clone of this object
      [helpstring("method Clone")/*,helpcontext(IDH_IRect2d_Clone)*/]
      HRESULT Clone([out,retval]IRect2d** clone);

      /// Set the bounds of a rectangle
		[helpstring("method SetBounds"),/* helpcontext(IDH_IRect2d_SetBounds)*/]
      HRESULT SetBounds(
         [in] Float64 Left,  ///< left edge
         [in] Float64 Right,  ///< right edge
         [in] Float64 Bottom,  ///< bottom edge
         [in] Float64 Top ///< top edge
      );

      /// Retreives the bounds of the rectangle
		[helpstring("method GetBounds"),/* helpcontext(IDH_IRect2d_GetBounds)*/]
      HRESULT GetBounds(
         [out] Float64* pLeft,  ///< left edge
         [out] Float64* pRight,  ///< right edge
         [out] Float64* pBottom,  ///< bottom edge
         [out] Float64* pTop ///< top edge
      );
   };

   /// Represents a vector in a two dimensional cartesian coordinate system. 
   ///
   /// A vector is a quantity that has magnitude and direction. The default vector is {1,0}.
   /// \image html Vector2d/Vector.jpg
	[
		object,
		uuid(55B8EF9A-FADF-11D2-8CDF-9849C70CC734),
		oleautomation,
		helpcontext(IDH_IVector2d),
		helpstring("IVector2d Interface"),
		pointer_default(unique)
	]
	interface IVector2d : IUnknown
	{
      /// The horizontal component of the vector
		[propget, helpstring("property X"), helpcontext(IDH_IVector2d_X)]
		HRESULT X([out, retval] Float64 *pVal);

		[propput, helpstring("property X"), helpcontext(IDH_IVector2d_X)]
		HRESULT X([in] Float64 newVal);

      /// The vertical component of the vector
		[propget, helpstring("property Y"), helpcontext(IDH_IVector2d_Y)]
		HRESULT Y([out, retval] Float64 *pVal);

		[propput, helpstring("property Y"), helpcontext(IDH_IVector2d_Y)]
		HRESULT Y([in] Float64 newVal);

      /// Direction of the vector. This is an angle, in radians, measured from the positive X axis in a counter-clockwise direction.
		[propget, helpstring("property Direction"), helpcontext(IDH_IVector2d_Direction)]
		HRESULT Direction([out, retval] Float64 *pVal);

		[propput, helpstring("property Direction"), helpcontext(IDH_IVector2d_Direction)]
		HRESULT Direction([in] Float64 newVal);

      /// Magnitude of the vector. Magnitude must be a positive number.
		[propget, helpstring("property Magnitude"), helpcontext(IDH_IVector2d_Magnitude)]
		HRESULT Magnitude([out, retval] Float64 *pVal);

		[propput, helpstring("property Magnitude"), helpcontext(IDH_IVector2d_Magnitude)]
		HRESULT Magnitude([in] Float64 newVal);

      /// Dimensions of the vector as a Size2d object
		[propget, helpstring("property Size"),helpcontext(IDH_IVector2d_Size)]
		HRESULT Size([out, retval] ISize2d* *pVal);

      /// Returns VARIANT_TRUE if the vector has a magnitude of zero, otherwise VARIANT_FALSE
		[helpstring("method IsZero"), helpcontext(IDH_IVector2d_IsZero)]
		HRESULT IsZero([out,retval] VARIANT_BOOL* pbResult);

      /// Creates a vector that is normal to this vector. The direction of the normal vector is to the left of this vector.
      /// \image html Vector2d/Normal.jpg
		[helpstring("method Normal"), helpcontext(IDH_IVector2d_Normal)]
		HRESULT Normal([out,retval] IVector2d** ppNormal);

      /// Normalizes the vector. 
      /// 
      /// A normalized vector has a magnitude of 1.0. A vector is normalized by dividing its X and Y components by the magnitude of the vector. An error will occur if the vector has a magnitude of zero.
      /// Returns S_OK if successful or GEOMETRY_E_ZEROMAGNITUDE if the magnitude of the vector is zero
		[helpstring("method Normalize"), helpcontext(IDH_IVector2d_Normalize)]
		HRESULT Normalize();

      /// Offsets the vector by incrementing the X and Y components with dx and dy
      /// \image html Vector2d/Offset.jpg
		[helpstring("method Offset"), helpcontext(IDH_IVector2d_Offset)]
		HRESULT Offset(
         [in] Float64 dx, ///< horizontal offset
         [in] Float64 dy  ///< vertical offset
      );

      /// Offsets the vector by incrementing the X and Y components with pSize->dx and pSize->dy
      /// \image html Vector2d/Offset.jpg
      [helpstring("method OffsetEx"), helpcontext(IDH_IVector2d_OffsetEx)]
		HRESULT OffsetEx(
         [in] ISize2d* pSize ///< Offset size
      );

      /// Computes the projection of this vector onto another vector.
      ///
      /// In the figure below, the magnitude of the red vector is equal the project of the black vector (this vector) onto the green vector.
      /// \image html Vector2d/Projection.jpg
		[helpstring("method Projection"), helpcontext(IDH_IVector2d_Projection)]
		HRESULT Projection(
         [in] IVector2d* pVector, ///< The vector this vector projects onto
         [out,retval] Float64* pVal ///< This projection of this vector onto pVector
      );

      /// Reflects this vector by multiplying X and Y by -1.
      /// \image html Vector2d/Reflect.jpg
		[helpstring("method Reflect"), helpcontext(IDH_IVector2d_Reflect)]
		HRESULT Reflect();

      /// Rotates the vector. 
      ///
      /// The direction of the vector is changed by incrementing the direction.
      /// \image html Vector2d/Rotate.jpg
		[helpstring("method Rotate"), helpcontext(IDH_IVector2d_Rotate)]
		HRESULT Rotate(
         [in] Float64 angle ///< Rotation angle, measured in radians with counter-clockwise as positive.
      );

      /// Changes the vectors magnitude by multiplying it by a scaling factor.
      /// \image html Vector2d/Scale.jpg
		[helpstring("method Scale"), helpcontext(IDH_IVector2d_Scale)]
		HRESULT Scale(
         [in] Float64 factor ///< scaling factor. Values greater than 1.0 increase magnitude
      );

      /// Computes the dot product. 
      ///
      /// The dot product is computed as \f$dot = x_1 x_2 + y_1 y_2\f$
		[helpstring("method Dot"), helpcontext(IDH_IVector2d_Dot)]
		HRESULT Dot(
         [in] IVector2d* v, ///< a vector
         [out,retval]Float64* val ///< the dot product
      );

      /// Computes the angle between two vectors. 
      ///
      /// The angle between the vectors is computed as \f$ \alpha = \cos{^{-1}} \left(\frac{x_1 x_2 + y_1 y_2}{\mid \overrightarrow{V_1} \mid \mid \overrightarrow{V_2} \mid}\right) \f$.
      /// \image html Vector2d/AngleBetween.jpg
		[helpstring("method AngleBetween"), helpcontext(IDH_IVector2d_AngleBetween)]
		HRESULT AngleBetween([in] IVector2d* v,[out,retval]Float64* val);

      /// Creates a new vector by adding the dimensions v with this vector
		[helpstring("method IncrementBy"), helpcontext(IDH_IVector2d_IncrementBy)]
		HRESULT IncrementBy(
         [in] IVector2d* v, ///< the vector whose dimenions are used to increment the dimensions of this vector
         [out,retval]IVector2d** val ///< The resulting vector
      );

      /// Increments the dimensions of this vector by adding the dimensions of v
		[helpstring("method Increment"), helpcontext(IDH_IVector2d_Increment)]
		HRESULT Increment(
         [in] IVector2d* v ///< the vector whose dimenions are used to increment the dimensions of this vector
      );

      /// Creates a new vector by subtracting the dimensions v from this vector
      [helpstring("method DecrementBy"), helpcontext(IDH_IVector2d_DecrementBy)]
		HRESULT DecrementBy(
         [in] IVector2d* v, ///< the vector whose dimenions are used to decrement the dimensions of this vector
         [out,retval]IVector2d** val ///< The resulting vector
      );

      /// Decrements the dimensions of this vector by subtracting the dimensions of v
      [helpstring("method Decrement"), helpcontext(IDH_IVector2d_Decrement)]
		HRESULT Decrement(
         [in] IVector2d* v ///< the vector whose dimenions are used to decrement the dimensions of this vector
      );

      /// Creates a clone of this object
      [helpstring("method Clone")/*, helpcontext(IDH_IVector2d_Clone)*/]
		HRESULT Clone([out,retval] IVector2d** ppClone);
   };
	
   /// Enumerates a collection of Point2d objects
	[
	   object,
	   uuid(2DB720E8-B7F8-11d3-8A0B-006097C68A9C),
	   helpstring("IEnumPoint2d Interface"),
	   helpcontext(IDH_IEnumPoint2d),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumPoint2d : IUnknown
	{
      /// Creates a clone of this object
      [helpstring("Clone"),helpcontext(IDH_IEnumPoint2d_Clone)]
	   HRESULT Clone([out] IEnumPoint2d** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
	   [helpstring("Next"),helpcontext(IDH_IEnumPoint2d_Next)]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IPoint2d** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
	   [helpstring("Reset"),helpcontext(IDH_IEnumPoint2d_Reset)]
	   HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
	   [helpstring("Skip"),helpcontext(IDH_IEnumPoint2d_Skip)]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for defining a collection of objects that implement the IPoint2d interface
   [
       object,
       uuid(B0D56FA3-C8D6-11d2-8CDF-C55C1CA84A34),
       oleautomation,
       helpstring("IPoint2dCollection Interface"),
	   helpcontext(IDH_IPoint2dCollection),
       pointer_default(unique)
   ]
   interface IPoint2dCollection : IUnknown
   {
      /// Number of items in the collection
      [propget, helpstring("property Count"), helpcontext(IDH_IPoint2dCollection_Count)]
      HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Returns a point from the collection
      [propget, helpstring("Given an index, returns an item in the collection."),helpcontext(IDH_IPoint2dCollection_Item)]
      HRESULT Item(
         [in] CollectionIndexType index, ///< index of the point to be retreived 
         [out, retval] IPoint2d** pPoint ///< an object implementing the IPoint2d interface
      );

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")]
      HRESULT _NewEnum([out, retval] IUnknown** retval);  
       
      /// Adds a reference to a Point2d object to the collection.
      [helpstring("method Add"),helpcontext(IDH_IPoint2dCollection_Add)]
	  HRESULT Add([in] IPoint2d* pPoint);

     /// Removes a point from the collection. 
     ///
     /// All points beyond the specified index are moved up one position
      [helpstring("method Remove"),helpcontext(IDH_IPoint2dCollection_Remove)]
	  HRESULT Remove(
        [in] CollectionIndexType Index ///< index of the point to be removed
     );

     /// Removes all items from the collection.
	  [helpstring("method Clear"),helpcontext(IDH_IPoint2dCollection_Clear)]
	  HRESULT Clear();

     /// Returns an IEnumPoint2d interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
	  [propget,restricted,helpstring("property _Enum"),helpcontext(IDH_IPoint2dCollection__Enum)]
	  HRESULT _Enum([out,retval] IEnumPoint2d** ppenum);

      /// Reverses the order of the points in the collection
      [helpstring("method Reverse")]
      HRESULT Reverse();

      /// Inserts a point into the collection at the specified index
      [helpstring("method Insert")]
      HRESULT Insert(
         [in]CollectionIndexType index, ///< location to insert the point
         [in]IPoint2d* pPoint ///< the point being inserted
      );

      /// Clones the collection making a copy of all the contained point objects
      [helpstring("method Clone")/*,helpcontext(IDH_IPoint2dCollection_Clone)*/]
      HRESULT Clone([out,retval]IPoint2dCollection** clone);

      /// Offsets the location of all the points in the collection
		[helpstring("method Offset"), helpcontext(IDH_IPoint2d_Offset)]
      HRESULT Offset(
         [in] Float64 dx, ///< Horizontal offset
         [in] Float64 dy ///< Vertical offset
      );

      /// Offsets the location of all the points in the collection
      [helpstring("method OffsetEx"), helpcontext(IDH_IPoint2d_OffsetEx)]
      HRESULT OffsetEx(
         [in] ISize2d* size ///< Size2d object representing the offset dimensions
      );

      /// Removes points that are at the same location from the collection
      [helpstring("method RemoveDuplicatePoints")]
      HRESULT RemoveDuplicatePoints();
   };

   /// Interface defining a line segment in a two dimensional Cartesian coordinate system.
   ///
   /// A line segment is a line with finite length between start and end points
   /// \image html LineSegment2d/LineSegment.jpg
	[
		object,
		uuid(DB32B4E0-FCD6-11D2-8CDF-F5BC1C124434),
		oleautomation,
      helpcontext(IDH_ILineSegment2d),
		helpstring("ILineSegment2d Interface"),
		pointer_default(unique)
	]
	interface ILineSegment2d : IUnknown
	{
      /// The beginning point of the line segment
		[propget, helpstring("property StartPoint"), helpcontext(IDH_ILineSegment2d_StartPoint)]
      HRESULT StartPoint([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property StartPoint"), helpcontext(IDH_ILineSegment2d_StartPoint)]
      HRESULT StartPoint([in] IPoint2d* newVal);

      /// The terminating point of the line segment
		[propget, helpstring("property EndPoint"), helpcontext(IDH_ILineSegment2d_EndPoint)]
      HRESULT EndPoint([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property EndPoint"), helpcontext(IDH_ILineSegment2d_EndPoint)]
      HRESULT EndPoint([in] IPoint2d* newVal);

      /// Length of the line segment
		[propget, helpstring("property Length"), helpcontext(IDH_ILineSegment2d_Length)]
      HRESULT Length([out, retval] Float64 *pVal);

      /// Rotates the line segment.
		[helpstring("method Rotate"), helpcontext(IDH_ILineSegment2d_Rotate)]
      HRESULT Rotate(
         [in] Float64 cx, ///< Horizontal coordinate of the center of rotation
         [in] Float64 cy, ///< Vertical coordinate of the center of rotation
         [in] Float64 angle ///<	Rotation angle, measured in radians from the positive X axis, increasing counter-clockwise
      );

      /// Rotates the line segment.
		[helpstring("method RotateEx"), helpcontext(IDH_ILineSegment2d_RotateEx)]
      HRESULT RotateEx(
         [in] IPoint2d* pCenter, ///< Center of rotation
         [in] Float64 angle ///<	Rotation angle, measured in radians from the positive X axis, increasing counter-clockwise
      );

      /// Offsets the line segment by moving its end points.
		[helpstring("method Offset"), helpcontext(IDH_ILineSegment2d_Offset)]
      HRESULT Offset(
         [in] Float64 dx, ///< Horizontal offset
         [in] Float64 dy ///< Vertical offset
      );

      /// Offsets the line segment by moving its end points.
		[helpstring("method OffsetEx"), helpcontext(IDH_ILineSegment2d_OffsetEx)]
      HRESULT OffsetEx(
         [in] ISize2d* pSize ///< Horizontal and vertical offsets
      );

      /// Offsets the line segment by moving in a direction that is normal to the line by a specified distance
      [helpstring("method Offset2"), helpcontext(IDH_ILineSegment2d_Offset)]
      HRESULT Offset2(
         [in] Float64 distance ///< offset distance. Positive values offset the line towards the right.
      );

      /// Defines the line segment with two end points
		[helpstring("method ThroughPoints")/*, helpcontext(IDH_ILineSegment2d_ThroughPoints)*/]
      HRESULT ThroughPoints(
         [in] IPoint2d* p1, ///< start of line segment
         [in] IPoint2d* p2 ///< end of line segment
      );

      [helpstring("method ContainsPoint")]
      HRESULT ContainsPoint([in]IPoint2d* pPoint, [in]Float64 tolerance, [out]VARIANT_BOOL* pbResult);

      /// Divides the line segment into nSpaces equally divided spaces.  Returns
      /// a vector containing the coordinate of each point.
      /// \image html LineSegment2d/DivideLineSegment.jpg
      [helpstring("method Divide")]
      HRESULT Divide([in]IndexType nSpaces, [out]IPoint2dCollection** ppPoints);

      /// Creates a clone of this object
      [helpstring("method Clone")/*, helpcontext(IDH_ILineSegment2d_Cone)*/]
      HRESULT Clone([out,retval]ILineSegment2d** ppClone);
   };

   /// Interface defining a directed line of infinite length.
   ///
   /// A line is described by its implicit form, its explicit form, or by two points.
   /// The implicit form consists of the shortest distance from the origin to the line and a unit vector normal to the line.
   /// \image html Line2d/Implicit.jpg
   /// The explicit from consists of a point and a unit vector in the direction of the line.
   /// \image html Line2d/Explicit.jpg
   /// The line can also be described as passing through two points.The direction of the line is from the first point, towards the second point.
   /// \image html Line2d/TwoPoints.jpg
   [
		object,
		uuid(54A873E0-FCE2-11D2-8CDF-B23210011634),
		oleautomation,
      helpcontext(IDH_ILine2d),
		helpstring("ILine2d Interface"),
		pointer_default(unique)
	]
	interface ILine2d : IUnknown
	{
      /// Defines the line using its explicit form.
		[helpstring("method SetExplicit"), helpcontext(IDH_ILine2d_SetExplicit)]
      HRESULT SetExplicit(
         [in] IPoint2d *p, ///< a point on the line
         [in] IVector2d* d ///< a vector in the direction of the line
      );

      /// Returns the explicit form of the line.
		[helpstring("method GetExplicit"), helpcontext(IDH_ILine2d_GetExplicit)]
      HRESULT GetExplicit(
         [out] IPoint2d** p, ///< a point on the line
         [out] IVector2d** d ///< a vector in the direction of the line
      );
		
      /// Defines the line using its implicit form.
      [helpstring("method SetImplicit"), helpcontext(IDH_ILine2d_SetImplicit)]
      HRESULT SetImplicit(
         [in] Float64 c, ///< Shortest distance from the origin to the line
         [in] IVector2d* n ///< A normal vector directed toward the left side of the line
      );

      /// Returns the implict form of the line
		[helpstring("method GetImplicit"), helpcontext(IDH_ILine2d_GetImplicit)]
      HRESULT GetImplicit(
         [out] Float64* c, ///< Shortest distance from the origin to the line
         [out] IVector2d** n ///< A normal vector directed toward the left side of the line
      );

      /// Defines the line using two points. Direction is from the first point towards the second point.
		[helpstring("method ThroughPoints"), helpcontext(IDH_ILine2d_ThroughPoints)]
      HRESULT ThroughPoints(
         [in] IPoint2d* p1,  ///< first point
         [in] IPoint2d* p2   ///< second point
      );

      /// Offsets the line. The specified offset is measured normal to the line. Positive values of offset move the line to the left, negative values move the line to the right.
		[helpstring("method Offset"), helpcontext(IDH_ILine2d_Offset)]
      HRESULT Offset(
         [in] Float64 offset ///< distance to offset the line
      );

      /// Rotates the line about a point
		[helpstring("method Rotate"), helpcontext(IDH_ILine2d_Rotate)]
      HRESULT Rotate(
         [in] Float64 cx, ///< X coordinate of the center of rotation
         [in] Float64 cy, ///< Y coordinate of the center of rotation
         [in] Float64 angle ///< Rotation angle, in radians, measured counter-clockwise from the positive X direction.
      );

      /// Rotates the line about a point
      [helpstring("method RotateEx"), helpcontext(IDH_ILine2d_RotateEx)]
      HRESULT RotateEx(
         [in] IPoint2d* pCenter, ///< center of rotation
         [in] Float64 angle ///< Rotation angle, in radians, measured counter-clockwise from the positive X direction.
      );

      /// Reverses the direction of the line
		[helpstring("method Reverse"), helpcontext(IDH_ILine2d_Reverse)]
	  HRESULT Reverse();

     [helpstring("method ContainsPoint")]
     HRESULT ContainsPoint([in]IPoint2d* pPoint, [out]VARIANT_BOOL* pbResult);

     [helpstring("method IsColinear")]
     HRESULT IsColinear([in]ILine2d* pLine, [out]VARIANT_BOOL* pbResult);

     /// Creates a clone of this object
      [helpstring("method Clone")/*, helpcontext(IDH_ILine2d_Clone)*/]
	  HRESULT Clone([out,retval]ILine2d** ppLine);
   };

   /// Represents a point in a three dimensional Cartesian coordinate system.
	[
		object,
		uuid(4F37A660-03FE-11D3-8CDF-882D80988F34),
		oleautomation,
		helpstring("IPoint3d Interface"),
        helpcontext(IDH_IPoint3d),
		pointer_default(unique)
	]
	interface IPoint3d : IUnknown
	{
      /// X ordinate
		[propget, helpstring("property X"),helpcontext(IDH_IPoint3d_X)]
      HRESULT X([out, retval] Float64 *x);

		[propput, helpstring("property X"),helpcontext(IDH_IPoint3d_X)]
      HRESULT X([in] Float64 x);

      /// Y ordinate
      [propget, helpstring("property Y"),helpcontext(IDH_IPoint3d_Y)]
      HRESULT Y([out, retval] Float64 *y);

		[propput, helpstring("property Y"),helpcontext(IDH_IPoint3d_Y)]
      HRESULT Y([in] Float64 y);

      /// Z ordinate
      [propget, helpstring("property Z"),helpcontext(IDH_IPoint3d_Z)]
      HRESULT Z([out, retval] Float64 *z);

		[propput, helpstring("property Z"),helpcontext(IDH_IPoint3d_Z)]
      HRESULT Z([in] Float64 z);

      /// Moves this point to (x,y,z).
		[helpstring("method Move"),helpcontext(IDH_IPoint3d_Move)]
      HRESULT Move([in] Float64 x,[in] Float64 y,[in] Float64 z);

      /// Moves this point to the location of another point
		[helpstring("method MoveEx"),helpcontext(IDH_IPoint3d_MoveEx)]
      HRESULT MoveEx(
         [in] IPoint3d* to // destination point
      );

      /// Offsets this point by the amount (dx,dy,dz).
		[helpstring("method Offset"),helpcontext(IDH_IPoint3d_Offset)]
      HRESULT Offset(
         [in] Float64 dx, ///< offset in the X direction
         [in] Float64 dy, ///< offset in the Y direction
         [in] Float64 dz ///< offset in the Z direction
      );

      /// Offset this point by size
		[helpstring("method OffsetEx"),helpcontext(IDH_IPoint3d_OffsetEx)]
      HRESULT OffsetEx(
         [in] ISize3d* size ///< Size3d object representing displacement
      );

      /// Repositions the point by rotating it about another point.
		[helpstring("method Rotate"), helpcontext(IDH_IPoint3d_Rotate)]
      HRESULT Rotate(
         [in] Float64 cx, ///< Center point X coordinate
         [in] Float64 cy, ///< Center point Y coordinate
         [in] Float64 cz,  ///< Center point Z coordinate
         [in] IVector3d* vector, ///< Rotation vector
         [in] Float64 angle ///< Rotation angle, in radians. Positive rotation follows the right hand rule.
      );

      /// Repositions the point by rotating it about another point.
      [helpstring("method RotateEx"), helpcontext(IDH_IPoint3d_RotateEx)]
      HRESULT RotateEx(
         [in] IPoint3d* center, ///< Center point of rotation
         [in] IVector3d* vector, ///< Rotation vector
         [in] Float64 angle ///< Rotation angle, in radians. Positive rotation follows the right hand rule.
      );

      /// Returns S_OK if pOther is at the same location as this point, otherwise returns S_FALSE
      [helpstring("method SameLocation"),helpcontext(IDH_IPoint3d_SameLocation)]
      HRESULT SameLocation([in]IPoint3d* pOther);

      /// Returns the X, Y, Z coordinates of this point
      [helpstring("method Location"),helpcontext(IDH_IPoint3d_Location)]
      HRESULT Location([out]Float64* pX,[out]Float64* pY,[out]Float64* pZ);

      /// Returns the distance between this point and (x,y,z)
      [helpstring("method Distance")/*,helpcontext(IDH_IPoint3d_Distance)*/]
      HRESULT Distance(
         [in]Float64 x, ///< X coordinate
         [in]Float64 y, ///< Y coordinate
         [in]Float64 z, ///< Z coordinate
         [out,retval]Float64* pDistance ///< The distance between this point and (x,y,z)
      );

      /// Returns the distance between this point and pOther
      [helpstring("method DistanceEx")/*,helpcontext(IDH_IPoint3d_DistanceEx)*/]
      HRESULT DistanceEx(
         [in]IPoint3d* pOther, ///< point used to computer distanced from this point
         [out,retval]Float64* pDistance ///< The distance between this point and pOther
      );

      /// Creates a clone of this object
      [helpstring("method Clone")/*,helpcontext(IDH_IPoint3d_Location)*/]
      HRESULT Clone([out,retval]IPoint3d** ppPoint);
   };

   /// Interface defining a line segment in a 3D Cartesian coordinate system.
   ///
   /// A line segment is a line with finite length between start and end points
   /// \image html LineSegment3d/LineSegment3d.png
   [
		object,
		uuid(0356DD54-DC34-47b2-B324-3C6A20930301),
		oleautomation,
      //helpcontext(IDH_ILineSegment3d),
		helpstring("ILineSegment3d Interface"),
		pointer_default(unique)
	]
	interface ILineSegment3d : IUnknown
	{
      /// The beginning point of the line segment
      [propget, helpstring("property StartPoint")/*, helpcontext(IDH_ILineSegment2d_StartPoint)*/]
      HRESULT StartPoint([out, retval] IPoint3d* *pVal);

		[propputref, helpstring("property StartPoint")/*, helpcontext(IDH_ILineSegment2d_StartPoint)*/]
      HRESULT StartPoint([in] IPoint3d* newVal);

      /// The terminating point of the line segment
      [propget, helpstring("property EndPoint")/*, helpcontext(IDH_ILineSegment2d_EndPoint)*/]
      HRESULT EndPoint([out, retval] IPoint3d* *pVal);

		[propputref, helpstring("property EndPoint")/*, helpcontext(IDH_ILineSegment2d_EndPoint)*/]
      HRESULT EndPoint([in] IPoint3d* newVal);

      /// Length of the line segment
      [propget, helpstring("property Length")/*, helpcontext(IDH_ILineSegment2d_Length)*/]
      HRESULT Length([out, retval] Float64 *pVal);

      /// Defines the line segment with two end points
      [helpstring("method ThroughPoints")/*, helpcontext(IDH_ILine2d_ThroughPoints)*/]
      HRESULT ThroughPoints([in] IPoint3d* p1, [in] IPoint3d* p2);

		//[helpstring("method Rotate"), helpcontext(IDH_ILineSegment2d_Rotate)]
  //    HRESULT Rotate([in] Float64 cx, [in] Float64 cy,[in] Float64 angle);

		//[helpstring("method RotateEx"), helpcontext(IDH_ILineSegment2d_RotateEx)]
  //    HRESULT RotateEx([in] IPoint2d* pCenter,[in] Float64 angle);

  /// Offsets the line segment by moving its end points.
      [helpstring("method Offset")/*, helpcontext(IDH_ILineSegment2d_Offset)*/]
      HRESULT Offset(
         [in] Float64 dx, ///< Offset in the X direction
         [in] Float64 dy, ///< Offset in the Y direction
         [in]Float64 dz ///< Offset in the Z direction
      );

      /// Offsets the line segment by moving its end points.
      [helpstring("method OffsetEx")/*, helpcontext(IDH_ILineSegment2d_OffsetEx)*/]
      HRESULT OffsetEx(
         [in] ISize3d* pSize ///< Size3d object representing offsets
      );

      /// Creates a clone of this object
      [helpstring("method Clone")/*,helpcontext(IDH_ILineSegment2d_Clone)*/]
      HRESULT Clone([out,retval]ILineSegment3d** clone);
   };

   /// Interface defining a size representing the extents of a rectangular prism
   [
		object,
		uuid(75DB33E0-0449-11D3-8CDF-9E53F9A4BF35),
		oleautomation,
		helpstring("ISize3d Interface"),
      helpcontext(IDH_ISize3d),
		pointer_default(unique)
	]
	interface ISize3d : IUnknown
	{
      /// Extent in the X direction
		[propget, helpstring("property Dx"), helpcontext(IDH_ISize3d_Dx)]
      HRESULT Dx([out, retval] Float64 *dx);
		
      [propput, helpstring("property Dx"), helpcontext(IDH_ISize3d_Dx)]
      HRESULT Dx([in] Float64 dx);

      /// Extent in the Y direction
      [propget, helpstring("property Dy"), helpcontext(IDH_ISize3d_Dy)]
      HRESULT Dy([out, retval] Float64 *dy);

		[propput, helpstring("property Dy"), helpcontext(IDH_ISize3d_Dy)]
      HRESULT Dy([in] Float64 dy);

      /// Extent in the Z direction
      [propget, helpstring("property Dz"), helpcontext(IDH_ISize3d_Dz)]
      HRESULT Dz([out, retval] Float64 *dz);

		[propput, helpstring("property Dz"), helpcontext(IDH_ISize3d_Dz)]
      HRESULT Dz([in] Float64 dz);

      /// Length of the diagonal line connecting opposite corners of the rectangular prisim
		[propget, helpstring("property Magnitude"), helpcontext(IDH_ISize3d_Magnitude)]
      HRESULT Magnitude([out,retval] Float64* mag);

      /// Modifies the dimensions by multipying Dx, Dy and Dz by a scaling factor
      /// Scaling factors greater than 1.0 enlarge the dimensions
      [helpstring("method Scale"), helpcontext(IDH_ISize3d_Scale)]
      HRESULT Scale([in] Float64 factor);

      /// Returns the dimensions
      [helpstring("method Dimensions"),helpcontext(IDH_ISize3d_Dimensions)]
      HRESULT Dimensions(
         [out]Float64* pDx, ///< Extent in the X direction
         [out]Float64* pDy, ///< Extent in the Y direction
         [out]Float64* pDz ///< Extent in the Z direction
      );

      /// Creates a clone of this object
      [helpstring("method Clone")/*,helpcontext(IDH_ISize3d_Clone)*/]
      HRESULT Clone([out,retval]ISize3d** clone);
   };

   /// Represents a vector in a three dimensional cartesian coordinate system. 
   ///
   /// A vector is a quantity that has magnitude and direction. The default vector is {1,0,0}.
   /// \image html Vector3d/Vector3d.jpg	
   [
		object,
		uuid(F97D8401-1871-11D3-8CDF-925649DD1F63),
		oleautomation,
		helpstring("IVector3d Interface"),
		helpcontext(IDH_IVector3d),
		pointer_default(unique)
	]
	interface IVector3d : IUnknown
	{
      /// X component of the vector
		[propget, helpstring("property X"),helpcontext(IDH_IVector3d_X)]
		HRESULT X([out, retval] Float64 *pVal);

		[propput, helpstring("property X"),helpcontext(IDH_IVector3d_X)]
		HRESULT X([in] Float64 newVal);

      /// Y component of the vector
      [propget, helpstring("property Y"),helpcontext(IDH_IVector3d_Y)]
		HRESULT Y([out, retval] Float64 *pVal);

		[propput, helpstring("property Y"),helpcontext(IDH_IVector3d_Y)]
		HRESULT Y([in] Float64 newVal);

      /// Z component of the vector
      [propget, helpstring("property Z"),helpcontext(IDH_IVector3d_Z)]
		HRESULT Z([out, retval] Float64 *pVal);

		[propput, helpstring("property Z"),helpcontext(IDH_IVector3d_Z)]
		HRESULT Z([in] Float64 newVal);

      /// Returns VARIANT_TRUE if the vector has a magnitude of zero, otherwise VARIANT_FALSE
      [helpstring("method IsZero"),helpcontext(IDH_IVector3d_IsZero)]
		HRESULT IsZero([out,retval] VARIANT_BOOL* pbResult);

      /// Magnitude of the vector. Magnitude must be a positive number.
      [propget, helpstring("property Magnitude"),helpcontext(IDH_IVector3d_Magnitude)]
		HRESULT Magnitude([out, retval] Float64 *pVal);

		[propput, helpstring("property Magnitude"),helpcontext(IDH_IVector3d_Magnitude)]
		HRESULT Magnitude([in] Float64 newVal);

      /// Normalizes the vector. 
      /// 
      /// A normalized vector has a magnitude of 1.0. A vector is normalized by dividing its X, Y, and Z components by the magnitude of the vector. An error will occur if the vector has a magnitude of zero.
      /// Returns S_OK if successful or GEOMETRY_E_ZEROMAGNITUDE if the magnitude of the vector is zero
      [helpstring("method Normalize"),helpcontext(IDH_IVector3d_Normalize)]
		HRESULT Normalize();

      /// Offsets the vector by incrementing the X, Y and Z components with dx, dy and dz
      [helpstring("method Offset"),helpcontext(IDH_IVector3d_Offset)]
		HRESULT Offset(
         [in] Float64 dx, ///< X direction offset
         [in] Float64 dy, ///< Y direction offset
         [in] Float64 dz ///< Z direction offset
      );

      /// Offsets the vector by incrementing the X, Y and Z components with pSize->dx, pSize->dy and pSize->dz
      [helpstring("method OffsetEx"),helpcontext(IDH_IVector3d_OffsetEx)]
		HRESULT OffsetEx(
         [in] ISize3d* pSize ///< Offset size
      );

      /// Computes the projection of this vector onto another vector.
      ///
      /// In the figure below, the magnitude of the red vector is equal the project of the black vector (this vector) onto the green vector.
      /// \image html Vector3d/Projection.jpg
      [helpstring("method Projection"),helpcontext(IDH_IVector3d_Projection)]
		HRESULT Projection(
         [in] IVector3d* pVector, ///< The vector this vector projects onto
         [out,retval] Float64* pDist ///< This projection of this vector onto pVector
      );

      /// Reflects this vector by multiplying X, Y and Z by -1.
      /// \image html Vector3d/Reflect.jpg
      [helpstring("method Reflect"),helpcontext(IDH_IVector3d_Reflect)]
		HRESULT Reflect();

      /// Changes the vectors magnitude by multiplying it by a scaling factor.
      /// \image html Vector3d/Scale.jpg
      [helpstring("method Scale"),helpcontext(IDH_IVector3d_Scale)]
		HRESULT Scale([in] Float64 factor);

      /// Dimensions of the vector as a Size3d object
      [propget, helpstring("property Size"),helpcontext(IDH_IVector3d_Size)]
		HRESULT Size([out, retval] ISize3d* *pVal);

      /// Computes the cross product. 
      ///
      /// The cross product is computed as \f$ \overrightarrow{V_1} \times \overrightarrow{V_2} = (y_1 z_2 - z_1 y_2)\overrightarrow{i} + (z_1 x_2 - x_1 z_2)\overrightarrow{j} + (x_1 y_2 - y_1 x_2)\overrightarrow{k} \f$
		[helpstring("method Cross"),helpcontext(IDH_IVector3d_Cross)]
		HRESULT Cross(
         [in] IVector3d* v, ///< the vector to cross this vecton into
         [out,retval] IVector3d** result ///< The resulting cross product vector
      );

      /// Computes the dot product. 
      ///
      /// The dot product is computed as \f$dot = x_1 x_2 + y_1 y_2 + z_1 z_2\f$
      [helpstring("method Dot"),helpcontext(IDH_IVector3d_Dot)]
		HRESULT Dot(
         [in] IVector3d* v, ///< a vector
         [out,retval]Float64* val ///< the dot product
      );

      /// Computes the angle between two vectors. 
      /// The angle between the vectors is computed as \f$ \alpha = \cos{^{-1}} \left(\frac{x_1 x_2 + y_1 y_2 + z_1 z_2}{\mid\overrightarrow{V_1} \mid \mid \overrightarrow{V_2} \mid}\right) \f$.
      /// \image html Vector3d/AngleBetween.jpg
      [helpstring("method AngleBetween"),helpcontext(IDH_IVector3d_AngleBetween)]
		HRESULT AngleBetween(
         [in] IVector3d* v,
         [out,retval] Float64* angle
      );

      /// Creates a new vector by adding the dimensions v with this vector
      [helpstring("method IncrementBy"), helpcontext(IDH_IVector3d_IncrementBy)]
		HRESULT IncrementBy(
         [in] IVector3d* v, ///< the vector whose dimenions are used to increment the dimensions of this vector
         [out,retval]IVector3d** val ///< The resulting vector
      );

      /// Increments the dimensions of this vector by adding the dimensions of v
      [helpstring("method Increment"), helpcontext(IDH_IVector3d_Increment)]
		HRESULT Increment(
         [in] IVector3d* v ///< the vector whose dimenions are used to increment the dimensions of this vector
      );

      /// Creates a new vector by subtracting the dimensions v from this vector
      [helpstring("method DecrementBy"), helpcontext(IDH_IVector3d_DecrementBy)]
		HRESULT DecrementBy(
         [in] IVector3d* v, ///< the vector whose dimenions are used to decrement the dimensions of this vector
         [out,retval]IVector3d** val ///< The resulting vector
      );

      /// Decrements the dimensions of this vector by subtracting the dimensions of v
      [helpstring("method Decrement"), helpcontext(IDH_IVector3d_Decrement)]
		HRESULT Decrement(
         [in] IVector3d* v ///< the vector whose dimenions are used to decrement the dimensions of this vector
      );

      /// Creates a clone of this object
      [helpstring("method Clone")/*, helpcontext(IDH_IVector3d_Clone)*/]
		HRESULT Clone([out,retval] IVector3d** ppClone);
   };

   /// Represents a plane in three dimension space.
   ///
   /// \image html Plane3d/Plane3d.jpg
	[
		object,
		uuid(F97D8403-1871-11D3-8CDF-925649DD1F63),
		oleautomation,
		helpstring("IPlane3d Interface"),
		helpcontext(IDH_IPlane3d),
		pointer_default(unique)
	]
	interface IPlane3d : IUnknown
	{
      /// Defines a plane that contains specified three points.
      ///
      /// Returns GEOMETRY_E_SAMEPOINTS if p1, p2, or p3 are not unique
		[helpstring("method ThroughPoints"),helpcontext(IDH_IPlane3d_ThroughPoints)]
		HRESULT ThroughPoints(
         [in] IPoint3d* p1, ///< a point on the plane
         [in] IPoint3d* p2, ///< a point on the plane
         [in] IPoint3d* p3 ///< a point on the plane
      );

      /// Defines a plane that contains a line in the XY Plane and a point in space.
      ///
      /// Returns GEOMETRY_E_COLINEAR if pPnt is on pLine
		[helpstring("method ThroughLineEx"),helpcontext(IDH_IPlane3d_ThroughLineEx)]
		HRESULT ThroughLineEx(
         [in] ILine2d* pLine, ///< A line in the XY plane
         [in] IPoint3d* pPnt ///< A point in on the plane
      );

      /// Defines a plane parallel to the XY plane at the specified altitude.
		[helpstring("method ThroughAltitude"),helpcontext(IDH_IPlane3d_ThroughAltitude)]
		HRESULT ThroughAltitude(
         [in] Float64 altitude ///< Altitude of the plane
      );

      /// Computes the X coordinate given Y and Z
      ///
      /// Returns GEOMETRY_E_INFINITESOLUTSIONS if there are an infinite number of points at the specified coordinate.
      /// Returns GEOMETRY_E_NOSOLUTIONS if the specified coordinate is not on the plane.
		[helpstring("method GetX"),helpcontext(IDH_IPlane3d_GetX)]
		HRESULT GetX(
         [in] Float64 y, ///< Y ordinate
         [in] Float64 z,  ///< Z ordinate
         [out, retval] Float64 *pVal ///< Computed X ordinate
      );

      /// Computes the Y coordinate given X and Z
      ///
      /// Returns GEOMETRY_E_INFINITESOLUTSIONS if there are an infinite number of points at the specified coordinate.
      /// Returns GEOMETRY_E_NOSOLUTIONS if the specified coordinate is not on the plane.
      [helpstring("method GetY"),helpcontext(IDH_IPlane3d_GetY)]
		HRESULT GetY(
         [in] Float64 x, ///< X ordinate
         [in] Float64 z, ///< Z ordinate
         [out, retval] Float64 *pVal ///< Computed Y ordinate
      );

      /// Computes the Z coordinate given X and Y
      ///
      /// Returns GEOMETRY_E_INFINITESOLUTSIONS if there are an infinite number of points at the specified coordinate.
      /// Returns GEOMETRY_E_NOSOLUTIONS if the specified coordinate is not on the plane.
      [helpstring("method GetZ"),helpcontext(IDH_IPlane3d_GetZ)]
		HRESULT GetZ(
         [in] Float64 x, ///< X ordinate
         [in] Float64 y, ///< Y ordinate
         [out, retval] Float64 *pVal /// Computed Z ordinate
      );

      /// Compute the point where a LineSegment3d object intersects the plane
      ///
      /// Returns GEOMETRY_E_NOSOLUTIONS if the line segment does not intersect the plane or if it is contained within the plane
		[helpstring("method LineSegmentIntersect")/*,helpcontext(IDH_IPlane3d_LineSegmentIntersect)*/]
		HRESULT LineSegmentIntersect(
         [in] ILineSegment3d* pLineSegment, ///< A LineSegment3d object to intersect with the plane
         [out,retval]IPoint3d** ppPoint ///< The intersection point
      );

      /// Computes the shortest distance between a point and the plane
		[helpstring("method ShortestDistance")/*,helpcontext(IDH_IPlane3d_ShortestDistance)*/]
      HRESULT SortestDistance(
         [in]IPoint3d* point, ///< A point
         [out,retval]Float64* pDistance ///< Distance between the point and the plane
      );

      /// Returns the point on the plane that is nearest the specified point
		[helpstring("method PointOnPlaneNearestOrigin")/*,helpcontext(IDH_IPlane3d_PointOnPlaneNearestOrigin)*/]
      HRESULT PointOnPlaneNearestOrigin(
         [in]IPoint3d* pPoint, ///< The point to project onto the plane
         [out,retval]IPoint3d** ppPoint ///< Point on the plane nearest the origin
      );

      /// Creates a clone of this object
      [helpstring("method Clone"),helpcontext(IDH_IPlane3d_Clone)]
		HRESULT Clone([out,retval]IPlane3d** clone);
   };

   /// Enumerates a collection of Point2d objects
   [
	   object,
	   uuid(2DB720E9-B7F8-11d3-8A0B-006097C68A9C),
	   helpstring("IEnumPoint3d Interface"),
	   helpcontext(IDH_IEnumPoint3d),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumPoint3d : IUnknown
	{
      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next"),helpcontext(IDH_IEnumPoint3d_Next)]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IPoint3d** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in, out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip"),helpcontext(IDH_IEnumPoint3d_Skip)]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset"),helpcontext(IDH_IEnumPoint3d_Reset)]
	   HRESULT Reset();

      /// Creates a clone of this object
      [helpstring("Clone"),helpcontext(IDH_IEnumPoint3d_Clone)]
       HRESULT Clone([out] IEnumPoint3d** ppenum);
	};

   /// Interface for defining a collection of objects that implement the IPoint3d interface
   [
		object,
		uuid(818E5100-1942-11D3-8CDF-DCD8D8F12565),
		oleautomation,
		helpstring("IPoint3dCollection Interface"),
		helpcontext(IDH_IPoint3dCollection),
		pointer_default(unique)
	]
	interface IPoint3dCollection : IUnknown
	{
      /// Number of items in the collection
      [propget, helpstring("property Count"),helpcontext(IDH_IPoint3dCollection_Count)]
		HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a reference to a Point3d object to the collection.
      [helpstring("method Add"),helpcontext(IDH_IPoint3dCollection_Add)]
		HRESULT Add([in] IPoint3d* pPoint);

      /// Removes a point from the collection. All points beyond the specified index are moved up one position
      [helpstring("method Remove"),helpcontext(IDH_IPoint3dCollection_Remove)]
      HRESULT Remove(
         [in] CollectionIndexType Index ///< index of the point to be removed
      );

      /// Removes all items from the collection.
      [helpstring("method Clear"),helpcontext(IDH_IPoint3dCollection_Clear)]
	    HRESULT Clear();

       /// Returns an IEnumPoint3d interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
       [propget,restricted,helpstring("property _Enum"),helpcontext(IDH_IPoint3dCollection__Enum)]
	     HRESULT _Enum([out,retval] IEnumPoint3d** ppenum);

        /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
        [propget, helpstring("property _NewEnum")]
		HRESULT _NewEnum([out, retval] LPUNKNOWN *pVal);

      /// Returns a point from the collection
      [propget, helpstring("property Item"),helpcontext(IDH_IPoint3dCollection_Item)]
		HRESULT Item(
         [in] CollectionIndexType index, ///< index of the point to be retreived 
         [out, retval] IPoint3d** pPoint ///< an object implementing the IPoint3d interface
      );

      /// Reverses the order of the points in the collection
      [helpstring("method Reverse")]
      HRESULT Reverse();

      /// Inserts a point into the collection at the specified index
      [helpstring("method Insert")]
      HRESULT Insert(
         [in]CollectionIndexType index, ///< location to insert the point
         [in]IPoint3d* pPoint ///< the point being inserted
      );

      /// Creates a clone of this object
      [helpstring("method Clone")/*,helpcontext(IDH_IPoint3dCollection_Clone)*/]
      HRESULT Clone([out,retval]IPoint3dCollection** clone);

      /// Offsets the location of all the points in the collection
      [helpstring("method Offset"), helpcontext(IDH_IPoint2d_Offset)]
      HRESULT Offset(
         [in] Float64 dx, ///< Offset in the X direction
         [in] Float64 dy, ///< Offset in the Y direction
         [in] Float64 dz ///< Offset in the Z direction
      );

      /// Offsets the location of all the points in the collection
      [helpstring("method OffsetEx"), helpcontext(IDH_IPoint2d_OffsetEx)]
      HRESULT OffsetEx(
         [in] ISize3d* size ///< Size3d object representing the offset dimensions
      );

      /// Removes points that are at the same location from the collection
      [helpstring("method RemoveDuplicatePoints")]
      HRESULT RemoveDuplicatePoints();
   };


   /// Interface for defining geometric properties of a shape
   [
		object,
		uuid(66172CA4-FF5A-11D2-8CDF-F43C3928A334),
		oleautomation,
		helpstring("IShapeProperties Interface"),
		helpcontext(IDH_IShapeProperties),
		pointer_default(unique)
	]
	interface IShapeProperties : IUnknown
	{
      /// Area of a closed shape
		[propget, helpstring("property Area"),helpcontext(IDH_IShapeProperties_Area)]
		HRESULT Area([out, retval] Float64 *pVal);

		[propput, helpstring("property Area"),helpcontext(IDH_IShapeProperties_Area)]
		HRESULT Area([in] Float64 newVal);

      /// Location of the geometric centroid
		[propget, helpstring("property Centroid"),helpcontext(IDH_IShapeProperties_Centroid)]
		HRESULT Centroid([out, retval] IPoint2d* *pVal);

		[propput, helpstring("property Centroid"),helpcontext(IDH_IShapeProperties_Centroid)]
		HRESULT Centroid([in] IPoint2d* newVal);

      /// Maximum moment of inertia
		[propget, helpstring("property I11"),helpcontext(IDH_IShapeProperties_I11)]
		HRESULT I11([out, retval] Float64 *pVal);

      /// Minimum moment of inertia
      [propget, helpstring("property I22"),helpcontext(IDH_IShapeProperties_I22)]
		HRESULT I22([out, retval] Float64 *pVal);

      /// Maximum product of inertia
      [propget, helpstring("property I12Max"),helpcontext(IDH_IShapeProperties_I12Max)]
		HRESULT I12Max([out, retval] Float64 *pVal);

      /// Minimum product of inertia
      [propget, helpstring("property I12Min"),helpcontext(IDH_IShapeProperties_I12Min)]
		HRESULT I12Min([out, retval] Float64 *pVal);

      /// Moment of inertia about the X axis defined by the CoordinateSystem property
      [propget, helpstring("property Ixx"),helpcontext(IDH_IShapeProperties_Ixx)]
		HRESULT Ixx([out, retval] Float64 *pVal);

		[propput, helpstring("property Ixx"),helpcontext(IDH_IShapeProperties_Ixx)]
		HRESULT Ixx([in] Float64 newVal);

      /// Moment of inertia about the Y axis defined by the CoordinateSystem property
      [propget, helpstring("property Iyy"),helpcontext(IDH_IShapeProperties_Iyy)]
		HRESULT Iyy([out, retval] Float64 *pVal);

		[propput, helpstring("property Iyy"),helpcontext(IDH_IShapeProperties_Iyy)]
		HRESULT Iyy([in] Float64 newVal);

      /// Product of inertia about the axes defined by the CoordinateSystem property
      [propget, helpstring("property Ixy"),helpcontext(IDH_IShapeProperties_Ixy)]
		HRESULT Ixy([out, retval] Float64 *pVal);

		[propput, helpstring("property Ixy"),helpcontext(IDH_IShapeProperties_Ixy)]
		HRESULT Ixy([in] Float64 newVal);

      /// Distance from the centroid to the left-most point of the shape
      ///
      /// \image html ShapeProperties/Xleft.jpg
		[propget, helpstring("property Xleft"),helpcontext(IDH_IShapeProperties_Xleft)]
		HRESULT Xleft([out, retval] Float64 *pVal);

		[propput, helpstring("property Xleft"),helpcontext(IDH_IShapeProperties_Xleft)]
		HRESULT Xleft([in] Float64 newVal);

      /// Distance from the centroid to the right-most point of the shape
      ///
      /// \image html ShapeProperties/Xleft.jpg
      [propget, helpstring("property Xright"),helpcontext(IDH_IShapeProperties_Xright)]
		HRESULT Xright([out, retval] Float64 *pVal);

		[propput, helpstring("property Xright"),helpcontext(IDH_IShapeProperties_Xright)]
		HRESULT Xright([in] Float64 newVal);

      /// Distance from the centroid to the top-most point of the shape
      ///
      /// \image html ShapeProperties/Xleft.jpg
      [propget, helpstring("property Ytop"),helpcontext(IDH_IShapeProperties_Ytop)]
		HRESULT Ytop([out, retval] Float64 *pVal);

		[propput, helpstring("property Ytop"),helpcontext(IDH_IShapeProperties_Ytop)]
		HRESULT Ytop([in] Float64 newVal);

      /// Distance from the centroid to the bottom-most point of the shape
      ///
      /// \image html ShapeProperties/Xleft.jpg
      [propget, helpstring("property Ybottom"),helpcontext(IDH_IShapeProperties_Ybottom)]
		HRESULT Ybottom([out, retval] Float64 *pVal);

		[propput, helpstring("property Ybottom"),helpcontext(IDH_IShapeProperties_Ybottom)]
		HRESULT Ybottom([in] Float64 newVal);

      /// Location of the origin of the coordinate system.
      ///
      /// Setting this property changes the CoordinateSystem property to csUser.
		[propget, helpstring("property Origin"),helpcontext(IDH_IShapeProperties_Origin)]
		HRESULT Origin([out, retval] IPoint2d* *pVal);

		[propput, helpstring("property Origin"),helpcontext(IDH_IShapeProperties_Origin)]
		HRESULT Origin([in] IPoint2d* newVal);

      /// Orientation of the coordinate system. 
      ///
      /// The orientation angle is measured in radians, counter-clockwise from the positive X axis.
      /// Setting this property changes the CoordinateSystem property to csUser.
		[propget, helpstring("property Orientation"),helpcontext(IDH_IShapeProperties_Orientation)]
		HRESULT Orientation([out, retval] Float64 *pVal);

		[propput, helpstring("property Orientation"),helpcontext(IDH_IShapeProperties_Orientation)]
		HRESULT Orientation([in] Float64 newVal);

      /// Coordinate system in which section properties are measured.
      ///
      /// Setting this properti causes the section properties to be transformed to the specified coordinate system.
      /// For example, if section properties are currently in the centroidal coordinate system and the coordinate system is changed to principle, 
      // the origin, orientation, and section properties will all be transformed to the principle direction coordinate system.
		[propget, helpstring("property CoordinateSystem"),helpcontext(IDH_IShapeProperties_CoordinateSystem)]
		HRESULT CoordinateSystem([out, retval] CoordinateSystemType *pVal);

		[propput, helpstring("property CoordinateSystem"),helpcontext(IDH_IShapeProperties_CoordinateSystem)]
		HRESULT CoordinateSystem([in] CoordinateSystemType newVal);

      /// Orientation of the principle coordinate system. 
      ///
      /// The orientation is measured in radians, counter-clockwise from the positive X-axis of the current coordinate system.
		[propget, helpstring("property PrincipleDirection"),helpcontext(IDH_IShapeProperties_PrincipleDirection)]
		HRESULT PrincipleDirection([out, retval] Float64 *pVal);

      /// Add the properties of this ShapeProperties object with those of another ShapeProperties object. The properties of this object are updated.
	   [helpstring("method AddProperties"),helpcontext(IDH_IShapePropertiesEx_AddProperties)]
	   HRESULT AddProperties([in] IShapeProperties* props);
	};

   /// The IShape interface provides properties and methods that are applicable to all shape objects.
	[
		object,
		uuid(8A8FF0A0-0002-11d3-8CDF-F43C3928A334),
		oleautomation,
		helpstring("IShape Interface"),
		helpcontext(IDH_IShape),
		pointer_default(unique)
	]
	interface IShape : IUnknown
	{
      /// Creates a ShapeProperties object for this shape
		[propget, helpstring("property ShapeProperties"),helpcontext(IDH_IShape_ShapeProperties)]
		HRESULT ShapeProperties([out, retval] IShapeProperties* *pVal);

      /// Returns the bounding box for a shape. Every shape can be entirely contained within a rectangle. This rectangle is called the bounding box.
		[propget, helpstring("property BoundingBox"),helpcontext(IDH_IShape_BoundingBox)]
		HRESULT BoundingBox([out, retval] IRect2d* *pVal);

      /// Creates a collection of points that is a polygon representation of the shape.
		[propget, helpstring("method PolyPoints"),helpcontext(IDH_IShape_PolyPoints)]
		HRESULT PolyPoints([out,retval] IPoint2dCollection** ppPolyPoints);

      /// Tests a point to determine if it is within the boundary of this shape. Points that are on the boundary of the shape are not within the shape.
		[helpstring("method PointInShape"),helpcontext(IDH_IShape_PointInShape)]
		HRESULT PointInShape([in] IPoint2d* pPoint,[out,retval] VARIANT_BOOL* pbResult);

      /// Creates a clone of this shape
		[helpstring("method Clone"),helpcontext(IDH_IShape_Clone)]
		HRESULT Clone([out,retval] IShape** pClone);

      /// Creates a new shape by removing all portions of this shape that are on the left side of a specified line.
      /// \image html IShape/ClipWithLine.jpg
		[helpstring("method ClipWithLine"),helpcontext(IDH_IShape_ClipWithLine)]
		HRESULT ClipWithLine([in] ILine2d* pLine,[out,retval] IShape** pShape);

      /// Creates a new shape by removing all portions of this shape that are outside of the bounds of a specified rectangle
      /// \image html IShape/ClipIn.jpg
      [helpstring("method ClipIn"),helpcontext(IDH_IShape_ClipIn)]
		HRESULT ClipIn([in] IRect2d* pRect,[out,retval] IShape** pShape);

      /// Returns the perimeter of the shape
		[propget, helpstring("property Perimeter"),helpcontext(IDH_IShape_Perimeter)]
		HRESULT	Perimeter([out, retval] Float64 *pVal);

      /// Returns the distance to the furthest point on the right hand side of a specified line
		[helpstring("method FurthestDistance"),helpcontext(IDH_IShape_FurthestDistance)]
		HRESULT	FurthestDistance([in]ILine2d* line,[out, retval] Float64 *pVal);

      /// Returns the point on the shape to the furthest point on the right hand side of a specified line
      [helpstring("method FurthestPoint")/*, helpcontext(IDH_IShape_FurthestDistance)*/]
      HRESULT FurthestPoint([in]ILine2d* line, [out] IPoint2d** ppPoint,[out]Float64* dist);
   };

   /// Enumerates a collection of Shape objects
   [
	   object,
	   uuid(2A9E6E20-B982-11d4-8B56-006097C68A9C),
	   helpstring("IEnumShape Interface"),
	   helpcontext(IDH_IEnumShape),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumShape : IUnknown
	{
      /// Creates a clone of this object
      [helpstring("Clone"),helpcontext(IDH_IEnumShape_Clone)]
	   HRESULT Clone([out] IEnumShape** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next"), helpcontext(IDH_IEnumShape_Next)]
      HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IShape** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in, out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset"),helpcontext(IDH_IEnumShape_Reset)]
	   HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip"),helpcontext(IDH_IEnumShape_Skip)]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// The IXYPosition interface provides properties and methods for manipulating the position of a shape in the XY plane.
	[
		object,
		uuid(C2EBFAA0-0013-11d3-8CDF-8BF0A4AD5B35),
		oleautomation,
		helpstring("IXYPosition Interface"),
	    helpcontext(IDH_IXYPosition),
		pointer_default(unique)
	]
	interface IXYPosition : IUnknown
	{
      /// Offsets an object from its current location by the amount dx,dy.
		[helpstring("method Offset"),helpcontext(IDH_IXYPosition_Offset)]
		HRESULT Offset(
         [in] Float64 dx, ///< Offset in the X direction
         [in] Float64 dy ///< Offset in the Y direction
      );

      /// Offsets an object from its current location.
		[helpstring("method OffsetEx"),helpcontext(IDH_IXYPosition_OffsetEx)]
		HRESULT OffsetEx(
         [in] ISize2d* pSize ///< Size2d object representing an offset
      );

      /// Location of a locator point
		[propget, helpstring("property LocatorPoint"),helpcontext(IDH_IXYPosition_LocatorPoint)]
		HRESULT LocatorPoint(
         [in] LocatorPointType lp,  ///< Locator point type
         [out,retval] IPoint2d** point ///< The locator point
      );

      [propput, helpstring("property LocatorPoint"),helpcontext(IDH_IXYPosition_LocatorPoint)]
		HRESULT LocatorPoint([in] LocatorPointType lp, [in] IPoint2d* point);

      /// Moves the object by moving an arbitrary point from one location to another.
      ///
      /// This method is similar to Offset and OffsetEx. pFrom and pTo do not need to be on or within the objet
		[helpstring("method MoveEx"),helpcontext(IDH_IXYPosition_MoveEx)]
		HRESULT MoveEx(
         [in] IPoint2d* pFrom, ///< start location of the move
         [in] IPoint2d* pTo ///< end location of the move
      );

      /// Rotates an object around a specified center point.
		[helpstring("method Rotate"),helpcontext(IDH_IXYPosition_Rotate)]
		HRESULT Rotate(
         [in] Float64 cx, ///< X coordinate of the center of rotation
         [in] Float64 cy, ///< Y coordinate of the center of rotation
         [in] Float64 angle ///< Rotation angle, in radians, measured counter - clockwise from the positive X direction.
      );

      /// Rotates an object around a specified center point.
      [helpstring("method RotateEx"), helpcontext(IDH_IXYPosition_RotateEx)]
      HRESULT RotateEx(
         [in] IPoint2d* pCenter, ///< Center of rotation
         [in] Float64 angle ///< Rotation angle, in radians, measured counter - clockwise from the positive X direction.
      );
   };

   /// Interface defining a generic shape.
   ///
   /// A generic shape is defined only by its properties. It does not represent an actual geometric entity.
   /// The properties of a generic shape are similar to the properties of the ShapeProperties object but differs
   /// in that a generic shape can be used like more concrete shape types
	[
		object,
		uuid(06762F74-9BD3-4f96-B2F4-946D64F9C37D),
		oleautomation,
		helpstring("IGenericShape Interface"),
		helpcontext(IDH_IGenericShape),
		pointer_default(unique)
	]
	interface IGenericShape : IUnknown
	{
      /// Area of the shape
      [propget, helpstring("property Area"),helpcontext(IDH_IGenericShape_Area)]
		HRESULT Area([out, retval] Float64 *pVal);

		[propput, helpstring("property Area"),helpcontext(IDH_IGenericShape_Area)]
		HRESULT Area([in] Float64 newVal);

      /// Perimeter of the shape
      [propput, helpstring("property Perimeter"), helpcontext(IDH_IGenericShape_Perimeter)]
      HRESULT Perimeter([in] Float64 newVal);

      /// Location of the geometric centroid
      [propget, helpstring("property Centroid"),helpcontext(IDH_IGenericShape_Centroid)]
		HRESULT Centroid([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property Centroid"),helpcontext(IDH_IGenericShape_Centroid)]
		HRESULT Centroid([in] IPoint2d* newVal);

      /// Distance from the centroid to the left-most point of the shape
      ///
      /// \image html ShapeProperties/Xleft.jpg
      [propget, helpstring("property Xleft"),helpcontext(IDH_IShapeProperties_Xleft)]
		HRESULT Xleft([out, retval] Float64 *pVal);

		[propput, helpstring("property Xleft"),helpcontext(IDH_IShapeProperties_Xleft)]
		HRESULT Xleft([in] Float64 newVal);

      /// Distance from the centroid to the right-most point of the shape
      ///
      /// \image html ShapeProperties/Xleft.jpg
      [propget, helpstring("property Xright"),helpcontext(IDH_IShapeProperties_Xright)]
		HRESULT Xright([out, retval] Float64 *pVal);

		[propput, helpstring("property Xright"),helpcontext(IDH_IShapeProperties_Xright)]
		HRESULT Xright([in] Float64 newVal);

      /// Distance from the centroid to the top-most point of the shape
      ///
      /// \image html ShapeProperties/Xleft.jpg
      [propget, helpstring("property Ytop"),helpcontext(IDH_IShapeProperties_Ytop)]
		HRESULT Ytop([out, retval] Float64 *pVal);

		[propput, helpstring("property Ytop"),helpcontext(IDH_IShapeProperties_Ytop)]
		HRESULT Ytop([in] Float64 newVal);

      /// Distance from the centroid to the bottom-most point of the shape
      ///
      /// \image html ShapeProperties/Xleft.jpg
      [propget, helpstring("property Ybottom"),helpcontext(IDH_IShapeProperties_Ybottom)]
		HRESULT Ybottom([out, retval] Float64 *pVal);

		[propput, helpstring("property Ybottom"),helpcontext(IDH_IShapeProperties_Ybottom)]
		HRESULT Ybottom([in] Float64 newVal);

      /// Moment of inertia about the X axis defined by the CoordinateSystem property
      [propget, helpstring("property Ixx"),helpcontext(IDH_IGenericShape_Ixx)]
		HRESULT Ixx([out, retval] Float64 *pVal);

		[propput, helpstring("property Ixx"),helpcontext(IDH_IGenericShape_Ixx)]
		HRESULT Ixx([in] Float64 newVal);

      /// Moment of inertia about the Y axis defined by the CoordinateSystem property
      [propget, helpstring("property Iyy"),helpcontext(IDH_IGenericShape_Iyy)]
		HRESULT Iyy([out, retval] Float64 *pVal);

		[propput, helpstring("property Iyy"),helpcontext(IDH_IGenericShape_Iyy)]
		HRESULT Iyy([in] Float64 newVal);

      /// Product of inertia about the axes defined by the CoordinateSystem property
      [propget, helpstring("property Ixy"),helpcontext(IDH_IGenericShape_Ixy)]
		HRESULT Ixy([out, retval] Float64 *pVal);

		[propput, helpstring("property Ixy"),helpcontext(IDH_IGenericShape_Ixy)]
		HRESULT Ixy([in] Float64 newVal);

      /// The Shape property
		[propget, helpstring("property Shape"),helpcontext(IDH_IGenericShape_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_IGenericShape_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);
	};

   /// Interface of a shape defined by a general polygon.
   ///
   /// \image html PolyShape/PolyShape.jpg
   /// The points of the polygon can be defined clockwise or counter-clockwise. The polygon can be open or closed (the first and last points don't have to be the same).
   /// While it is possible to create degenerate shapes, shapes where edges cross(like a bowtie), shape properties will not be computed correctly for these types of shapes.
   /// Section propertes in global coordinates are computed with the following equations:
   /// \f[ A = \sum{(x_{i+1} - x_i)y_i + \frac{1}{2}(x_{i+1} - x_i)(y_{i+1} - y_i)} \f]
   /// \f[ I_x = \sum{
   ///           \frac{{y_i}^3(x_{i+1} - x_i)}{12} 
   ///           + (x_{i+1}-x_i)y_i {\frac{y_i}{2}}^2 
   ///           + \frac{(y_{i+1} - y_i)^3 (x_{i+1} - x_i)}{36}
   ///           + \frac{1}{2} (x_{i+1} - x_i)(y_{i+1} - y_i) \left[ \frac{(y_{i+1} - y_i)}{3} + y_i \right] ^3 
   ///           } \f]
   /// \f[ I_y = \sum{
   ///           \frac{y_i(x_{i+1} - x_i)^3}{12} 
   ///           + (x_{i+1}-x_i)y_i \left[ x_i + \frac{(x_{i+1} - x_i)}{2} \right]^2 
   ///           + \frac{(y_{i+1} - y_i)(x_{i+1} - x_i)^3 }{36}
   ///           + \frac{1}{2} (x_{i+1} - x_i)(y_{i+1} - y_i) \left[ \frac{2(x_{i+1} - x_i)}{3} + x_i \right] ^3 
   ///           } \f]
   /// \f[ I_{xy} = \sum{
   ///            (x_{i+1} - x_i)\frac{{y_i}^2}{2} \left( x_i + \frac{x_{i+1} - x_i}{2} \right)
   ///            + \frac{1}{2} (x_{i+1} - x_i)(y_{i+1} - y_i) \left( \frac{y_{i+1} - y_i}{3} - y_i  \right) \left[ \frac{2(x_{i+1} - x_i)}{3} + x_i \right]
   ///            + \frac{(x_{i+1} - x_i)^2(y_{i+1} - y_i)^2}{72}
   ///            } \f]
   /// \f[ \overline{x} = \frac{ \sum{ \frac{1}{2}y_i(x_{i+1} - x_i)(x_{i+1} + x_i) + \frac{1}{2}(x_{i+1} - x_i)(y_{i+1} - y_i) \left[ \frac{2}{3}(x_{i+1} + x_i) + x_i \right] } }{A} \f]
   /// \f[ \overline{y} = \frac{ \sum{ \frac{1}{2}{y_i}^2(x_{i+1} - x_i) + \frac{1}{2}(x_{i+1} - x_i)(y_{i+1} - y_i) \left[ \frac{1}{3}(y_{i+1} + y_i) + y_i \right] } }{A} \f]
   [
		object,
		uuid(94FD8E63-0013-11D3-8CDF-8BF0A4AD5B35),
      oleautomation,
		helpstring("IPolyShape Interface"),
		helpcontext(IDH_IPolyShape),
		pointer_default(unique)
	]
	interface IPolyShape : IUnknown
	{
      /// Adds a point to the polygon
		[helpstring("method AddPoint"),helpcontext(IDH_IPolyShape_AddPoint)]
		HRESULT AddPoint(
         [in] Float64 x, ///< X coordinate
         [in] Float64 y  ///< Y coordinate
      );

      /// Adds a Point2d object to the polygon
		[helpstring("method AddPointEx"),helpcontext(IDH_IPolyShape_AddPointEx)]
		HRESULT AddPointEx(
         [in] IPoint2d* pPoint ///< Point to add
      );

      /// Adds a collection of Point2d objects to the polygon
		[helpstring("method AddPoints"),helpcontext(IDH_IPolyShape_AddPoints)]
		HRESULT AddPoints(
         [in] IPoint2dCollection* pPoints ///< the points in the collection are added to the polygon
      );

      /// Sets the points with a collection of Point2d objects to the polygon
      [helpstring("method SetPoints"), helpcontext(IDH_IPolyShape_AddPoints)]
      HRESULT SetPoints(
         [in] IPoint2dCollection* pPoints ///< the points in the collection define the polygon
      );

      /// Removes a point from the polygon
		[helpstring("method RemovePoint"),helpcontext(IDH_IPolyShape_RemovePoint)]
		HRESULT RemovePoint(
         [in] CollectionIndexType index ///< index of the point to be removed
      );

      /// Changes the location of a point
      [helpstring("method ChangePoint"), helpcontext(IDH_IPolyShape_ChangePoint)]
      HRESULT ChangePoint([in] CollectionIndexType index, [in] Float64 x, [in] Float64 y);

      /// Changes the location of a point
      [helpstring("method ChangePointEx"), helpcontext(IDH_IPolyShape_ChangePointEx)]
      HRESULT ChangePointEx([in] CollectionIndexType index, [in] IPoint2d* pPoint);

      /// Returns the number of points in the polygon
      [propget, helpstring("property Count"), helpcontext(IDH_IPolyShape_Count)]
      HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Hook point is the first point in the shape
      [propget, helpstring("property HookPoint")]
      HRESULT HookPoint([out, retval] IPoint2d** hookPnt);

      [propputref, helpstring("property HookPoint")]
      HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_IPolyShape_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_IPolyShape_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);


      /// Returns the specified point
		[propget, helpstring("property Point"),helpcontext(IDH_IPolyShape_Point)]
		HRESULT Point(
         [in] CollectionIndexType index,  ///< index of the point to be returned
         [out, retval] IPoint2d* *pVal ///< the point
      );

      /// Gets the location of a point
      [helpstring("property GetPoint"), helpcontext(IDH_IPolyShape_Point)]
      HRESULT GetPoint([in] CollectionIndexType index, [out] Float64* pX, [out] Float64* pY);

      /// Removes all points from the polygon
		[helpstring("method Clear"),helpcontext(IDH_IPolyShape_Clear)]
		HRESULT Clear();

      /// Returns the collection of Point2d objects that make up the polygon
		[propget, helpstring("property Points"),helpcontext(IDH_IPolyShape_Points)]
		HRESULT Points([out,retval]IPoint2dCollection** coll);
   };

   /// Object representing a Circle
   ///
   /// \image html Circle/Circle.jpg
   /// Section properties in centroidal coordinates. 
   /// \f[ A = \pi r^2 \f]
   /// \f[ I_x = I_y =\frac{\pi r^2}{4} \f]
   /// \f[ I_{xy} = 0 \f]
   /// \f[ Perimeter = 2 \pi r \f]
	[
		object,
		uuid(219B8FC1-0154-11D3-8CDF-CCA4ADEF4534),
      oleautomation,
		helpstring("ICircle Interface"),
		helpcontext(IDH_ICircle),
		pointer_default(unique)
	]
	interface ICircle : IUnknown
	{
      /// Radius of the circle
		[propget, helpstring("property Radius"),helpcontext(IDH_ICircle_Radius)]
		HRESULT Radius([out, retval] Float64 *pVal);

		[propput, helpstring("property Radius"),helpcontext(IDH_ICircle_Radius)]
		HRESULT Radius([in] Float64 newVal);

      /// Center of the circle
		[propget, helpstring("property Center"),helpcontext(IDH_ICircle_Center)]
		HRESULT Center([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property Center"),helpcontext(IDH_ICircle_Center)]
		HRESULT Center([in] IPoint2d* newVal);

      /// Defines the circle with two points on the circumference connected by the diameter
      ///
      /// The points cannot be coincident
		[helpstring("method ThroughTwoPoints"),helpcontext(IDH_ICircle_ThroughTwoPoints)] 
		HRESULT ThroughTwoPoints(
         [in] IPoint2d* p1, ///< point on the circumference at one end of the diameter
         [in] IPoint2d* p2 ///< point on the circumference at the other end of the diameter
      );

      /// Defines the circle by fitting it through three points on its circumference
      ///
      /// The points cannot be coincident and the lines connecting the points cannot be colinear.
		[helpstring("method ThroughThreePoints"),helpcontext(IDH_ICircle_ThroughThreePoints)] 
		HRESULT ThroughThreePoints(
         [in] IPoint2d* p1, ///< point on the circumference
         [in] IPoint2d* p2, ///< point on the circumference
         [in] IPoint2d* p3 ///< point on the circumference
      );

      /// Determines if a point is contained within a circle
		[helpstring("method ContainsPoint"),helpcontext(IDH_ICircle_ContainsPoint)] 
		HRESULT ContainsPoint(
         [in]IPoint2d* p, ///< The point being evaluated
         [out,retval] VARIANT_BOOL* pResult ///< returns VARIANT_TRUE if a point is contained within the circle, otherwise VARIANT_FALSE
      );

      /// Determines if a point is on the circumference of a circle
		[helpstring("method PointOnCircle"),helpcontext(IDH_ICircle_PointOnCircle)] 
		HRESULT PointOnCircle(
         [in]IPoint2d* p, ///< The point being evaluated
         [out,retval] VARIANT_BOOL* pResult ///< returns VARIANT_TRUE if a point is on the circumference, otherwise VARIANT_FALSE
      );

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_ICircle_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_ICircle_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing a Rectangle
   ///
   /// \image html Rectangle/Rectangle.jpg
   [
		object,
		uuid(3E07BAA1-01A2-11D3-8CDF-D8B830C3A934),
      oleautomation,
		helpstring("IRectangle Interface"),
		helpcontext(IDH_IRectangle),
		pointer_default(unique)
	]
	interface IRectangle : IUnknown
	{
      /// Height of the rectangle
		[propget, helpstring("property Height"),helpcontext(IDH_IRectangle_Height)]
		HRESULT Height([out, retval] Float64 *pVal);

		[propput, helpstring("property Height"),helpcontext(IDH_IRectangle_Height)]
		HRESULT Height([in] Float64 newVal);

      /// Width of the rectangle
		[propget, helpstring("property Width"),helpcontext(IDH_IRectangle_Width)]
		HRESULT Width([out, retval] Float64 *pVal);

		[propput, helpstring("property Width"),helpcontext(IDH_IRectangle_Width)]
		HRESULT Width([in] Float64 newVal);

      // Hook point located at the center of the rectangle
		[propget, helpstring("property HookPoint"),helpcontext(IDH_IRectangle_HookPoint)]
		HRESULT HookPoint([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property HookPoint"),helpcontext(IDH_IRectangle_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* newVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_IRectangle_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_IRectangle_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing a Triangle
   ///
   /// \image html Triangle/Triangle.jpg
   /// Negative dimensions can be used to form a variety of triangular configurations.
   /// \image html Triangle/Triangle2.jpg
   [
		object,
		uuid(0C89D3A1-02E2-11D3-8CDF-DDE6AA65DF35),
		oleautomation,
		helpstring("ITriangle Interface"),
		helpcontext(IDH_ITriangle),
		pointer_default(unique)
	]
	interface ITriangle : IUnknown
	{
      /// Width of the base of the triangle
		[propget, helpstring("property Width"),helpcontext(IDH_ITriangle_Width)]
		HRESULT Width([out, retval] Float64 *pVal);

		[propput, helpstring("property Width"),helpcontext(IDH_ITriangle_Width)]
		HRESULT Width([in] Float64 newVal);

      /// Height of the triangle
		[propget, helpstring("property Height"),helpcontext(IDH_ITriangle_Height)]
		HRESULT Height([out, retval] Float64 *pVal);

		[propput, helpstring("property Height"),helpcontext(IDH_ITriangle_Height)]
		HRESULT Height([in] Float64 newVal);

      /// Offset from the hook point vertex to the peak of the triangle
		[propget, helpstring("property Offset"),helpcontext(IDH_ITriangle_Offset)]
		HRESULT Offset([out, retval] Float64 *pVal);

		[propput, helpstring("property Offset"),helpcontext(IDH_ITriangle_Offset)]
		HRESULT Offset([in] Float64 newVal);

      // Hook point located at the left-most vertex for a rectangle defined with positive quantities
      [propget, helpstring("property HookPoint"),helpcontext(IDH_ITriangle_HookPoint)]
		HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

		[propputref, helpstring("property HookPoint"),helpcontext(IDH_ITriangle_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_ITriangle_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_ITriangle_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing the cross section of a precast concrete I-Beam
   ///
   /// \image html PrecastBeam/PrecastBeam.jpg
   [
		object,
		uuid(E7E272C1-032F-11D3-8CDF-861E1B8C3634),
		oleautomation,
		helpstring("IPrecastBeam Interface"),
		helpcontext(IDH_IPrecastBeam),
		pointer_default(unique)
	]
	interface IPrecastBeam : IUnknown
	{
      /// A top flange width dimension
		[propget, helpstring("property W1"),helpcontext(IDH_IPrecastBeam_W1)]
		HRESULT W1([out, retval] Float64 *pVal);

		[propput, helpstring("property W1"),helpcontext(IDH_IPrecastBeam_W1)]
		HRESULT W1([in] Float64 newVal);

      /// A top flange width dimension
      [propget, helpstring("property W2"),helpcontext(IDH_IPrecastBeam_W2)]
		HRESULT W2([out, retval] Float64 *pVal);

		[propput, helpstring("property W2"),helpcontext(IDH_IPrecastBeam_W2)]
		HRESULT W2([in] Float64 newVal);

      /// A bottom flange width dimension
      [propget, helpstring("property W3"),helpcontext(IDH_IPrecastBeam_W3)]
		HRESULT W3([out, retval] Float64 *pVal);

		[propput, helpstring("property W3"),helpcontext(IDH_IPrecastBeam_W3)]
		HRESULT W3([in] Float64 newVal);

      /// A bottom flange width dimension
      [propget, helpstring("property W4"),helpcontext(IDH_IPrecastBeam_W4)]
		HRESULT W4([out, retval] Float64 *pVal);

		[propput, helpstring("property W4"),helpcontext(IDH_IPrecastBeam_W4)]
		HRESULT W4([in] Float64 newVal);

      /// A top flange depth dimension
		[propget, helpstring("property D1"),helpcontext(IDH_IPrecastBeam_D1)]
		HRESULT D1([out, retval] Float64 *pVal);

		[propput, helpstring("property D1"),helpcontext(IDH_IPrecastBeam_D1)]
		HRESULT D1([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D2"),helpcontext(IDH_IPrecastBeam_D2)]
		HRESULT D2([out, retval] Float64 *pVal);

		[propput, helpstring("property D2"),helpcontext(IDH_IPrecastBeam_D2)]
		HRESULT D2([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D3"),helpcontext(IDH_IPrecastBeam_D3)]
		HRESULT D3([out, retval] Float64 *pVal);

		[propput, helpstring("property D3"),helpcontext(IDH_IPrecastBeam_D3)]
		HRESULT D3([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D4"),helpcontext(IDH_IPrecastBeam_D4)]
		HRESULT D4([out, retval] Float64 *pVal);

		[propput, helpstring("property D4"),helpcontext(IDH_IPrecastBeam_D4)]
		HRESULT D4([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D5"),helpcontext(IDH_IPrecastBeam_D5)]
		HRESULT D5([out, retval] Float64 *pVal);

		[propput, helpstring("property D5"),helpcontext(IDH_IPrecastBeam_D5)]
		HRESULT D5([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget,  helpstring("property D6"),helpcontext(IDH_IPrecastBeam_D6)]
		HRESULT D6([out, retval] Float64 *pVal);

		[propput,  helpstring("property D6"),helpcontext(IDH_IPrecastBeam_D6)]
		HRESULT D6([in] Float64 newVal);

      /// The web height dimension
      [propget,  helpstring("property D7"),helpcontext(IDH_IPrecastBeam_D7)]
		HRESULT D7([out, retval] Float64 *pVal);

		[propput,  helpstring("property D7"),helpcontext(IDH_IPrecastBeam_D7)]
		HRESULT D7([in] Float64 newVal);

      /// Top of web thickness dimension
		[propget,  helpstring("property T1"),helpcontext(IDH_IPrecastBeam_T1)]
		HRESULT T1([out, retval] Float64 *pVal);

		[propput,  helpstring("property T1"),helpcontext(IDH_IPrecastBeam_T1)]
		HRESULT T1([in] Float64 newVal);

      /// Bottom of web thickness dimension
      [propget,  helpstring("property T2"),helpcontext(IDH_IPrecastBeam_T2)]
		HRESULT T2([out, retval] Float64 *pVal);

		[propput,  helpstring("property T2"),helpcontext(IDH_IPrecastBeam_T2)]
		HRESULT T2([in] Float64 newVal);

      /// Bottom flange chamfer dimension
		[propget,  helpstring("property C1"),helpcontext(IDH_IPrecastBeam_C1)]
		HRESULT C1([out, retval] Float64 *pVal);

		[propput,  helpstring("property C1"),helpcontext(IDH_IPrecastBeam_C1)]
		HRESULT C1([in] Float64 newVal);

      /// Hook point is located at intersection of the vertical centerline and the bottom of the bottom flange
      [propget,  helpstring("property HookPoint"),helpcontext(IDH_IPrecastBeam_HookPoint)]
		HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

      [propputref,  helpstring("property HookPoint"),helpcontext(IDH_IPrecastBeam_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The overall height of the girder
      [propget,  helpstring("property Height"),helpcontext(IDH_IPrecastBeam_Height)]
		HRESULT Height([out, retval] Float64 *pVal);

      /// Average of the web width dimensions
		[propget,  helpstring("property AvgWebWidth"),helpcontext(IDH_IPrecastBeam_AvgWebWidth)]
		HRESULT AvgWebWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the bottom flange
      [propget,  helpstring("property BottomFlangeWidth"),helpcontext(IDH_IPrecastBeam_BottomFlangeWidth)]
		HRESULT BottomFlangeWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the top flange
      [propget,  helpstring("property TopFlangeWidth"),helpcontext(IDH_IPrecastBeam_TopFlangeWidth)]
		HRESULT TopFlangeWidth([out, retval] Float64 *pVal);

      /// The XYPosition property
      [propget,  helpstring("property XYPosition"),helpcontext(IDH_IPrecastBeam_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget,  helpstring("property Shape"),helpcontext(IDH_IPrecastBeam_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing the cross section of a precast concrete I-Beam
   ///
   /// \image html PrecastBeam/PrecastBeam2.png
   [
      object,
      uuid(1FDF594F-DEB1-472F-9069-3C6C30D0FB2D),
      oleautomation,
      helpstring("IPrecastBeam2 Interface"),
      //helpcontext(IDH_IPrecastBeam2),
      pointer_default(unique)
   ]
   interface IPrecastBeam2 : IUnknown
   {
      /// A top flange width dimension
      [propget, helpstring("property W1")/*, helpcontext(IDH_IPrecastBeam2_W1)*/]
      HRESULT W1([out, retval] Float64 *pVal);

      [propput, helpstring("property W1")/*, helpcontext(IDH_IPrecastBeam2_W1)*/]
      HRESULT W1([in] Float64 newVal);

      /// A top flange width dimension
      [propget, helpstring("property W2")/*, helpcontext(IDH_IPrecastBeam2_W2)*/]
      HRESULT W2([out, retval] Float64 *pVal);

      [propput, helpstring("property W2")/*, helpcontext(IDH_IPrecastBeam2_W2)*/]
      HRESULT W2([in] Float64 newVal);

      /// A top flange width dimension
      [propget, helpstring("property W3")/*, helpcontext(IDH_IPrecastBeam2_W3)*/]
      HRESULT W3([out, retval] Float64 *pVal);

      [propput, helpstring("property W3")/*, helpcontext(IDH_IPrecastBeam2_W3)*/]
      HRESULT W3([in] Float64 newVal);

      /// A bottom flange width dimension
      [propget, helpstring("property W4")/*, helpcontext(IDH_IPrecastBeam2_W4)*/]
      HRESULT W4([out, retval] Float64 *pVal);

      [propput, helpstring("property W4")/*, helpcontext(IDH_IPrecastBeam2_W4)*/]
      HRESULT W4([in] Float64 newVal);

      /// A bottom flange width dimension
      [propget, helpstring("property W5")/*, helpcontext(IDH_IPrecastBeam2_W5)*/]
      HRESULT W5([out, retval] Float64 *pVal);

      [propput, helpstring("property W5")/*, helpcontext(IDH_IPrecastBeam2_W5)*/]
      HRESULT W5([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D1")/*, helpcontext(IDH_IPrecastBeam2_D1)*/]
      HRESULT D1([out, retval] Float64 *pVal);

      [propput, helpstring("property D1")/*, helpcontext(IDH_IPrecastBeam2_D1)*/]
      HRESULT D1([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D2")/*, helpcontext(IDH_IPrecastBeam2_D2)*/]
      HRESULT D2([out, retval] Float64 *pVal);

      [propput, helpstring("property D2")/*, helpcontext(IDH_IPrecastBeam2_D2)*/]
      HRESULT D2([in] Float64 newVal);

      [propget, helpstring("property D3")/*, helpcontext(IDH_IPrecastBeam2_D3)*/]
      HRESULT D3([out, retval] Float64 *pVal);

      /// A top flange depth dimension
      [propput, helpstring("property D3")/*, helpcontext(IDH_IPrecastBeam2_D3)*/]
      HRESULT D3([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D4")/*, helpcontext(IDH_IPrecastBeam2_D4)*/]
      HRESULT D4([out, retval] Float64 *pVal);

      [propput, helpstring("property D4")/*, helpcontext(IDH_IPrecastBeam2_D4)*/]
      HRESULT D4([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D5")/*, helpcontext(IDH_IPrecastBeam2_D5)*/]
      HRESULT D5([out, retval] Float64 *pVal);

      [propput, helpstring("property D5")/*, helpcontext(IDH_IPrecastBeam2_D5)*/]
      HRESULT D5([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D6")/*, helpcontext(IDH_IPrecastBeam2_D6)*/]
      HRESULT D6([out, retval] Float64 *pVal);

      [propput, helpstring("property D6")/*, helpcontext(IDH_IPrecastBeam2_D6)*/]
      HRESULT D6([in] Float64 newVal);

      /// Overall height of girder shape
      [propget, helpstring("property H")/*, helpcontext(IDH_IPrecastBeam2_H)*/]
      HRESULT H([out, retval] Float64 *pVal);

      [propput, helpstring("property H")/*, helpcontext(IDH_IPrecastBeam2_H)*/]
      HRESULT H([in] Float64 newVal);

      /// Top of web thickness dimension
      [propget, helpstring("property T1")/*, helpcontext(IDH_IPrecastBeam2_T1)*/]
      HRESULT T1([out, retval] Float64 *pVal);

      /// Bottom of web thickness dimension
      [propput, helpstring("property T1")/*, helpcontext(IDH_IPrecastBeam2_T1)*/]
      HRESULT T1([in] Float64 newVal);

      [propget, helpstring("property T2")/*, helpcontext(IDH_IPrecastBeam2_T2)*/]
      HRESULT T2([out, retval] Float64 *pVal);

      [propput, helpstring("property T2")/*, helpcontext(IDH_IPrecastBeam2_T2)*/]
      HRESULT T2([in] Float64 newVal);

      /// Bottom flange chamfer dimension
      [propget, helpstring("property C1")/*, helpcontext(IDH_IPrecastBeam2_C1)*/]
      HRESULT C1([out, retval] Float64 *pVal);

      [propput, helpstring("property C1")/*, helpcontext(IDH_IPrecastBeam2_C1)*/]
      HRESULT C1([in] Float64 newVal);

      /// Hook point is located at intersection of the vertical centerline and the bottom of the bottom flange
      [propget, helpstring("property HookPoint")/*, helpcontext(IDH_IPrecastBeam2_HookPoint)*/]
      HRESULT HookPoint([out, retval] IPoint2d** hookPnt);

      [propputref, helpstring("property HookPoint")/*, helpcontext(IDH_IPrecastBeam2_HookPoint)*/]
      HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The overall height of the girder
      [propget, helpstring("property Height")/*, helpcontext(IDH_IPrecastBeam2_Height)*/]
      HRESULT Height([out, retval] Float64 *pVal);

      /// Average of the web width dimensions
      [propget, helpstring("property AvgWebWidth")/*, helpcontext(IDH_IPrecastBeam2_AvgWebWidth)*/]
      HRESULT AvgWebWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the bottom flange
      [propget, helpstring("property BottomFlangeWidth")/*, helpcontext(IDH_IPrecastBeam2_BottomFlangeWidth)*/]
      HRESULT BottomFlangeWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the top flange
      [propget, helpstring("property TopFlangeWidth")/*, helpcontext(IDH_IPrecastBeam2_TopFlangeWidth)*/]
      HRESULT TopFlangeWidth([out, retval] Float64 *pVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition")/*, helpcontext(IDH_IPrecastBeam2_XYPosition)*/]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget, helpstring("property Shape")/*, helpcontext(IDH_IPrecastBeam2_Shape)*/]
      HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing the cross section of a University of Nebraska (NU) precast concrete I-Beam
   ///
   /// \image html NUBeam/NUBeam.jpg   
   [
		object,
		uuid(AF453AD4-38FF-4493-B988-4E871CBE0F2E),
		oleautomation,
		helpstring("INUBeam Interface"),
		helpcontext(IDH_INUBeam),
		pointer_default(unique)
	]
	interface INUBeam : IUnknown
	{
      /// Top flange width
		[propget, helpstring("property W1"),helpcontext(IDH_INUBeam_W1)]
		HRESULT W1([out, retval] Float64 *pVal);

		[propput, helpstring("property W1"),helpcontext(IDH_INUBeam_W1)]
		HRESULT W1([in] Float64 newVal);

      /// Bottom flange width
      [propget, helpstring("property W2"),helpcontext(IDH_INUBeam_W2)]
		HRESULT W2([out, retval] Float64 *pVal);

		[propput, helpstring("property W2"),helpcontext(IDH_INUBeam_W2)]
		HRESULT W2([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D1"),helpcontext(IDH_INUBeam_D1)]
		HRESULT D1([out, retval] Float64 *pVal);

		[propput, helpstring("property D1"),helpcontext(IDH_INUBeam_D1)]
		HRESULT D1([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D2"),helpcontext(IDH_INUBeam_D2)]
		HRESULT D2([out, retval] Float64 *pVal);

		[propput, helpstring("property D2"),helpcontext(IDH_INUBeam_D2)]
		HRESULT D2([in] Float64 newVal);

      /// Web depth dimension
      [propget, helpstring("property D3"),helpcontext(IDH_INUBeam_D3)]
		HRESULT D3([out, retval] Float64 *pVal);

		[propput, helpstring("property D3"),helpcontext(IDH_INUBeam_D3)]
		HRESULT D3([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D4"),helpcontext(IDH_INUBeam_D4)]
		HRESULT D4([out, retval] Float64 *pVal);

		[propput, helpstring("property D4"),helpcontext(IDH_INUBeam_D4)]
		HRESULT D4([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D5"),helpcontext(IDH_INUBeam_D5)]
		HRESULT D5([out, retval] Float64 *pVal);

		[propput, helpstring("property D5"),helpcontext(IDH_INUBeam_D5)]
		HRESULT D5([in] Float64 newVal);

      /// Web width dimension
      [propget, helpstring("property T"),helpcontext(IDH_INUBeam_T)]
		HRESULT T([out, retval] Float64 *pVal);

		[propput, helpstring("property T"),helpcontext(IDH_INUBeam_T)]
		HRESULT T([in] Float64 newVal);

      /// Width of an end block
      ///
      /// When the end block width is greater than T, the geometry of
      // the web and the top and bottom flanges are modified so the web of the 
      // girder is equal to the end block width
		[propget, helpstring("property EndBlock"),helpcontext(IDH_INUBeam_T)]
		HRESULT EndBlock([out, retval] Float64 *pVal);

		[propput, helpstring("property EndBlock"),helpcontext(IDH_INUBeam_T)]
		HRESULT EndBlock([in] Float64 newVal);

      /// Radius of top flange-web intersection
		[propget, helpstring("property R1"),helpcontext(IDH_INUBeam_R1)]
		HRESULT R1([out, retval] Float64 *pVal);

		[propput, helpstring("property R1"),helpcontext(IDH_INUBeam_R1)]
		HRESULT R1([in] Float64 newVal);

      /// Radius of bottom flange-web intersection
      [propget, helpstring("property R2"),helpcontext(IDH_INUBeam_R2)]
		HRESULT R2([out, retval] Float64 *pVal);

		[propput, helpstring("property R2"),helpcontext(IDH_INUBeam_R2)]
		HRESULT R2([in] Float64 newVal);

      /// Radius of top flange corner
      [propget, helpstring("property R3"),helpcontext(IDH_INUBeam_R3)]
		HRESULT R3([out, retval] Float64 *pVal);

		[propput, helpstring("property R3"),helpcontext(IDH_INUBeam_R3)]
		HRESULT R3([in] Float64 newVal);

      /// Radius of bottom flange corner
      [propget, helpstring("property R4"),helpcontext(IDH_INUBeam_R4)]
		HRESULT R4([out, retval] Float64 *pVal);

		[propput, helpstring("property R4"),helpcontext(IDH_INUBeam_R4)]
		HRESULT R4([in] Float64 newVal);

      /// Bottom flange chamfer dimension
		[propget, helpstring("property C1"),helpcontext(IDH_INUBeam_C1)]
		HRESULT C1([out, retval] Float64 *pVal);

		[propput, helpstring("property C1"),helpcontext(IDH_INUBeam_C1)]
		HRESULT C1([in] Float64 newVal);

      /// Hook point is located at intersection of the vertical centerline and the bottom of the bottom flange
      [propget, helpstring("property HookPoint"),helpcontext(IDH_INUBeam_HookPoint)]
		HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

      [propputref, helpstring("property HookPoint"),helpcontext(IDH_INUBeam_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The overall height of the girder
      [propget, helpstring("property Height"),helpcontext(IDH_INUBeam_Height)]
		HRESULT Height([out, retval] Float64 *pVal);

      /// Average of the web width dimensions
      [propget, helpstring("property AvgWebWidth"),helpcontext(IDH_INUBeam_AvgWebWidth)]
		HRESULT AvgWebWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the bottom flange
		[propget, helpstring("property BottomFlangeWidth"),helpcontext(IDH_INUBeam_BottomFlangeWidth)]
		HRESULT BottomFlangeWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the top flange
      [propget, helpstring("property TopFlangeWidth"),helpcontext(IDH_INUBeam_TopFlangeWidth)]
		HRESULT TopFlangeWidth([out, retval] Float64 *pVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_INUBeam_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_INUBeam_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing the cross section of a Decked I-Beam based on the University of Nebraska (NU) precast concrete I-Beam section.
/// This shape is intended for use with PCI UHPC girder bridges
///
/// \image html NUDeckedIBeam/NUDeckedIBeam.jpg   
   [
      object,
      uuid(ABB8969A-87E6-43BF-99E9-73DBD2D5440E),
      oleautomation,
      helpstring("INUDeckedIBeam Interface"),
      //helpcontext(IDH_INUBeam),
      pointer_default(unique)
   ]
   interface INUDeckedIBeam : IUnknown
   {
      /// Top flange width
      [propget, helpstring("property W1")] HRESULT W1([out, retval] Float64* pVal);
      [propput, helpstring("property W1")] HRESULT W1([in] Float64 newVal);

      /// Top flange overhang
      [propget, helpstring("property W2")] HRESULT W2([out, retval] Float64* pVal);
      [propput, helpstring("property W2")] HRESULT W2([in] Float64 newVal);

      /// Top flange chamfer
      [propget, helpstring("property W3")] HRESULT W3([out, retval] Float64* pVal);
      [propput, helpstring("property W3")] HRESULT W3([in] Float64 newVal);

      /// Bottom flange width
      [propget, helpstring("property W4")] HRESULT W4([out, retval] Float64* pVal);
      [propput, helpstring("property W4")] HRESULT W4([in] Float64 newVal);

      /// Overall girder height
      [propget, helpstring("property H")] HRESULT H([out, retval] Float64* pVal);
      [propput, helpstring("property H")] HRESULT H([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D1")] HRESULT D1([out, retval] Float64* pVal);
      [propput, helpstring("property D1")] HRESULT D1([in] Float64 newVal);

      /// A top flange rib depth dimension
      [propget, helpstring("property D2")] HRESULT D2([out, retval] Float64* pVal);
      [propput, helpstring("property D2")] HRESULT D2([in] Float64 newVal);

      /// Top flange depth at centerline web dimension
      [propget, helpstring("property D3")] HRESULT D3([out, retval] Float64* pVal);
      [propput, helpstring("property D3")] HRESULT D3([in] Float64 newVal);

      /// Top flange rib depth at centerline web dimension
      [propget, helpstring("property D4")] HRESULT D4([out, retval] Float64* pVal);
      [propput, helpstring("property D4")] HRESULT D4([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D5")] HRESULT D5([out, retval] Float64* pVal);
      [propput, helpstring("property D5")] HRESULT D5([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D6")] HRESULT D6([out, retval] Float64* pVal);
      [propput, helpstring("property D6")] HRESULT D6([in] Float64 newVal);

      /// Web width dimension
      [propget, helpstring("property T")] HRESULT T([out, retval] Float64* pVal);
      [propput, helpstring("property T")] HRESULT T([in] Float64 newVal);

      /// Radius of top flange-web intersection
      [propget, helpstring("property R1")] HRESULT R1([out, retval] Float64* pVal);
      [propput, helpstring("property R1")] HRESULT R1([in] Float64 newVal);

      /// Radius of bottom flange-web intersection
      [propget, helpstring("property R2")] HRESULT R2([out, retval] Float64* pVal);
      [propput, helpstring("property R2")] HRESULT R2([in] Float64 newVal);

      /// Bottom flange chamfer dimension
      [propget, helpstring("property C1")] HRESULT C1([out, retval] Float64* pVal);
      [propput, helpstring("property C1")] HRESULT C1([in] Float64 newVal);

      /// Hook point is located at intersection of the vertical centerline and the bottom of the bottom flange
      [propget, helpstring("property HookPoint")] HRESULT HookPoint([out, retval] IPoint2d** hookPnt);
      [propputref, helpstring("property HookPoint")] HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The overall height of the girder
      [propget, helpstring("property Height")] HRESULT Height([out, retval] Float64* pVal);

      /// Average of the web width dimensions
      [propget, helpstring("property AvgWebWidth")] HRESULT AvgWebWidth([out, retval] Float64* pVal);

      /// Out-to-out width of the bottom flange
      [propget, helpstring("property BottomFlangeWidth")]
      HRESULT BottomFlangeWidth([out, retval] Float64* pVal);

      /// Out-to-out width of the top flange
      [propget, helpstring("property TopFlangeWidth")] HRESULT TopFlangeWidth([out, retval] Float64* pVal);

      /// Points defining the top flange
      ///
      /// \image html BulbTee/TopFlangePoints.png
      [helpstring("property GetTopFlangePoints")]
      HRESULT GetTopFlangePoints(
         [out]IPoint2d** ppLeftTop,    ///< point at top-left flange tip
         [out]IPoint2d** ppLeftBottom,  ///< point directly below the top-left flange tip
         [out]IPoint2d** ppTopCL, ///< point directly above the CL web
         [out]IPoint2d** ppTopCentral,  ///< point at crown point in the top flange
         [out]IPoint2d** ppRightTop,  ///< point at top-right flange tip
         [out]IPoint2d** ppRightBottom ///< point directly below the top-right flange tip
      );

      /// Points defining the bottom flange
      ///
      /// \image html BulbTee/BottomFlangePoints.png
      [helpstring("property GetBottomFlangePoints")]
      HRESULT GetBottomFlangePoints(
         [out]IPoint2d** ppLeftTop, ///< point directly above the bottom-left flange tip
         [out]IPoint2d** ppLeftBottom,  ///< point at bottom-left flange tip
         [out]IPoint2d** ppRightTop,  ///< point directly above the bottom-right flange tip
         [out]IPoint2d** ppRightBottom ///< point at bottom-right flange tip
      );

      /// Thickness of the top flange
      [helpstring("method GetTopFlangeThickness")]
      HRESULT GetTopFlangeThickness(
         [out]Float64* pHl, ///< Left flange tip
         [out]Float64* pHc, ///< At centerline of web
         [out]Float64* pHr  ///< Right flange tip
      );

      /// The XYPosition property
      [propget, helpstring("property XYPosition")] HRESULT XYPosition([out, retval] IXYPosition** pVal);

      /// The Shape property
      [propget, helpstring("property Shape")] HRESULT Shape([out, retval] IShape** pVal);
   };


   /// Object representing the cross section of a Decked I-Beam based on the University of Nebraska (NU) precast concrete I-Beam section.
   /// This shape is intended for use with PCI UHPC girder bridges
   ///
   /// \image html PCIUHPCDeckedIBeam/PCIUHPCDeckedIBeam.jpg   
   [
      object,
      uuid(822A1F1E-A461-438A-8447-55CA89B78CA2),
      oleautomation,
      helpstring("IPCIDeckedIBeam Interface"),
      //helpcontext(IDH_INUBeam),
      pointer_default(unique)
   ]
   interface IPCIDeckedIBeam : IUnknown
   {
      /// Top flange width
      [propget, helpstring("property W1")] HRESULT W1([out, retval] Float64* pVal);
      [propput, helpstring("property W1")] HRESULT W1([in] Float64 newVal);

      /// Top flange overhang
      [propget, helpstring("property W2")] HRESULT W2([out, retval] Float64* pVal);
      [propput, helpstring("property W2")] HRESULT W2([in] Float64 newVal);

      /// Top flange chamfer
      [propget, helpstring("property W3")] HRESULT W3([out, retval] Float64* pVal);
      [propput, helpstring("property W3")] HRESULT W3([in] Float64 newVal);

      /// Bottom flange width
      [propget, helpstring("property W4")] HRESULT W4([out, retval] Float64* pVal);
      [propput, helpstring("property W4")] HRESULT W4([in] Float64 newVal);

      [propget, helpstring("property W5")] HRESULT W5([out, retval] Float64* pVal);
      [propput, helpstring("property W5")] HRESULT W5([in] Float64 newVal);

      [propget, helpstring("property W6")] HRESULT W6([out, retval] Float64* pVal);
      [propput, helpstring("property W6")] HRESULT W6([in] Float64 newVal);

      /// Overall girder height
      [propget, helpstring("property H")] HRESULT H([out, retval] Float64* pVal);
      [propput, helpstring("property H")] HRESULT H([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D1")] HRESULT D1([out, retval] Float64* pVal);
      [propput, helpstring("property D1")] HRESULT D1([in] Float64 newVal);

      /// A top flange rib depth dimension
      [propget, helpstring("property D2")] HRESULT D2([out, retval] Float64* pVal);
      [propput, helpstring("property D2")] HRESULT D2([in] Float64 newVal);

      /// Top flange depth at centerline web dimension
      [propget, helpstring("property D3")] HRESULT D3([out, retval] Float64* pVal);
      [propput, helpstring("property D3")] HRESULT D3([in] Float64 newVal);

      /// Top flange rib depth at centerline web dimension
      [propget, helpstring("property D4")] HRESULT D4([out, retval] Float64* pVal);
      [propput, helpstring("property D4")] HRESULT D4([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D5")] HRESULT D5([out, retval] Float64* pVal);
      [propput, helpstring("property D5")] HRESULT D5([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D6")] HRESULT D6([out, retval] Float64* pVal);
      [propput, helpstring("property D6")] HRESULT D6([in] Float64 newVal);

      [propget, helpstring("property D7")] HRESULT D7([out, retval] Float64* pVal);
      [propput, helpstring("property D7")] HRESULT D7([in] Float64 newVal);

      [propget, helpstring("property D8")] HRESULT D8([out, retval] Float64* pVal);
      [propput, helpstring("property D8")] HRESULT D8([in] Float64 newVal);

      [propget, helpstring("property D9")] HRESULT D9([out, retval] Float64* pVal);
      [propput, helpstring("property D9")] HRESULT D9([in] Float64 newVal);

      /// Web width dimension
      [propget, helpstring("property T")] HRESULT T([out, retval] Float64* pVal);
      [propput, helpstring("property T")] HRESULT T([in] Float64 newVal);

      /// Radius of top flange-web intersection
      [propget, helpstring("property R1")] HRESULT R1([out, retval] Float64* pVal);
      [propput, helpstring("property R1")] HRESULT R1([in] Float64 newVal);

      /// Radius of bottom flange-web intersection
      [propget, helpstring("property R2")] HRESULT R2([out, retval] Float64* pVal);
      [propput, helpstring("property R2")] HRESULT R2([in] Float64 newVal);

      [propget, helpstring("property R3")] HRESULT R3([out, retval] Float64* pVal);
      [propput, helpstring("property R3")] HRESULT R3([in] Float64 newVal);

      /// Bottom flange chamfer dimension
      [propget, helpstring("property C1")] HRESULT C1([out, retval] Float64* pVal);
      [propput, helpstring("property C1")] HRESULT C1([in] Float64 newVal);

      /// Hook point is located at intersection of the vertical centerline and the bottom of the bottom flange
      [propget, helpstring("property HookPoint")] HRESULT HookPoint([out, retval] IPoint2d** hookPnt);
      [propputref, helpstring("property HookPoint")] HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The overall height of the girder
      [propget, helpstring("property Height")] HRESULT Height([out, retval] Float64* pVal);

      /// Average of the web width dimensions
      [propget, helpstring("property AvgWebWidth")] HRESULT AvgWebWidth([out, retval] Float64* pVal);

      /// Out-to-out width of the bottom flange
      [propget, helpstring("property BottomFlangeWidth")]
      HRESULT BottomFlangeWidth([out, retval] Float64* pVal);

      /// Out-to-out width of the top flange
      [propget, helpstring("property TopFlangeWidth")] HRESULT TopFlangeWidth([out, retval] Float64* pVal);

      /// Points defining the top flange
      ///
      /// \image html BulbTee/TopFlangePoints.png
      [helpstring("property GetTopFlangePoints")]
      HRESULT GetTopFlangePoints(
         [out]IPoint2d** ppLeftTop,    ///< point at top-left flange tip
         [out]IPoint2d** ppLeftBottom,  ///< point directly below the top-left flange tip
         [out]IPoint2d** ppTopCL, ///< point directly above the CL web
         [out]IPoint2d** ppTopCentral,  ///< point at crown point in the top flange
         [out]IPoint2d** ppRightTop,  ///< point at top-right flange tip
         [out]IPoint2d** ppRightBottom ///< point directly below the top-right flange tip
      );

      /// Points defining the bottom flange
      ///
      /// \image html BulbTee/BottomFlangePoints.png
      [helpstring("property GetBottomFlangePoints")]
      HRESULT GetBottomFlangePoints(
         [out]IPoint2d** ppLeftTop, ///< point directly above the bottom-left flange tip
         [out]IPoint2d** ppLeftBottom,  ///< point at bottom-left flange tip
         [out]IPoint2d** ppRightTop,  ///< point directly above the bottom-right flange tip
         [out]IPoint2d** ppRightBottom ///< point at bottom-right flange tip
      );

      /// Thickness of the top flange
      [helpstring("method GetTopFlangeThickness")]
      HRESULT GetTopFlangeThickness(
         [out]Float64* pHl, ///< Left flange tip
         [out]Float64* pHc, ///< At centerline of web
         [out]Float64* pHr  ///< Right flange tip
      );

      /// The XYPosition property
      [propget, helpstring("property XYPosition")] HRESULT XYPosition([out, retval] IXYPosition** pVal);

      /// The Shape property
      [propget, helpstring("property Shape")] HRESULT Shape([out, retval] IShape** pVal);
   };

   /// Object representing the cross section of a deck bulb tee girder
   ///
   /// \image html BulbTee/BulbTee.jpg   
   [
		object,
		uuid(84F1406D-0AF3-400b-92A4-1EE4804921AD),
		oleautomation,
		helpstring("IBulbTee Interface"),
		helpcontext(IDH_IBulbTee),
		pointer_default(unique)
	]
	interface IBulbTee : IUnknown
	{
      /// A top flange width dimension
		[propget, helpstring("property W1"),helpcontext(IDH_IBulbTee_W1)]
		HRESULT W1([out, retval] Float64 *pVal);

		[propput, helpstring("property W1"),helpcontext(IDH_IBulbTee_W1)]
		HRESULT W1([in] Float64 newVal);

      /// A top flange width dimension
      [propget, helpstring("property W2"),helpcontext(IDH_IBulbTee_W2)]
		HRESULT W2([out, retval] Float64 *pVal);

		[propput, helpstring("property W2"),helpcontext(IDH_IBulbTee_W2)]
		HRESULT W2([in] Float64 newVal);

      /// A bottom flange width dimension
      [propget, helpstring("property W3"),helpcontext(IDH_IBulbTee_W3)]
		HRESULT W3([out, retval] Float64 *pVal);

		[propput, helpstring("property W3"),helpcontext(IDH_IBulbTee_W3)]
		HRESULT W3([in] Float64 newVal);

      /// A bottom flange width dimension
      [propget, helpstring("property W4"),helpcontext(IDH_IBulbTee_W4)]
		HRESULT W4([out, retval] Float64 *pVal);

		[propput, helpstring("property W4"),helpcontext(IDH_IBulbTee_W4)]
		HRESULT W4([in] Float64 newVal);

      /// The overall top flange width dimension
      [propget, helpstring("property W5"),helpcontext(IDH_IBulbTee_W5)]
		HRESULT W5([out, retval] Float64 *pVal);

		[propput, helpstring("property W5"),helpcontext(IDH_IBulbTee_W5)]
		HRESULT W5([in] Float64 newVal);

      /// Bottom flange chamfer dimension
		[propget, helpstring("property C1"),helpcontext(IDH_IBulbTee_C1)]
		HRESULT C1([out, retval] Float64 *pVal);

		[propput, helpstring("property C1"),helpcontext(IDH_IBulbTee_C1)]
		HRESULT C1([in] Float64 newVal);

      /// A top flange depth dimension
		[propget, helpstring("property D1"),helpcontext(IDH_IBulbTee_D1)]
		HRESULT D1([out, retval] Float64 *pVal);

		[propput, helpstring("property D1"),helpcontext(IDH_IBulbTee_D1)]
		HRESULT D1([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D2"),helpcontext(IDH_IBulbTee_D2)]
		HRESULT D2([out, retval] Float64 *pVal);

		[propput, helpstring("property D2"),helpcontext(IDH_IBulbTee_D2)]
		HRESULT D2([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D3"),helpcontext(IDH_IBulbTee_D3)]
		HRESULT D3([out, retval] Float64 *pVal);

		[propput, helpstring("property D3"),helpcontext(IDH_IBulbTee_D3)]
		HRESULT D3([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D4"),helpcontext(IDH_IBulbTee_D4)]
		HRESULT D4([out, retval] Float64 *pVal);

		[propput, helpstring("property D4"),helpcontext(IDH_IBulbTee_D4)]
		HRESULT D4([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D5"),helpcontext(IDH_IBulbTee_D5)]
		HRESULT D5([out, retval] Float64 *pVal);

		[propput, helpstring("property D5"),helpcontext(IDH_IBulbTee_D5)]
		HRESULT D5([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget,  helpstring("property D6"),helpcontext(IDH_IBulbTee_D6)]
		HRESULT D6([out, retval] Float64 *pVal);

		[propput,  helpstring("property D6"),helpcontext(IDH_IBulbTee_D6)]
		HRESULT D6([in] Float64 newVal);

      /// Web depth dimension
      [propget,  helpstring("property D7"),helpcontext(IDH_IBulbTee_D7)]
		HRESULT D7([out, retval] Float64 *pVal);

		[propput,  helpstring("property D7"),helpcontext(IDH_IBulbTee_D7)]
		HRESULT D7([in] Float64 newVal);

      /// Web thickness at top flange
		[propget,  helpstring("property T1"),helpcontext(IDH_IBulbTee_T1)]
		HRESULT T1([out, retval] Float64 *pVal);

		[propput,  helpstring("property T1"),helpcontext(IDH_IBulbTee_T1)]
		HRESULT T1([in] Float64 newVal);

      /// Web thickness at bottom flange
      [propget,  helpstring("property T2"),helpcontext(IDH_IBulbTee_T2)]
		HRESULT T2([out, retval] Float64 *pVal);

		[propput,  helpstring("property T2"),helpcontext(IDH_IBulbTee_T2)]
		HRESULT T2([in] Float64 newVal);

      /// Hook point is located at intersection of the vertical centerline and the bottom of the bottom flange.
      [propget,  helpstring("property HookPoint"),helpcontext(IDH_IBulbTee_HookPoint)]
		HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

      [propputref,  helpstring("property HookPoint"),helpcontext(IDH_IBulbTee_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The overall height of the girder
      [propget,  helpstring("property Height"),helpcontext(IDH_IBulbTee_Height)]
		HRESULT Height([out, retval] Float64 *pVal);

      /// Average of the web width dimensions
      [propget,  helpstring("property AvgWebWidth"),helpcontext(IDH_IBulbTee_AvgWebWidth)]
		HRESULT AvgWebWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the bottom flange
      [propget,  helpstring("property BottomFlangeWidth"),helpcontext(IDH_IBulbTee_BottomFlangeWidth)]
		HRESULT BottomFlangeWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the top flange
      [propget,  helpstring("property TopFlangeWidth"),helpcontext(IDH_IBulbTee_TopFlangeWidth)]
		HRESULT TopFlangeWidth([out, retval] Float64 *pVal);

      /// The XYPosition property
      [propget,  helpstring("property XYPosition"),helpcontext(IDH_IBulbTee_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget,  helpstring("property Shape"),helpcontext(IDH_IBulbTee_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing the cross section of a deck bulb tee girder
   ///
   /// \image html BulbTee/BulbTee2.png   
   [
      object,
      uuid(08EA1719-7EF6-44EC-9B49-FF4E967DF74A),
      oleautomation,
      helpstring("IBulbTee2 Interface"),
      helpcontext(IDH_IBulbTee),
      pointer_default(unique)
   ]
   interface IBulbTee2 : IUnknown
   {
      /// A top flange width dimension
      [propget, helpstring("property W1"), helpcontext(IDH_IBulbTee_W1)]
      HRESULT W1([out, retval] Float64 *pVal);

      [propput, helpstring("property W1"), helpcontext(IDH_IBulbTee_W1)]
      HRESULT W1([in] Float64 newVal);

      /// A top flange width dimension
      [propget, helpstring("property W2"), helpcontext(IDH_IBulbTee_W2)]
      HRESULT W2([out, retval] Float64 *pVal);

      [propput, helpstring("property W2"), helpcontext(IDH_IBulbTee_W2)]
      HRESULT W2([in] Float64 newVal);

      /// A bottom flange width dimension
      [propget, helpstring("property W3"), helpcontext(IDH_IBulbTee_W3)]
      HRESULT W3([out, retval] Float64 *pVal);

      [propput, helpstring("property W3"), helpcontext(IDH_IBulbTee_W3)]
      HRESULT W3([in] Float64 newVal);

      /// A bottom flange width dimension
      [propget, helpstring("property W4"), helpcontext(IDH_IBulbTee_W4)]
      HRESULT W4([out, retval] Float64 *pVal);

      [propput, helpstring("property W4"), helpcontext(IDH_IBulbTee_W4)]
      HRESULT W4([in] Float64 newVal);

      /// Distance from left edge of top flange to centerline of web
      [propget, helpstring("property W5"), helpcontext(IDH_IBulbTee_W5)]
      HRESULT W5([out, retval] Float64 *pVal);

      [propput, helpstring("property W5"), helpcontext(IDH_IBulbTee_W5)]
      HRESULT W5([in] Float64 newVal);

      /// Distance from right edge of top flange to centerline of web
      [propget, helpstring("property W6"), helpcontext(IDH_IBulbTee_W5)]
      HRESULT W6([out, retval] Float64 *pVal);

      [propput, helpstring("property W6"), helpcontext(IDH_IBulbTee_W5)]
      HRESULT W6([in] Float64 newVal);

      /// Bottom flange chamfer dimension
      [propget, helpstring("property C1"), helpcontext(IDH_IBulbTee_C1)]
      HRESULT C1([out, retval] Float64 *pVal);

      [propput, helpstring("property C1"), helpcontext(IDH_IBulbTee_C1)]
      HRESULT C1([in] Float64 newVal);

      /// Distance from the left flange tip to the crown point in the top flange
      ///
      /// If the top flange has a constant slope, set C2 to 0.0 and use the n2 slope
      /// or set C2 equal to W5+W5 and use the n1 slope
      [propget, helpstring("property C2"), helpcontext(IDH_IBulbTee_C1)]
      HRESULT C2([out, retval] Float64 *pVal);

      [propput, helpstring("property C2"), helpcontext(IDH_IBulbTee_C1)]
      HRESULT C2([in] Float64 newVal);

      /// A top flange depth dimension
      ///
      /// The depth of the top flange at the left and right edges are different.
      /// This dimension is the least depth.
      [propget, helpstring("property D1"), helpcontext(IDH_IBulbTee_D1)]
      HRESULT D1([out, retval] Float64 *pVal);

      [propput, helpstring("property D1"), helpcontext(IDH_IBulbTee_D1)]
      HRESULT D1([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D2"), helpcontext(IDH_IBulbTee_D2)]
      HRESULT D2([out, retval] Float64 *pVal);

      [propput, helpstring("property D2"), helpcontext(IDH_IBulbTee_D2)]
      HRESULT D2([in] Float64 newVal);

      /// A top flange depth dimension
      [propget, helpstring("property D3"), helpcontext(IDH_IBulbTee_D3)]
      HRESULT D3([out, retval] Float64 *pVal);

      [propput, helpstring("property D3"), helpcontext(IDH_IBulbTee_D3)]
      HRESULT D3([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D4"), helpcontext(IDH_IBulbTee_D4)]
      HRESULT D4([out, retval] Float64 *pVal);

      [propput, helpstring("property D4"), helpcontext(IDH_IBulbTee_D4)]
      HRESULT D4([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D5"), helpcontext(IDH_IBulbTee_D5)]
      HRESULT D5([out, retval] Float64 *pVal);

      [propput, helpstring("property D5"), helpcontext(IDH_IBulbTee_D5)]
      HRESULT D5([in] Float64 newVal);

      /// A bottom flange depth dimension
      [propget, helpstring("property D6"), helpcontext(IDH_IBulbTee_D6)]
      HRESULT D6([out, retval] Float64 *pVal);

      [propput, helpstring("property D6"), helpcontext(IDH_IBulbTee_D6)]
      HRESULT D6([in] Float64 newVal);

      /// Web depth dimension
      [propget, helpstring("property D7"), helpcontext(IDH_IBulbTee_D7)]
      HRESULT D7([out, retval] Float64 *pVal);

      [propput, helpstring("property D7"), helpcontext(IDH_IBulbTee_D7)]
      HRESULT D7([in] Float64 newVal);

      /// Web thickness at top flange
      [propget, helpstring("property T1"), helpcontext(IDH_IBulbTee_T1)]
      HRESULT T1([out, retval] Float64 *pVal);

      [propput, helpstring("property T1"), helpcontext(IDH_IBulbTee_T1)]
      HRESULT T1([in] Float64 newVal);

      /// Web thickness at bottom flange
      [propget, helpstring("property T2"), helpcontext(IDH_IBulbTee_T2)]
      HRESULT T2([out, retval] Float64 *pVal);

      [propput, helpstring("property T2"), helpcontext(IDH_IBulbTee_T2)]
      HRESULT T2([in] Float64 newVal);
      
      /// Top flange slope left of the crown point
      [propget, helpstring("property n1"), helpcontext(IDH_IBulbTee_T1)]
      HRESULT n1([out, retval] Float64 *pVal);

      [propput, helpstring("property n1"), helpcontext(IDH_IBulbTee_T1)]
      HRESULT n1([in] Float64 newVal);

      /// Top flange slope right of the crown point
      [propget, helpstring("property n2"), helpcontext(IDH_IBulbTee_T2)]
      HRESULT n2([out, retval] Float64 *pVal);

      [propput, helpstring("property n2"), helpcontext(IDH_IBulbTee_T2)]
      HRESULT n2([in] Float64 newVal);

      /// Hook point is located at intersection of the vertical centerline of the web and the bottom of the bottom flange.
      [propget, helpstring("property HookPoint"), helpcontext(IDH_IBulbTee_HookPoint)]
      HRESULT HookPoint([out, retval] IPoint2d** hookPnt);

      [propputref, helpstring("property HookPoint"), helpcontext(IDH_IBulbTee_HookPoint)]
      HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// Height of the girder shape at the lowest point in the top flange
      [propget, helpstring("property MinHeight"), helpcontext(IDH_IBulbTee_Height)]
      HRESULT MinHeight([out, retval] Float64 *pVal);

      /// Height of the girder shape at the highest point in the top flange
      [propget, helpstring("property MaxHeight"), helpcontext(IDH_IBulbTee_Height)]
      HRESULT MaxHeight([out, retval] Float64 *pVal);

      /// Height of the girder shape at the centerline of the web
      [propget, helpstring("property CLHeight"), helpcontext(IDH_IBulbTee_Height)]
      HRESULT CLHeight([out, retval] Float64 *pVal);

      /// The overall height of the girder
      [propget, helpstring("property Height"), helpcontext(IDH_IBulbTee_Height)]
      HRESULT Height([out, retval] Float64 *pVal);

      /// Average of the web width dimensions
      [propget, helpstring("property AvgWebWidth"), helpcontext(IDH_IBulbTee_AvgWebWidth)]
      HRESULT AvgWebWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the bottom flange
      [propget, helpstring("property BottomFlangeWidth"), helpcontext(IDH_IBulbTee_BottomFlangeWidth)]
      HRESULT BottomFlangeWidth([out, retval] Float64 *pVal);

      /// Out-to-out width of the top flange
      [propget, helpstring("property TopFlangeWidth"), helpcontext(IDH_IBulbTee_TopFlangeWidth)]
      HRESULT TopFlangeWidth([out, retval] Float64 *pVal);

      /// Points defining the top flange
      ///
      /// \image html BulbTee/TopFlangePoints.png
      [helpstring("property GetTopFlangePoints")]
      HRESULT GetTopFlangePoints(
         [out]IPoint2d** ppLeftTop,    ///< point at top-left flange tip
         [out]IPoint2d** ppLeftBottom,  ///< point directly below the top-left flange tip
         [out]IPoint2d** ppTopCL, ///< point directly above the CL web
         [out]IPoint2d** ppTopCentral,  ///< point at crown point in the top flange
         [out]IPoint2d** ppRightTop,  ///< point at top-right flange tip
         [out]IPoint2d** ppRightBottom ///< point directly below the top-right flange tip
      );

      /// Points defining the bottom flange
      ///
      /// \image html BulbTee/BottomFlangePoints.png
      [helpstring("property GetBottomFlangePoints")]
      HRESULT GetBottomFlangePoints(
         [out]IPoint2d** ppLeftTop, ///< point directly above the bottom-left flange tip
         [out]IPoint2d** ppLeftBottom,  ///< point at bottom-left flange tip
         [out]IPoint2d** ppRightTop,  ///< point directly above the bottom-right flange tip
         [out]IPoint2d** ppRightBottom ///< point at bottom-right flange tip
      );

      /// Thickness of the top flange
      [helpstring("method GetTopFlangeThickness")]
      HRESULT GetTopFlangeThickness(
         [out]Float64* pHl, ///< Left flange tip
         [out]Float64* pHc, ///< At centerline of web
         [out]Float64* pHr  ///< Right flange tip
      );

      /// The XYPosition property
      [propget, helpstring("property XYPosition"), helpcontext(IDH_IBulbTee_XYPosition)]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget, helpstring("property Shape"), helpcontext(IDH_IBulbTee_Shape)]
      HRESULT Shape([out, retval] IShape* *pVal);
   };
   
   /// Object representing the cross section of a multi-web girder
   ///
   /// \image html MultiWeb/MultiWeb.jpg   
   [
		object,
		uuid(754A6B13-2256-41d9-8D48-B40E95C9A117),
		oleautomation,
		helpstring("IMultiWeb Interface"),
		helpcontext(IDH_IMultiWeb),
		pointer_default(unique)
	]
	interface IMultiWeb : IUnknown
	{
      /// Top flange overhang width
		[propget, helpstring("property W1"),helpcontext(IDH_IMultiWeb_W1)]
		HRESULT W1([out, retval] Float64 *pVal);

		[propput, helpstring("property W1"),helpcontext(IDH_IMultiWeb_W1)]
		HRESULT W1([in] Float64 newVal);

      /// Top width between webs
		[propget, helpstring("property W2"),helpcontext(IDH_IMultiWeb_W2)]
		HRESULT W2([out, retval] Float64 *pVal);

		[propput, helpstring("property W2"),helpcontext(IDH_IMultiWeb_W2)]
		HRESULT W2([in] Float64 newVal);

      /// Top flange depth
    	[propget, helpstring("property D1"),helpcontext(IDH_IMultiWeb_D1)]
		HRESULT D1([out, retval] Float64 *pVal);

		[propput, helpstring("property D1"),helpcontext(IDH_IMultiWeb_D1)]
		HRESULT D1([in] Float64 newVal);

      /// Web depth
    	[propget, helpstring("property D2"),helpcontext(IDH_IMultiWeb_D2)]
		HRESULT D2([out, retval] Float64 *pVal);

		[propput, helpstring("property D2"),helpcontext(IDH_IMultiWeb_D2)]
		HRESULT D2([in] Float64 newVal);

      /// Web width at top flange
    	[propget, helpstring("property T1"),helpcontext(IDH_IMultiWeb_T1)]
		HRESULT T1([out, retval] Float64 *pVal);

		[propput, helpstring("property T1"),helpcontext(IDH_IMultiWeb_T1)]
		HRESULT T1([in] Float64 newVal);

      /// Bottom of web width
    	[propget, helpstring("property T2"),helpcontext(IDH_IMultiWeb_T2)]
		HRESULT T2([out, retval] Float64 *pVal);

		[propput, helpstring("property T2"),helpcontext(IDH_IMultiWeb_T2)]
		HRESULT T2([in] Float64 newVal);

      /// Number of webs
    	[propget, helpstring("property WebCount"),helpcontext(IDH_IMultiWeb_WebCount)]
		HRESULT WebCount([out, retval] WebIndexType *pVal);

		[propput, helpstring("property WebCount"),helpcontext(IDH_IMultiWeb_WebCount)]
		HRESULT WebCount([in] WebIndexType newVal);

      /// Location of a web
		[propget, helpstring("property WebLocation"),helpcontext(IDH_IMultiWeb_WebLocation)]
		HRESULT WebLocation(
         [in]WebIndexType webIdx, ///< index of the web
         [out,retval]Float64* location ///< location of web measured horizontally from the hook point. Negative values are to the left of the hook point.
      );

      /// Hook point is located at intersection of the vertical centerline and the top of the top flange.
      [propget,  helpstring("property HookPoint"),helpcontext(IDH_IMultiWeb_HookPoint)]
		HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

      [propputref,  helpstring("property HookPoint"),helpcontext(IDH_IMultiWeb_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The overall height of the girder
      [propget,  helpstring("property Height"),helpcontext(IDH_IMultiWeb_Height)]
		HRESULT Height([out, retval] Float64 *pVal);

      /// Average of the web width dimensions
      [propget,  helpstring("property AvgWebWidth"),helpcontext(IDH_IMultiWeb_AvgWebWidth)]
		HRESULT AvgWebWidth([out, retval] Float64 *pVal);

      /// The overall width of the top flange
		[propget,  helpstring("property TopFlangeWidth"),helpcontext(IDH_IMultiWeb_TopFlangeWidth)]
		HRESULT TopFlangeWidth([out, retval] Float64 *pVal);

      /// The XYPosition property
      [propget,  helpstring("property XYPosition"),helpcontext(IDH_IMultiWeb_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget,  helpstring("property Shape"),helpcontext(IDH_IMultiWeb_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing the cross section of a multi-web girder
   ///
   /// \image html MultiWeb/MultiWeb2.jpg   
   [
      object,
	  uuid(12CBCFA5-F5C9-4a3b-A071-D277F72FD730),
	  oleautomation,
	  helpstring("IMultiWeb2 Interface"),
	  helpcontext(IDH_IMultiWeb2),
	  pointer_default(unique)
   ]
   interface IMultiWeb2 : IUnknown
   {
      /// Top flange overhang width
      [propget, helpstring("property W1"),helpcontext(IDH_IMultiWeb2_W1)]
		HRESULT W1([out, retval] Float64 *pVal);

		[propput, helpstring("property W1"),helpcontext(IDH_IMultiWeb2_W1)]
		HRESULT W1([in] Float64 newVal);

      /// Top width between webs
      [propget, helpstring("property W2"),helpcontext(IDH_IMultiWeb2_W2)]
		HRESULT W2([out, retval] Float64 *pVal);

		[propput, helpstring("property W2"),helpcontext(IDH_IMultiWeb2_W2)]
		HRESULT W2([in] Float64 newVal);

      /// Web depth
      [propget, helpstring("property H1"),helpcontext(IDH_IMultiWeb2_H1)]
		HRESULT H1([out, retval] Float64 *pVal);

		[propput, helpstring("property H1"),helpcontext(IDH_IMultiWeb2_H1)]
		HRESULT H1([in] Float64 newVal);

      /// Top flange depth dimension
      [propget, helpstring("property H2"),helpcontext(IDH_IMultiWeb2_H2)]
		HRESULT H2([out, retval] Float64 *pVal);

		[propput, helpstring("property H2"),helpcontext(IDH_IMultiWeb2_H2)]
		HRESULT H2([in] Float64 newVal);

      /// Top flange depth dimension
      [propget, helpstring("property H3"),helpcontext(IDH_IMultiWeb2_H3)]
		HRESULT H3([out, retval] Float64 *pVal);

		[propput, helpstring("property H3"),helpcontext(IDH_IMultiWeb2_H3)]
		HRESULT H3([in] Float64 newVal);

      /// Exterior web width dimension
		[propget, helpstring("property T1"),helpcontext(IDH_IMultiWeb2_T1)]
		HRESULT T1([out, retval] Float64 *pVal);

		[propput, helpstring("property T1"),helpcontext(IDH_IMultiWeb2_T1)]
		HRESULT T1([in] Float64 newVal);

      /// Exterior web width dimension
      [propget, helpstring("property T2"),helpcontext(IDH_IMultiWeb2_T2)]
		HRESULT T2([out, retval] Float64 *pVal);

		[propput, helpstring("property T2"),helpcontext(IDH_IMultiWeb2_T2)]
		HRESULT T2([in] Float64 newVal);

      /// Exterior web width dimension
      [propget, helpstring("property T3"),helpcontext(IDH_IMultiWeb2_T3)]
		HRESULT T3([out, retval] Float64 *pVal);

		[propput, helpstring("property T3"),helpcontext(IDH_IMultiWeb2_T3)]
		HRESULT T3([in] Float64 newVal);

      /// Interior web width dimension
      [propget, helpstring("property T4"),helpcontext(IDH_IMultiWeb2_T4)]
		HRESULT T4([out, retval] Float64 *pVal);

		[propput, helpstring("property T4"),helpcontext(IDH_IMultiWeb2_T4)]
		HRESULT T4([in] Float64 newVal);

      /// Interior web width dimension
      [propget, helpstring("property T5"),helpcontext(IDH_IMultiWeb2_T5)]
		HRESULT T5([out, retval] Float64 *pVal);

      /// Interior web width dimension
      [propput, helpstring("property T5"),helpcontext(IDH_IMultiWeb2_T5)]
		HRESULT T5([in] Float64 newVal);

      /// Exterior fillet dimension
		[propget, helpstring("property F1"),helpcontext(IDH_IMultiWeb2_F1)]
		HRESULT F1([out, retval] Float64 *pVal);

		[propput, helpstring("property F1"),helpcontext(IDH_IMultiWeb2_F1)]
		HRESULT F1([in] Float64 newVal);

      /// Interior fillet dimension
      [propget, helpstring("property F2"),helpcontext(IDH_IMultiWeb2_F2)]
		HRESULT F2([out, retval] Float64 *pVal);

		[propput, helpstring("property F2"),helpcontext(IDH_IMultiWeb2_F2)]
		HRESULT F2([in] Float64 newVal);

      /// Bottom of web chamfer dimensino
      [propget, helpstring("property C1"),helpcontext(IDH_IMultiWeb2_C1)]
		HRESULT C1([out, retval] Float64 *pVal);

		[propput, helpstring("property C1"),helpcontext(IDH_IMultiWeb2_C1)]
		HRESULT C1([in] Float64 newVal);

      /// Top flange bevel dimension
		[propget, helpstring("property C2"),helpcontext(IDH_IMultiWeb2_C2)]
		HRESULT C2([out, retval] Float64 *pVal);

		[propput, helpstring("property C2"),helpcontext(IDH_IMultiWeb2_C2)]
		HRESULT C2([in] Float64 newVal);

      /// Number of webs
    	[propget, helpstring("property WebCount"),helpcontext(IDH_IMultiWeb2_WebCount)]
		HRESULT WebCount([out, retval] WebIndexType *pVal);

		[propput, helpstring("property WebCount"),helpcontext(IDH_IMultiWeb2_WebCount)]
		HRESULT WebCount([in] WebIndexType newVal);

      /// Location of a web
      [propget, helpstring("property WebLocation"),helpcontext(IDH_IMultiWeb2_WebLocation)]
		HRESULT WebLocation(
         [in]WebIndexType webIdx, ///< index of the web
         [out,retval]Float64* location ///< location of web measured horizontally from the hook point. Negative values are to the left of the hook point.
      );

      /// Hook point is located at intersection of the vertical centerline and the top of the top flange.
      [propget,  helpstring("property HookPoint"),helpcontext(IDH_IMultiWeb2_HookPoint)]
		HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

        [propputref,  helpstring("property HookPoint"),helpcontext(IDH_IMultiWeb2_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// The overall height of the girder
      [propget,  helpstring("property Height"),helpcontext(IDH_IMultiWeb2_Height)]
		HRESULT Height([out, retval] Float64 *pVal);

      /// The overall width of the top flange
      [propget,  helpstring("property TopFlangeWidth"),helpcontext(IDH_IMultiWeb2_TopFlangeWidth)]
		HRESULT TopFlangeWidth([out, retval] Float64 *pVal);

      /// Average of the web width dimensions
      [propget,  helpstring("property AvgWebWidth"),helpcontext(IDH_IMultiWeb2_AvgWebWidth)]
		HRESULT AvgWebWidth([in] WebIndexType webIdx,[out, retval] Float64 *pVal);

      /// Property indicating if the bevel on the left flange tip is used
      [propput,helpstring("property LeftBlockOut")/*,helpcontext(IDH_IMultiWeb2_LeftBlockOut)*/]
      HRESULT LeftBlockOut([in]VARIANT_BOOL bLeftBlockOut);

      [propget,helpstring("property LeftBlockOut")/*,helpcontext(IDH_IMultiWeb2_LeftBlockOut)*/]
      HRESULT LeftBlockOut([out,retval]VARIANT_BOOL* pbLeftBlockOut);

      /// Property indicating if the bevel on the right flange tip is used
      [propput,helpstring("property RightBlockOut")/*,helpcontext(IDH_IMultiWeb2_RightBlockOut)*/]
      HRESULT RightBlockOut([in]VARIANT_BOOL bRightBlockOut);

      [propget,helpstring("property RightBlockOut")/*,helpcontext(IDH_IMultiWeb2_RightBlockOut)*/]
      HRESULT RightBlockOut([out,retval]VARIANT_BOOL* pbRightBlockOut);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"), helpcontext(IDH_IMultiWeb2_XYPosition)]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget, helpstring("property Shape"), helpcontext(IDH_IMultiWeb2_Shape)]
      HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing the shape of a traffic barrier
   ///
   /// \image html TrafficBarrier/TrafficBarrier.jpg   	
   [
		object,
		uuid(2558CFC1-03CE-11D3-8CDF-EBFB6612CA35),
		oleautomation,
		helpstring("ITrafficBarrier Interface"),
		helpcontext(IDH_ITrafficBarrier),
		pointer_default(unique)
	]
	interface ITrafficBarrier : IUnknown
	{
      /// A dimension of the barrier
		[propget, helpstring("property X1"),helpcontext(IDH_ITrafficBarrier_X1)]
		HRESULT X1([out, retval] Float64 *pVal);

		[propput, helpstring("property X1"),helpcontext(IDH_ITrafficBarrier_X1)]
		HRESULT X1([in] Float64 newVal);

      /// A dimension of the barrier
      [propget, helpstring("property X2"),helpcontext(IDH_ITrafficBarrier_X2)]
		HRESULT X2([out, retval] Float64 *pVal);

		[propput, helpstring("property X2"),helpcontext(IDH_ITrafficBarrier_X2)]
		HRESULT X2([in] Float64 newVal);

      /// A dimension of the barrier
      [propget, helpstring("property X3"),helpcontext(IDH_ITrafficBarrier_X3)]
		HRESULT X3([out, retval] Float64 *pVal);

		[propput, helpstring("property X3"),helpcontext(IDH_ITrafficBarrier_X3)]
		HRESULT X3([in] Float64 newVal);

      /// A dimension of the barrier
      [propget, helpstring("property X4"),helpcontext(IDH_ITrafficBarrier_X4)]
		HRESULT X4([out, retval] Float64 *pVal);

		[propput, helpstring("property X4"),helpcontext(IDH_ITrafficBarrier_X4)]
		HRESULT X4([in] Float64 newVal);

      /// A dimension of the barrier
      [propget, helpstring("property X5"),helpcontext(IDH_ITrafficBarrier_X5)]
		HRESULT X5([out, retval] Float64 *pVal);

		[propput, helpstring("property X5"),helpcontext(IDH_ITrafficBarrier_X5)]
		HRESULT X5([in] Float64 newVal);

      /// A dimension of the barrier
      [propget, helpstring("property Y1"),helpcontext(IDH_ITrafficBarrier_Y1)]
		HRESULT Y1([out, retval] Float64 *pVal);

		[propput, helpstring("property Y1"),helpcontext(IDH_ITrafficBarrier_Y1)]
		HRESULT Y1([in] Float64 newVal);

      /// A dimension of the barrier
      [propget, helpstring("property Y2"),helpcontext(IDH_ITrafficBarrier_Y2)]
		HRESULT Y2([out, retval] Float64 *pVal);

		[propput, helpstring("property Y2"),helpcontext(IDH_ITrafficBarrier_Y2)]
		HRESULT Y2([in] Float64 newVal);

      /// A dimension of the barrier
      [propget, helpstring("property Y3"),helpcontext(IDH_ITrafficBarrier_Y3)]
		HRESULT Y3([out, retval] Float64 *pVal);

		[propput, helpstring("property Y3"),helpcontext(IDH_ITrafficBarrier_Y3)]
		HRESULT Y3([in] Float64 newVal);

      /// A dimension of the barrier
      [propget, helpstring("property Y4"),helpcontext(IDH_ITrafficBarrier_Y4)]
		HRESULT Y4([out, retval] Float64 *pVal);

		[propput, helpstring("property Y4"),helpcontext(IDH_ITrafficBarrier_Y4)]
		HRESULT Y4([in] Float64 newVal);

      /// Hook point is located at the point coincident with the top exterior point of the item that the barrier connects with.
      [propget, helpstring("property HookPoint"),helpcontext(IDH_ITrafficBarrier_HookPoint)]
		HRESULT HookPoint([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property HookPoint"),helpcontext(IDH_ITrafficBarrier_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* newVal);

      /// Orientation of the barrier
		[propget, helpstring("property Orientation"),helpcontext(IDH_ITrafficBarrier_Orientation)]
		HRESULT Orientation([out, retval] TrafficBarrierOrientation *pVal);

		[propput, helpstring("property Orientation"),helpcontext(IDH_ITrafficBarrier_Orientation)]
		HRESULT Orientation([in] TrafficBarrierOrientation newVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_ITrafficBarrier_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_ITrafficBarrier_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Interface for 2D geometric utility methods
	[
		object,
		uuid(110FFB8A-2B04-11D3-8952-006097C68A9C),
		oleautomation,
		helpstring("IGeomUtil2d Interface"),
		helpcontext(IDH_IGeomUtil2d),
		pointer_default(unique)
	]
	interface IGeomUtil2d : IUnknown
	{
      /// Generates a collection of points in a circle
		[helpstring("method GenerateCircle"),helpcontext(IDH_IGeomUtil2d_GenerateCircle)]
		HRESULT GenerateCircle(
         [in] IndexType nPoints, ///< number of points to generate
         [in] IPoint2d* center, ///< center of the circle
         [in] Float64 radius,  ///< radius of the circle
         [in,defaultvalue(0.00)] Float64 initAngle, ///< Counter-clockwise angle from the positive X-axis, measured in radians, that determines where the first point is located.
         [out,retval] IPoint2dCollection** points ///< The collection of points generated points
      );

      /// Computes the angle formed by three points
      /// \image html GeomUtil2d/Angle.jpg
		[helpstring("method Angle"),helpcontext(IDH_IGeomUtil2d_Angle)]
		HRESULT Angle(
         [in] IPoint2d* pStart, ///< start point
         [in] IPoint2d* pCenter, ///< vertex of the angle
         [in] IPoint2d* pEnd, ///< end point
         [out,retval] Float64* angle ///< angle, measured in radians
      );

      /// Computes the shortest offset between a line and a point
      /// \image html GeomUtil2d/ShortestOffsetToPoint.jpg
		[helpstring("method ShortestOffsetToPoint"),helpcontext(IDH_IGeomUtil2d_ShortestOffsetToPoint)]
		HRESULT ShortestOffsetToPoint(
         [in] ILine2d* pLine, ///< a line
         [in] IPoint2d* pPoint, ///< a point
         [out,retval] Float64* pOffset ///< shortest offset between the line and the point. Negative values indicate the point is to the left of the line.
      );

      /// Locates the point on a line nearest a specified point
      /// \image html GeomUtil2d/PointOnLineNearest.jpg
		[helpstring("method PointOnLineNearest"),helpcontext(IDH_IGeomUtil2d_PointOnLineNearest)]
		HRESULT PointOnLineNearest(
         [in] ILine2d* pLine, ///< a line
         [in] IPoint2d* pPoint,  ///< a point
         [out,retval] IPoint2d** ppPOLN ///< the point on the line that is nearest to pPoint
      );

      /// Creates a line parallel to the specified line, and passing through a specified point. The parallel line has the same direction as the specified line.
      /// \image html GeomUtil2d/CreateParallelLineThroughPoint.jpg
		[helpstring("method CreateParallelLineThroughPoint"),helpcontext(IDH_IGeomUtil2d_CreateParallelLineThroughPoint)]
		HRESULT CreateParallelLineThroughPoint(
         [in] ILine2d* pLine, ///< a line
         [in] IPoint2d* pPoint, ///< the point the parallel line passes through
         [out,retval] ILine2d** ppLine ///< the new parallel line
      );

      /// Creates a line that is parallel to the specified line.
		[helpstring("method CreateParallelLine"),helpcontext(IDH_IGeomUtil2d_CreateParallelLine)]
		HRESULT CreateParallelLine(
         [in] ILine2d* pLine, ///< the source line
         [in] Float64 dist, ///< Distance to offset the parallel line from the source line. The parallel line will be on the right side of the source line if this parameter is greater than zero.
         [out,retval]ILine2d** ppLine ///< the new parallel line
      );

      /// Creates a line normal to the specified line, and passing through a specified point. The normal line is directed to the right of the specified line.
      /// \image html GeomUtil2d/CreateNormalLineThroughPoint.jpg
		[helpstring("method CreateNormalLineThroughPoint"),helpcontext(IDH_IGeomUtil2d_CreateNormalLineThroughPoint)]
		HRESULT CreateNormalLineThroughPoint(
         [in] ILine2d* pLine, ///< the source line
         [in] IPoint2d* pPoint, ///< The point that the normal line passes through
         [out,retval] ILine2d** ppLine ///< The normal line
      );

      /// Divides an arch segment into equal length pieces.
      /// The coordinates of N - 1 points are computed, where N is the number of spaces.
      /// \image html GeomUtil2d/DivideArc.jpg
      [helpstring("method DivideArc"),helpcontext(IDH_IGeomUtil2d_DivideArc)]
		HRESULT DivideArc(
         [in] IPoint2d* pStart, ///< point defining the start of the arc
         [in] IPoint2d* pCenter, ///< vertex point at the center of the arc
         [in] IPoint2d* pEnd, ///< point defining the end of the arc
         [in] IndexType nSpaces, ///< the number of spaces between end points
         [out,retval] IPoint2dCollection** ppPoints ///< collection containing the points
      );

      /// Finds the intersection of two lines.
      /// If an intersection point cannot be found or the lines are coincident, the resulting point is nullptr
		[helpstring("method LineLineIntersect"),helpcontext(IDH_IGeomUtil2d_LineLineIntersect)]
		HRESULT LineLineIntersect(
         [in] ILine2d* l1, ///< the first line
         [in] ILine2d* l2, ///< the second line
         [out,retval] IPoint2d** ppPoint ///< the intersection point.
      );

      /// Finds the intersection of two line segments.
      /// If an intersection point cannot be found or the line segments are coincident, the resulting point is nullptr
      [helpstring("method SegSegIntersect"),helpcontext(IDH_IGeomUtil2d_SegSegIntersect)]
		HRESULT SegSegIntersect(
         [in] ILineSegment2d* pSeg1, ///< the first line segment
         [in] ILineSegment2d* pSeg2, ///< the second line segment
         [out,retval] IPoint2d** ppPoint ///< the intersection point
      );

      /// Finds the intersection of a line and a line segment.
      /// If an intersection point cannot be found or the line and line segment are coincident, the result point is nullptr
		[helpstring("method IntersectLineWithLineSegment"),helpcontext(IDH_IGeomUtil2d_IntersectLineWithLineSegment)]
		HRESULT IntersectLineWithLineSegment([in] ILine2d* pLine,[in] ILineSegment2d* pSeg,[out,retval] IPoint2d** ppPoint);

      /// Finds the intersection of a line and a circle.
      /// If there are not intersection points, p1 and p2 are nullptr
		[helpstring("method LineCircleIntersect"),helpcontext(IDH_IGeomUtil2d_LineCircleIntersect)]
		HRESULT LineCircleIntersect(
         [in] ILine2d *line, ///< the line
         [in] ICircle* circle, ///< the circle
         [out] IPoint2d** p1, ///< the first intersection point
         [out] IPoint2d** p2, ///< the second intersection point
         [out,retval] short* nIntersect ///< the number of intersections found
      );

      /// Finds the intersection of two circles.
      /// If the number of intersections is zero, p1 and p2 are nullptr. If only one intersection was found, p2 is nullptr.
      /// If circle1 and circle2 have the same center and radius, p1 and p2 are nullptr and the number of intersections points is set to 3
		[helpstring("method CircleCircleIntersect"),helpcontext(IDH_IGeomUtil2d_CircleCircleIntersect)]
		HRESULT CircleCircleIntersect(
         [in] ICircle *circle1, ///< the first circle
         [in] ICircle* circle2, ///< the second circle
         [out] IPoint2d** p1, ///< the first intersection point
         [out] IPoint2d** p2, ///< the second intersection point
         [out,retval] short* nIntersect ///< the number of intersection points (this is set to 3 if there is an infinite number of intersection points)
      );

      /// Tests if two lines are parallel. The lines can be in opposite directions.
		[helpstring("method AreLinesParallel"),helpcontext(IDH_IGeomUtil2d_AreLinesParallel)]
		HRESULT AreLinesParallel(
         [in] ILine2d* pLine1, ///< the first line
         [in] ILine2d* pLine2, ///< the second line
         [out,retval] VARIANT_BOOL* pbResult ///< the result of the comparison, VARIANT_TRUE if the lines are parallel, otherwise VARIANT_FALSE
      );

      /// Tests if two lines are parallel and in the same direction
      [helpstring("method IsSameDirection")]
      HRESULT IsSameDirection(
         [in] ILine2d* pLine1, ///< the first line
         [in] ILine2d* pLine2, ///< the second line
         [out, retval] VARIANT_BOOL* pbResult ///< the result of the comparison, VARIANT_TRUE if the lines are parallel and in the same direction, otherwise VARIANT_FALSE
      );

      /// Tests if two line segments are parallel.
      [helpstring("method AreLineSegmentsParallel"),helpcontext(IDH_IGeomUtil2d_AreLineSegmentsParallel)]
		HRESULT AreLineSegmentsParallel(
         [in] ILineSegment2d* pSeg1, ///< the first line segment
         [in] ILineSegment2d* pSeg2, ///< the second line segment
         [out,retval] VARIANT_BOOL* pbResult ///< the result of the comparison, VARIANT_TRUE if the line segments are parallel, otherwise VARIANT_FALSE
      );

      /// Tests if a line is parallel to a line segment.
		[helpstring("method IsLineParallelToLineSegment"),helpcontext(IDH_IGeomUtil2d_IsLineParallelToLineSegment)]
		HRESULT IsLineParallelToLineSegment(
         [in] ILine2d* pLine, ///< the line
         [in] ILineSegment2d* pSeg, ///< the line segment
         [out,retval] VARIANT_BOOL* pbResult ///< the result of the comparison, VARIANT_TRUE if the line and line segment are parallel, otherwise VARIANT_FALSE
      );

      /// Creates a line segment that is parallel to the specified line segment.
      /// \image html GeomUtil2d/CreateParallelLineSegment.jpg
     [helpstring("method CreateParallelLineSegment"),helpcontext(IDH_IGeomUtil2d_CreateParallelLineSegment)]
		HRESULT CreateParallelLineSegment(
         [in] ILineSegment2d* pSeg, ///< the source line segment
         [in] Float64 offset, ///< Distance to offset the parallel line segment from the source line segment. The parallel line segment will be on the right side of the source line segment if this parameter is greater than zero.
         [out,retval] ILineSegment2d** pNewSeg ///< the parallel line segment
      );

      /// Tests if a point is contained within a triangle defined by three non-coincident points
      [helpstring("method PointInTriangle")]
      HRESULT PointInTriangle(
         [in]IPoint2d* p, ///< the point
         [in]IPoint2d* pA, ///< point at a vertex of the triangle
         [in]IPoint2d* pB, ///< point at a vertex of the triangle
         [in]IPoint2d* pC, ///< point at a vertex of the triangle
         [out,retval]VARIANT_BOOL* pbResult ///< the result of the comparison, VARIANT_TRUE if the point is in the triangle, otherwise VARIANT_FALSE
      );
	};

   /// Interface for an object that provides utility functions
   ///
   /// The factory objects assigned to this object are used whenever new objects need to be created.
	[
	   object,
	   uuid(1B9B8520-C46E-11d3-8A19-006097C68A9C),
	   oleautomation,
	   helpstring("IGeomUtil Interface"),
	   helpcontext(IDH_IGeomUtil),
	   pointer_default(unique)
	]
	interface IGeomUtil : IUnknown
	{
      /// 2D geometric utilities object
		[propget,helpstring("property Geom2d"),helpcontext(IDH_IGeomUtil_Geom2d)]
		HRESULT Geom2d([out,retval] IGeomUtil2d** util);
	};

   /// Interface for object that performs 3D coordinate transformations
   ///
   /// \f[ \overrightarrow{P'} = \left[ \left( \overrightarrow{P} - \overrightarrow{T} \right) \cdot \overrightarrow{n} \right] \overrightarrow{n}(1 - \cos \theta) + \left[ \left( \overrightarrow{P} - \overrightarrow{T} \right) \cos(\theta) \times \overrightarrow{n} \right] \sin \theta \f]
   /// \f[ \overrightarrow{P} = \left[ \left( \overrightarrow{P'} \cdot \overrightarrow{n} \right) \overrightarrow{n} (1 - \cos \theta) \right] + \overrightarrow{P'} \cos\theta + \left( \overrightarrow{P'} \times \overrightarrow{n} \right) \sin(-\theta) + \overrightarrow{T} \f]
   ///
   /// where
   ///
   /// \f$ \overrightarrow{P'} = \f$ point in the new coordinate system
   ///
   /// \f$ \overrightarrow{P} = \f$ point in the old coordinate system
   ///
   /// \f$ \overrightarrow{T'} = \f$ origin of the new coordinate system
   ///
   /// \f$ \theta = \f$ rotation angle
   [
		object,
		uuid(D146B4A4-5103-11D3-8CDF-BFEA3D98042F),
		oleautomation,
		helpstring("ICoordinateXform3d Interface"),
		helpcontext(IDH_ICoordinateXform3d),
		pointer_default(unique)
	]
	interface ICoordinateXform3d : IUnknown
	{
      /// Location of the origin of the new coordinate system.
		[propget, helpstring("property NewOrigin"),helpcontext(IDH_ICoordinateXform3d_NewOrigin)]
		HRESULT NewOrigin([out, retval] IPoint3d **pVal);

		[propput, helpstring("property NewOrigin"),helpcontext(IDH_ICoordinateXform3d_NewOrigin)]
		HRESULT NewOrigin([in] IPoint3d *newVal);

      /// Rotation angle of the new coordinate system. The new coordinate system is rotated about the RotationVector. The rotation angle is measured in Radians. A positive rotation follows the Right Hand Rule.
		[propget, helpstring("property RotationAngle"),helpcontext(IDH_ICoordinateXform3d_RotationAngle)]
		HRESULT RotationAngle([out, retval] Float64 *pVal);

		[propput, helpstring("property RotationAngle"),helpcontext(IDH_ICoordinateXform3d_RotationAngle)]
		HRESULT RotationAngle([in] Float64 newVal);

      /// Unit vector that describes that axis around which the new coordinate system is rotated.
		[propget, helpstring("property RotationVector"),helpcontext(IDH_ICoordinateXform3d_RotationVector)]
		HRESULT RotationVector([out, retval] IVector3d **pVal);

		[propput, helpstring("property RotationVector"),helpcontext(IDH_ICoordinateXform3d_RotationVector)]
		HRESULT RotationVector([in] IVector3d *newVal);

      /// Transforms the coordinates of a point. Coordinate transformation can be from the original system to the new system or from the new system to the original system.
      [helpstring("method Xform"),helpcontext(IDH_ICoordinateXform3d_Xform)]
		HRESULT Xform(
         [in,out] IPoint3d** point, ///< the point to be transformed
         [in] XformType type ///< the type of transformation. If type is xfrmOldToNew, point is in the original coordinate system and it is transformed into the new coordinate system. If type is xfrmNewToOld, point is in the new coordinate system and it is transformed into the original system.
      );

      /// Creates a new point by transforming the coordinates of a point. Coordinate transformation can be from the original system to the new system or from the new system to the original system.
      [helpstring("method XformEx"),helpcontext(IDH_ICoordinateXform3d_XformEx)]
		HRESULT XformEx(
         [in] IPoint3d* point, ///< the original point
         [in] XformType type, ///< the type of transformation. If type is xfrmOldToNew, point is in the original coordinate system and it is transformed into the new coordinate system. If type is xfrmNewToOld, point is in the new coordinate system and it is transformed into the original system.
         [out,retval] IPoint3d** result ///< the resulting point
      );
   };

   /// Interface for object that performs 2D coordinate transformations
   ///
   /// \image html CoordinateXform2d/CoordinateXform2d.jpg
   /// Original to New
   ///
   /// \f[ x' = (x - x_o)\cos\theta + (y - y_o)\sin\theta \f]
   /// \f[ y' = -(x - x_o)\sin\theta + (y - y_o)\cos\theta \f]
   ///
   /// New to Original
   ///
   /// \f[ x = x'\cos\theta - y'\sin\theta + x_o \f]
   /// \f[ y = x'\sin\theta + y'\cos\theta + y_o \f]
   [
		object,
		uuid(1A1AD39B-5184-11D3-8985-006097C68A9C),
		oleautomation,
		helpstring("ICoordinateXform2d Interface"),
		helpcontext(IDH_ICoordinateXform2d),
		pointer_default(unique)
	]
	interface ICoordinateXform2d : IUnknown
	{
      /// Origin of the new coordinate system.
		[propget, helpstring("property NewOrigin"),helpcontext(IDH_ICoordinateXform2d_NewOrigin)]
		HRESULT NewOrigin([out, retval] IPoint2d* *pVal);

		[propput, helpstring("property NewOrigin"),helpcontext(IDH_ICoordinateXform2d_NewOrigin)]
		HRESULT NewOrigin([in] IPoint2d* newVal);

      /// Rotation angle of the new coordinate system. The rotation angle is measured counter-clockwise from the positive X axis, in radians.
		[propget, helpstring("property RotationAngle"),helpcontext(IDH_ICoordinateXform2d_RotationAngle)]
		HRESULT RotationAngle([out, retval] Float64 *pVal);

		[propput, helpstring("property RotationAngle"),helpcontext(IDH_ICoordinateXform2d_RotationAngle)]
		HRESULT RotationAngle([in] Float64 newVal);

      /// Transforms the coordinates of a point. Coordinate transformation can be from the original system to the new system or from the new system to the original system.
      [helpstring("method Xform"),helpcontext(IDH_ICoordinateXform2d_Xform)]
		HRESULT Xform(
         [in,out] IPoint2d** point, ///< the point to be transformed
         [in] XformType type ///< the type of transformation. If type is xfrmOldToNew, point is in the original coordinate system and it is transformed into the new coordinate system. If type is xfrmNewToOld, point is in the new coordinate system and it is transformed into the original system.
      );

      /// Creates a new point by transforming the coordinates of a point. Coordinate transformation can be from the original system to the new system or from the new system to the original system.
      [helpstring("method XformEx"),helpcontext(IDH_ICoordinateXform2d_XformEx)]
		HRESULT XformEx(
         [in] IPoint2d* point, ///< the original point
         [in] XformType type, ///< the type of transformation. If type is xfrmOldToNew, point is in the original coordinate system and it is transformed into the new coordinate system. If type is xfrmNewToOld, point is in the new coordinate system and it is transformed into the original system.
         [out, retval] IPoint2d** result ///< the resulting point
      );
   };

   /// Object representing a circular segment
   ///
   /// \image html CircularSegment/CircularSegment.jpg
   ///
   /// \f[ \alpha (radians) \f]
   /// \f[ A = r^2 \left(\alpha - \frac{\sin 2\alpha}{2} \right) \f]
   /// \f[ \overline{x} = \frac{4r}{3} \frac{\sin^3\alpha}{2\alpha-\sin 2\alpha} \f]
   /// \f[ \overline{y} = 0 \f]
   /// \f[ I_x = \frac{Ar^2}{4} \left(1 - \frac{4\sin^3\alpha\cos\alpha}{3(2\alpha-\sin2\alpha)} \right) \f]
   /// \f[ I_y = \frac{Ar^2}{4} \left(1 + \frac{4\sin^3\alpha\cos\alpha}{2\alpha-\sin2\alpha} \right) \f]
   [
		object,
		uuid(C6C2A640-6563-11D4-8CE4-0080C7380027),
		oleautomation,
		helpstring("ICircularSegment Interface"),
		helpcontext(IDH_ICircularSegment),
		pointer_default(unique)
	]
	interface ICircularSegment : IUnknown
	{
      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_ICircularSegment_Shape)]
		HRESULT Shape([out, retval] IShape* *pVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_ICircularSegment_XYPosition)]
		HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The hook point is located at the mid-point of the chord
		[propget, helpstring("property HookPoint"),helpcontext(IDH_ICircularSegment_HookPoint)]
		HRESULT HookPoint([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property HookPoint"),helpcontext(IDH_ICircularSegment_HookPoint)]
		HRESULT HookPoint([in] IPoint2d* newVal);

      /// Radius of the circle
		[propget, helpstring("property Radius"),helpcontext(IDH_ICircularSegment_Radius)]
		HRESULT Radius([out, retval] Float64 *pVal);

		[propput, helpstring("property Radius"),helpcontext(IDH_ICircularSegment_Radius)]
		HRESULT Radius([in] Float64 newVal);

      /// Center point of the circle
		[propget, helpstring("property Center"),helpcontext(IDH_ICircularSegment_Center)]
		HRESULT Center([out, retval] IPoint2d* *pVal);

		[propput, helpstring("property Center"),helpcontext(IDH_ICircularSegment_Center)]
		HRESULT Center([in] IPoint2d* newVal);

      /// Mid-ordinate dimension
		[propget, helpstring("property MidOrdinate"),helpcontext(IDH_ICircularSegment_MidOrdinate)]
		HRESULT MidOrdinate([out, retval] Float64 *pVal);

		[propput, helpstring("property MidOrdinate"),helpcontext(IDH_ICircularSegment_MidOrdinate)]
		HRESULT MidOrdinate([in] Float64 newVal);

      /// Interior angle formed by the radius lines
		[propget, helpstring("property InteriorAngle"),helpcontext(IDH_ICircularSegment_InteriorAngle)]
		HRESULT InteriorAngle([out, retval] Float64 *pVal);

		[propput, helpstring("property InteriorAngle"),helpcontext(IDH_ICircularSegment_InteriorAngle)]
		HRESULT InteriorAngle([in] Float64 newVal);

      /// Rotation of the shape from the x-axis, measured in radians, increasing counter-clockwise from the X-axis
		[propget, helpstring("property Rotation"),helpcontext(IDH_ICircularSegment_Rotation)]
		HRESULT Rotation([out, retval] Float64 *pVal);

		[propput, helpstring("property Rotation"),helpcontext(IDH_ICircularSegment_Rotation)]
		HRESULT Rotation([in] Float64 newVal);

      [propget,helpstring("property Chord")]
      HRESULT Chord([out, retval]ILineSegment2d** ppChord);
   };

   /// Object representing a built-up steel plate girder
   ///
   /// \image html PlateGirder/PlateGirder.jpg
   [
		object,
		uuid(9F28211D-09D6-11D5-8BBF-006097C68A9C),
		oleautomation,
		helpstring("IPlateGirder Interface"),
      helpcontext(IDH_IPlateGirder),
		pointer_default(unique)
	]
	interface IPlateGirder : IUnknown
	{
      /// Top flange width
		[propget, helpstring("property TopFlangeWidth"),helpcontext(IDH_IPlateGirder_TopFlangeWidth)]
      HRESULT TopFlangeWidth([out, retval] Float64 *pVal);

		[propput, helpstring("property TopFlangeWidth"),helpcontext(IDH_IPlateGirder_TopFlangeWidth)]
      HRESULT TopFlangeWidth([in] Float64 newVal);

      /// Top flange thickness
      [propget, helpstring("property TopFlangeThickness"),helpcontext(IDH_IPlateGirder_TopFlangeThickness)]
      HRESULT TopFlangeThickness([out, retval] Float64 *pVal);

		[propput, helpstring("property TopFlangeThickness"),helpcontext(IDH_IPlateGirder_TopFlangeThickness)]
      HRESULT TopFlangeThickness([in] Float64 newVal);

      /// Bottom flange width
		[propget, helpstring("property BottomFlangeWidth"),helpcontext(IDH_IPlateGirder_BottomFlangeWidth)]
      HRESULT BottomFlangeWidth([out, retval] Float64 *pVal);

		[propput, helpstring("property BottomFlangeWidth"),helpcontext(IDH_IPlateGirder_BottomFlangeWidth)]
      HRESULT BottomFlangeWidth([in] Float64 newVal);

      /// Bottom flange thickness
      [propget, helpstring("property BottomFlangeThickness"),helpcontext(IDH_IPlateGirder_BottomFlangeThickness)]
      HRESULT BottomFlangeThickness([out, retval] Float64 *pVal);

		[propput, helpstring("property BottomFlangeThickness"),helpcontext(IDH_IPlateGirder_BottomFlangeThickness)]
      HRESULT BottomFlangeThickness([in] Float64 newVal);

      /// Web height
		[propget, helpstring("property WebHeight"),helpcontext(IDH_IPlateGirder_WebHeight)]
      HRESULT WebHeight([out, retval] Float64 *pVal);

		[propput, helpstring("property WebHeight"),helpcontext(IDH_IPlateGirder_WebHeight)]
      HRESULT WebHeight([in] Float64 newVal);

      /// Web width
      [propget, helpstring("property WebWidth"),helpcontext(IDH_IPlateGirder_WebWidth)]
      HRESULT WebWidth([out, retval] Float64 *pVal);

		[propput, helpstring("property WebWidth"),helpcontext(IDH_IPlateGirder_WebWidth)]
      HRESULT WebWidth([in] Float64 newVal);

      /// Overall height of the cross section
		[propget, helpstring("property Height"),helpcontext(IDH_IPlateGirder_Height)]
      HRESULT Height([out, retval] Float64 *pVal);

      /// First moment of area of the top flange
		[propget, helpstring("property QTopFlange"),helpcontext(IDH_IPlateGirder_QTopFlange)]
      HRESULT QTopFlange([out, retval] Float64 *pVal);

      /// First moment of area of the bottom flange
      [propget, helpstring("property QBottomFlange"),helpcontext(IDH_IPlateGirder_QBottomFlange)]
      HRESULT QBottomFlange([out, retval] Float64 *pVal);

      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_IPlateGirder_Shape)]
      HRESULT Shape([out, retval] IShape* *pVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_IPlateGirder_XYPosition)]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// Hook point is at the intersection of the centerline of the web and the bottom of the bottom flange
		[propget, helpstring("property HookPoint"),helpcontext(IDH_IPlateGirder_HookPoint)]
      HRESULT HookPoint([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property HookPoint"),helpcontext(IDH_IPlateGirder_HookPoint)]
      HRESULT HookPoint([in] IPoint2d* newVal);
   };

   /// Object representing the cross section of a U-Beam girder
   ///
   /// \image html UBeam/UBeam.jpg   
   [
		object,
		uuid(231FB083-6FBE-417D-93E2-90C5FE345249),
		oleautomation,
      helpcontext(IDH_IUBeam),
		helpstring("IUBeam Interface"),
		pointer_default(unique)
	]
	interface IUBeam : IUnknown
	{
      /// Bottom width
		[propget, helpstring("property W1"),helpcontext(IDH_IUBeam_W1)] 
      HRESULT W1([out, retval] Float64 *pVal);

		[propput, helpstring("property W1"),helpcontext(IDH_IUBeam_W1)] 
      HRESULT W1([in] Float64 newVal);

      /// Out-to-out top width
		[propget, helpstring("property W2"),helpcontext(IDH_IUBeam_W2)] 
      HRESULT W2([out, retval] Float64 *pVal);

		[propput, helpstring("property W2"),helpcontext(IDH_IUBeam_W2)] 
      HRESULT W2([in] Float64 newVal);

      /// Width of web-bottom plate taper
		[propget, helpstring("property W3"),helpcontext(IDH_IUBeam_W3)] 
      HRESULT W3([out, retval] Float64 *pVal);

		[propput, helpstring("property W3"),helpcontext(IDH_IUBeam_W3)] 
      HRESULT W3([in] Float64 newVal);

      /// Width of inside edge of top flange
		[propget, helpstring("property W4"),helpcontext(IDH_IUBeam_W4)] 
      HRESULT W4([out, retval] Float64 *pVal);

		[propput, helpstring("property W4"),helpcontext(IDH_IUBeam_W4)] 
      HRESULT W4([in] Float64 newVal);

      /// Width of outside edge of top flange
      [propget, helpstring("property W5"),helpcontext(IDH_IUBeam_W5)]
      HRESULT W5([out, retval] Float64 *pVal);

		[propput, helpstring("property W5"),helpcontext(IDH_IUBeam_W5)] 
      HRESULT W5([in] Float64 newVal);

      /// Overall depth
		[propget, helpstring("property D1"),helpcontext(IDH_IUBeam_D1)] 
      HRESULT D1([out, retval] Float64 *pVal);

		[propput, helpstring("property D1"),helpcontext(IDH_IUBeam_D1)] 
      HRESULT D1([in] Float64 newVal);

      /// Bottom plate thickness
		[propget, helpstring("property D2"),helpcontext(IDH_IUBeam_D2)] 
      HRESULT D2([out, retval] Float64 *pVal);

		[propput, helpstring("property D2"),helpcontext(IDH_IUBeam_D2)] 
      HRESULT D2([in] Float64 newVal);

      /// Depth of web-bottom plate taper
		[propget, helpstring("property D3"),helpcontext(IDH_IUBeam_D3)] 
      HRESULT D3([out, retval] Float64 *pVal);

		[propput, helpstring("property D3"),helpcontext(IDH_IUBeam_D3)] 
      HRESULT D3([in] Float64 newVal);

      /// Top flange outside depth dimension
		[propget, helpstring("property D4"),helpcontext(IDH_IUBeam_D4)] 
      HRESULT D4([out, retval] Float64 *pVal);

		[propput, helpstring("property D4"),helpcontext(IDH_IUBeam_D4)] 
      HRESULT D4([in] Float64 newVal);

      /// Top flange outside depth dimension
      [propget, helpstring("property D5"),helpcontext(IDH_IUBeam_D5)]
      HRESULT D5([out, retval] Float64 *pVal);

		[propput, helpstring("property D5"),helpcontext(IDH_IUBeam_D5)] 
      HRESULT D5([in] Float64 newVal);

      /// Top flange inside depth dimension
      [propget, helpstring("property D6"),helpcontext(IDH_IUBeam_D6)]
      HRESULT D6([out, retval] Float64 *pVal);

		[propput, helpstring("property D6"),helpcontext(IDH_IUBeam_D6)] 
      HRESULT D6([in] Float64 newVal);

      /// Top flange inside depth dimension
      [propget, helpstring("property D7"),helpcontext(IDH_IUBeam_D7)]
      HRESULT D7([out, retval] Float64 *pVal);

		[propput, helpstring("property D7"),helpcontext(IDH_IUBeam_D7)] 
      HRESULT D7([in] Float64 newVal);

      /// Web thickness measured perpendicular to the web slope
		[propget, helpstring("property T"),helpcontext(IDH_IUBeam_T)] 
      HRESULT T([out, retval] Float64 *pVal);

		[propput, helpstring("property T"),helpcontext(IDH_IUBeam_T)] 
      HRESULT T([in] Float64 newVal);

      /// Hook point is located bottom-centerline of section
		[propget, helpstring("property HookPoint"),helpcontext(IDH_IUBeam_HookPoint)] 
      HRESULT HookPoint([out, retval] IPoint2d* *pVal);

		[propputref, helpstring("property HookPoint"),helpcontext(IDH_IUBeam_HookPoint)] 
      HRESULT HookPoint([in] IPoint2d* newVal);

      /// Overall height 
		[propget, helpstring("property Height"),helpcontext(IDH_IUBeam_Height)] 
      HRESULT Height([out, retval] Float64 *pVal);

      /// Slope of the web.
      /// Slope is measured in the shape coordinate system. The left web will typically have a negative slope.
      [propget, helpstring("property Slope"), helpcontext(IDH_IUBeam_Slope)] 
      HRESULT Slope([in]WebIndexType webIdx, [out, retval]Float64* slope);

      /// Overall top width
      [propget, helpstring("property TopWidth"), helpcontext(IDH_IUBeam_TopWidth)] 
      HRESULT TopWidth([out, retval]Float64* width);

      /// The out-to-out width of the top flange for one web
      [propget, helpstring("property TopFlangeWidth"), helpcontext(IDH_IUBeam_TopFlangeWidth)] 
      HRESULT TopFlangeWidth([out, retval]Float64* width);

      /// The location of the web is measured along the top of the girder, from the centerline of the beam to the point that the centerline of the web intersects the top of the top flange.
      /// Webs that are to the left of the centerline of locations that are less than zero.Webs to the right of the centerline have a positive location.
      /// The left web has web index 0 and the right web has web index 1.
      [propget, helpstring("property WebLocation"), helpcontext(IDH_IUBeam_WebLocation)]
      HRESULT WebLocation([in]WebIndexType webIdx, [out, retval]Float64* location);

      /// Spacing between the centerline of the webs.
      /// The spacing between the webs is measured along the top of the girder between the points where the centerline of the web intersects the top flange
      [propget, helpstring("property WebSpacing"), helpcontext(IDH_IUBeam_WebSpacing)] 
      HRESULT WebSpacing([out, retval]Float64* spacing);

      /// The Shape property
      [propget, helpstring("property Shape"), helpcontext(IDH_IUBeam_Shape)]
      HRESULT Shape([out, retval] IShape* *pVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_IUBeam_XYPosition)]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);
   };


   /// Object representing the cross section of a U-Beam girder
   ///
   /// \image html UBeam/UBeam2.jpg   
   [
		object,
		uuid(4A262C68-AE3A-405f-A7E9-7A7BA09B70ED),
		oleautomation,
      helpcontext(IDH_IUBeam2),
		helpstring("IUBeam2 Interface"),
		pointer_default(unique)
	]
	interface IUBeam2 : IUnknown
	{
      /// Bottom width
      [propget, helpstring("property W1"),helpcontext(IDH_IUBeam2_W1)]
      HRESULT W1([out, retval] Float64 *pVal);

		[propput, helpstring("property W1"),helpcontext(IDH_IUBeam2_W1)] 
      HRESULT W1([in] Float64 newVal);

      /// Out-to-out top width
      [propget, helpstring("property W2"),helpcontext(IDH_IUBeam2_W2)]
      HRESULT W2([out, retval] Float64 *pVal);

		[propput, helpstring("property W2"),helpcontext(IDH_IUBeam2_W2)] 
      HRESULT W2([in] Float64 newVal);

      /// Width of web-bottom plate taper
      [propget, helpstring("property W3"),helpcontext(IDH_IUBeam2_W3)]
      HRESULT W3([out, retval] Float64 *pVal);

		[propput, helpstring("property W3"),helpcontext(IDH_IUBeam2_W3)] 
      HRESULT W3([in] Float64 newVal);

      /// Outside top flange bevel horizontal offset
		[propget, helpstring("property W4"),helpcontext(IDH_IUBeam2_W4)] 
      HRESULT W4([out, retval] Float64 *pVal);

		[propput, helpstring("property W4"),helpcontext(IDH_IUBeam2_W4)] 
      HRESULT W4([in] Float64 newVal);

      /// Width of underside of top flange
		[propget, helpstring("property W5"),helpcontext(IDH_IUBeam2_W5)] 
      HRESULT W5([out, retval] Float64 *pVal);

		[propput, helpstring("property W5"),helpcontext(IDH_IUBeam2_W5)] 
      HRESULT W5([in] Float64 newVal);

      /// Top width of top flange
		[propget, helpstring("property W6"),helpcontext(IDH_IUBeam2_W6)] 
      HRESULT W6([out, retval] Float64 *pVal);

		[propput, helpstring("property W6"),helpcontext(IDH_IUBeam2_W6)] 
      HRESULT W6([in] Float64 newVal);

      /// Offset of inside bevel
		[propget, helpstring("property W7"),helpcontext(IDH_IUBeam2_W7)] 
      HRESULT W7([out, retval] Float64 *pVal);

		[propput, helpstring("property W7"),helpcontext(IDH_IUBeam2_W7)] 
      HRESULT W7([in] Float64 newVal);

      /// Overall depth
      [propget, helpstring("property D1"),helpcontext(IDH_IUBeam2_D1)]
      HRESULT D1([out, retval] Float64 *pVal);

		[propput, helpstring("property D1"),helpcontext(IDH_IUBeam2_D1)] 
      HRESULT D1([in] Float64 newVal);

      /// Bottom plate thickness
      [propget, helpstring("property D2"),helpcontext(IDH_IUBeam2_D2)]
      HRESULT D2([out, retval] Float64 *pVal);

		[propput, helpstring("property D2"),helpcontext(IDH_IUBeam2_D2)] 
      HRESULT D2([in] Float64 newVal);

      /// Depth of web-bottom plate taper
      [propget, helpstring("property D3"),helpcontext(IDH_IUBeam2_D3)]
      HRESULT D3([out, retval] Float64 *pVal);

		[propput, helpstring("property D3"),helpcontext(IDH_IUBeam2_D3)] 
      HRESULT D3([in] Float64 newVal);

      /// Depth of top flange under side taper
		[propget, helpstring("property D4"),helpcontext(IDH_IUBeam2_D4)] 
      HRESULT D4([out, retval] Float64 *pVal);

		[propput, helpstring("property D4"),helpcontext(IDH_IUBeam2_D4)] 
      HRESULT D4([in] Float64 newVal);

      /// Depth of outside top flange bevel
		[propget, helpstring("property D5"),helpcontext(IDH_IUBeam2_D5)] 
      HRESULT D5([out, retval] Float64 *pVal);

		[propput, helpstring("property D5"),helpcontext(IDH_IUBeam2_D5)] 
      HRESULT D5([in] Float64 newVal);

      /// Depth of inside bevel
		[propget, helpstring("property D6"),helpcontext(IDH_IUBeam2_D6)] 
      HRESULT D6([out, retval] Float64 *pVal);

		[propput, helpstring("property D6"),helpcontext(IDH_IUBeam2_D6)] 
      HRESULT D6([in] Float64 newVal);

      /// Dimension of chamfer
		[propget, helpstring("property C1"),helpcontext(IDH_IUBeam2_C1)] 
      HRESULT C1([out, retval] Float64 *pVal);

		[propput, helpstring("property C1"),helpcontext(IDH_IUBeam2_C1)] 
      HRESULT C1([in] Float64 newVal);

      /// Web thickness measured perpendicular to the web slope
      [propget, helpstring("property T"),helpcontext(IDH_IUBeam2_T)]
      HRESULT T([out, retval] Float64 *pVal);

		[propget, helpstring("property HookPoint"),helpcontext(IDH_IUBeam2_HookPoint)] 
      HRESULT HookPoint([out, retval] IPoint2d* *pVal);

      /// Hook point is located bottom-centerline of section
      [propputref, helpstring("property HookPoint"),helpcontext(IDH_IUBeam2_HookPoint)]
      HRESULT HookPoint([in] IPoint2d* newVal);

      /// Overall height 
      [propget, helpstring("property Height"),helpcontext(IDH_IUBeam2_Height)]
      HRESULT Height([out, retval] Float64 *pVal);

      /// Slope of the web.
      /// Slope is measured in the shape coordinate system. The left web will typically have a negative slope.
      [propget, helpstring("property Slope"), helpcontext(IDH_IUBeam2_Slope)]
      HRESULT Slope([in]WebIndexType webIdx, [out, retval]Float64* slope);
      
      /// Overall top width
      [propget, helpstring("property TopWidth"), helpcontext(IDH_IUBeam2_TopWidth)] 
      HRESULT TopWidth([out, retval]Float64* width);

      /// The out-to-out width of the top flange for one web
      [propget, helpstring("property TopFlangeWidth"), helpcontext(IDH_IUBeam2_TopFlangeWidth)]
      HRESULT TopFlangeWidth([out, retval]Float64* width);

      /// The location of the web is measured along the top of the girder, from the centerline of the beam to the point that the centerline of the web intersects the top of the top flange.
      /// Webs that are to the left of the centerline of locations that are less than zero.Webs to the right of the centerline have a positive location.
      /// The left web has web index 0 and the right web has web index 1.
      [propget, helpstring("property WebLocation"), helpcontext(IDH_IUBeam2_WebLocation)] 
      HRESULT WebLocation([in]WebIndexType webIdx, [out, retval]Float64* location);

      /// Spacing between the centerline of the webs.
      /// The spacing between the webs is measured along the top of the girder between the points where the centerline of the web intersects the top flange
      [propget, helpstring("property WebSpacing"), helpcontext(IDH_IUBeam2_WebSpacing)] 
      HRESULT WebSpacing([out, retval]Float64* spacing);

      /// Property specifying that the outline of the section is to be used for the shape.
      /// This property is useful in regions where there is an end block or diaphragm
      [propput, helpstring("property UseOutlineOnly")/*,helpcontext(IDH_IUBeam2_VoidCount)*/]
      HRESULT UseOutlineOnly([in]VARIANT_BOOL bUseOutlineOnly);

      [propget, helpstring("property UseOutlineOnly")/*,helpcontext(IDH_IUBeam2_VoidCount)*/]
      HRESULT UseOutlineOnly([out, retval]VARIANT_BOOL* bUseOutlineOnly);

      /// The Shape property
      [propget, helpstring("property Shape"),helpcontext(IDH_IUBeam2_Shape)]
      HRESULT Shape([out, retval] IShape* *pVal);

      /// The XYPosition property
      [propget, helpstring("property XYPosition"),helpcontext(IDH_IUBeam2_XYPosition)]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);
   };

   /// Object that contains shape information for a shape in a CompositeShape object
   [
   object,
   uuid(A76E22D6-6C41-49d8-94C2-10D10CF0DB04),
   oleautomation,
   helpstring("ICompositeShapeItem Interface"),
   //helpcontext(IDH_ICompositeShapeItem),
   pointer_default(unique)
   ]
   interface ICompositeShapeItem : IUnknown
   {
      /// A shape object implementing the IShape interface
      [propget, helpstring("property Shape")/*,helpcontext(IDH_ICompositeShapeItem_Shape)*/]
      HRESULT Shape([out, retval] IShape* *pVal);

      [propputref, helpstring("property Shape")/*,helpcontext(IDH_ICompositeShapeItem_Shape)*/]
      HRESULT Shape([in] IShape* newVal);

      /// Property indicating if a shape models a solid shape or a void.
      [propget, helpstring("property Void")/*,helpcontext(IDH_ICompositeShapeItem_Void)*/]
      HRESULT Void([out, retval] VARIANT_BOOL *pVal);

      [propput, helpstring("property Void")/*,helpcontext(IDH_ICompositeShapeItem_Void)*/]
      HRESULT Void([in] VARIANT_BOOL newVal);
   };

   /// Object that models a generic shape composed of shape item objects that implement the ICompositeShapeItem interface
   [
   object,
   uuid(0BAF0D09-6A8D-4818-AAA6-C5B72C3641FE),
   oleautomation,
   helpstring("ICompositeShape Interface"),
   //helpcontext(IDH_ICompositeShape),
   pointer_default(unique)
   ]
   interface ICompositeShape : IUnknown
   {
      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, helpstring("property _NewEnum")]
         HRESULT _NewEnum([out, retval] IUnknown* *pVal);

         /// Returns a CompositeShapeItem object
		   [propget, helpstring("property Item")/*,helpcontext(IDH_ICompositeShape_Item)*/]
         HRESULT Item(
            [in] CollectionIndexType idx,  ///< index of the item to be returned
            [out, retval] ICompositeShapeItem* *pVal ///< the CompositeShapeItem
         );

         /// Adds a shape to this composite, creating a CompositeShapeItem
		   [helpstring("method AddShape")/*,helpcontext(IDH_ICompositeShape_AddShape)*/]
         HRESULT AddShape(
            [in] IShape* shape, ///< the shape
            [in] VARIANT_BOOL bVoid ///< VARIANT_TRUE and VARIANT_FALSE indicates the shape represents a void or a solid, respectively
         );

         /// Adds a CompositeShapeItem to this composite
		   [helpstring("method AddSectionEx")/*,helpcontext(IDH_ICompositeSection_AddShapeEx)*/]
         HRESULT AddShapeEx([in] ICompositeShapeItem* shapeItem);

         /// Replaces the shape associated with a composite shape item
         [helpstring("method Replace")/*,helpcontext(IDH_ICompsiteShape_Replace)*/]
         HRESULT Replace(
            [in]CollectionIndexType idx, ///< index of the item
            [in]IShape* pShape ///< the replacement shape
         );

         /// Replaces a CompositeShapeItem
         [helpstring("method ReplaceEx")/*,helpcontext(IDH_ICompsiteShape_ReplaceEx)*/]
         HRESULT ReplaceEx(
            [in]CollectionIndexType idx, ///< index of the item
            [in]ICompositeShapeItem* pShapeItem ///< the replacement CompositeShapeItem
         );

         /// Removes a CompositeShapeItem from the composite
		   [helpstring("method Remove")/*,helpcontext(IDH_ICompositeShape_Remove)*/]
         HRESULT Remove(
            [in] CollectionIndexType idx ///< index of the CompositeShapeItem to be removed
         );

         /// Removes all CompositeShapeItem objects
		   [helpstring("method Clear")/*,helpcontext(IDH_ICompositeShape_Clear)*/]
         HRESULT Clear();

         /// Number of CompositeShapeItem objects in this composite
		   [propget, helpstring("property Count")/*,helpcontext(IDH_ICompositeShape_Count)*/]
         HRESULT Count([out, retval] CollectionIndexType *pVal);

         /// The Shape property
         [propget, helpstring("property Shape")/*,helpcontext(IDH_ICompositeShape_Shape)*/]
         HRESULT Shape([out, retval] IShape* *pVal);

         /// The XYPosition property
         [propget, helpstring("property XYPosition")/*,helpcontext(IDH_ICompositeShape_XYPosition)*/]
         HRESULT XYPosition([out, retval] IXYPosition* *pVal);
   };

   /// Object representing the cross section of a voided slab
   ///
   /// \image html VoidedSlab/VoidedSlab.jpg 
   [
   object,
   uuid(82ABF099-2BCB-4119-AAFC-C3E6B04624C7),
   oleautomation,
   helpstring("IVoidedSlab Interface"),
   //helpcontext(IDH_IVoidedSlab),
   pointer_default(unique)
   ]
   interface IVoidedSlab : IUnknown
   {
      /// Height of the slab
      [propput,helpstring("property Height")/*,helpcontext(IDH_IVoidedSlab_Height)*/]
      HRESULT Height([in]Float64 h);

      [propget,helpstring("property Height")/*,helpcontext(IDH_IVoidedSlab_Height)*/]
      HRESULT Height([out,retval]Float64* h);

      /// Width of the slab
      [propput,helpstring("property Width")/*,helpcontext(IDH_IVoidedSlab_Width)*/]
      HRESULT Width([in]Float64 w);

      [propget,helpstring("property Width")/*,helpcontext(IDH_IVoidedSlab_Width)*/]
      HRESULT Width([out,retval]Float64* w);

      /// Void diameter
      [propput,helpstring("property VoidDiameter")/*,helpcontext(IDH_IVoidedSlab_VoidDiameter)*/]
      HRESULT VoidDiameter([in]Float64 d);

      [propget,helpstring("property VoidDiameter")/*,helpcontext(IDH_IVoidedSlab_VoidDiameter)*/]
      HRESULT VoidDiameter([out,retval]Float64* d);

      /// Spacing between center of voids
      [propput,helpstring("property VoidSpacing")/*,helpcontext(IDH_IVoidedSlab_VoidSpacing)*/]
      HRESULT VoidSpacing([in]Float64 s);

      [propget,helpstring("property VoidSpacing")/*,helpcontext(IDH_IVoidedSlab_VoidSpacing)*/]
      HRESULT VoidSpacing([out,retval]Float64* s);

      /// Number of voids
      [propput,helpstring("property VoidCount")/*,helpcontext(IDH_IVoidedSlab_VoidCount)*/]
      HRESULT VoidCount([in]CollectionIndexType nv);

      [propget,helpstring("property VoidCount")/*,helpcontext(IDH_IVoidedSlab_VoidCount)*/]
      HRESULT VoidCount([out,retval]CollectionIndexType* nv);

      /// Hook point is at bottom centerline of the shape
      [propget,  helpstring("property HookPoint")/*,helpcontext(IDH_IVoidedSlab_HookPoint)*/]
      HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

      [propputref,  helpstring("property HookPoint")/*,helpcontext(IDH_IVoidedSlab_HookPoint)*/]
      HRESULT HookPoint([in] IPoint2d* hookPnt);

      [helpstring("method GetSlabShape")]
      HRESULT GetSlabShape([out]IShape** ppShape);

      [helpstring("method GetVoidShape")]
      HRESULT GetVoidShape([in]IndexType idx, [out]IShape** ppShape);

      /// The Shape property
      [propget, helpstring("property Shape")/*,helpcontext(IDH_IVoidedSlab_Shape)*/]
      HRESULT Shape([out, retval] IShape* *pVal);

      /// The XYPosition property
      [propget,  helpstring("property XYPosition")/*,helpcontext(IDH_IVoidedSlab_XYPosition)*/]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);
   };


   /// Object representing the cross section of a voided slab
   ///
   /// \image html VoidedSlab/VoidedSlab2.jpg 
   [
   object,
   uuid(F8EC30FA-8C49-4b8d-AA93-B0D83A785142),
   oleautomation,
   helpstring("IVoidedSlab2 Interface"),
   //helpcontext(IDH_IVoidedSlab2),
   pointer_default(unique)
   ]
   interface IVoidedSlab2 : IUnknown
   {
      /// Height of the slab
      [propput,helpstring("property Height")/*,helpcontext(IDH_IVoidedSlab_Height)*/]
      HRESULT Height([in]Float64 h);

      [propget,helpstring("property Height")/*,helpcontext(IDH_IVoidedSlab_Height)*/]
      HRESULT Height([out,retval]Float64* h);

      /// Width of the slab
      [propput,helpstring("property Width")/*,helpcontext(IDH_IVoidedSlab_Width)*/]
      HRESULT Width([in]Float64 w);

      [propget,helpstring("property Width")/*,helpcontext(IDH_IVoidedSlab_Width)*/]
      HRESULT Width([out,retval]Float64* w);

      /// Edge blockout dimension
      [propput,helpstring("property C1")/*,helpcontext(IDH_IVoidedSlab_C1)*/]
      HRESULT C1([in]Float64 c1);

      [propget,helpstring("property C1")/*,helpcontext(IDH_IVoidedSlab_C1)*/]
      HRESULT C1([out,retval]Float64* c1);

      /// Vertical offset of edge blockout from top of section
      [propput,helpstring("property C2")/*,helpcontext(IDH_IVoidedSlab_C2)*/]
      HRESULT C2([in]Float64 c2);

      [propget,helpstring("property C2")/*,helpcontext(IDH_IVoidedSlab_C2)*/]
      HRESULT C2([out,retval]Float64* c2);

      /// Bottom corner chamfer dimension
      [propput,helpstring("property C3")/*,helpcontext(IDH_IVoidedSlab_C3)*/]
      HRESULT C3([in]Float64 c3);

      [propget,helpstring("property C3")/*,helpcontext(IDH_IVoidedSlab_C3)*/]
      HRESULT C3([out,retval]Float64* c3);

      /// Property indicating if there is a blockout on the left side of the slab
      [propput,helpstring("property LeftBlockOut")/*,helpcontext(IDH_IVoidedSlab_LeftBlockOut)*/]
      HRESULT LeftBlockOut([in]VARIANT_BOOL bLeftBlockOut);

      [propget,helpstring("property LeftBlockOut")/*,helpcontext(IDH_IVoidedSlab_LeftBlockOut)*/]
      HRESULT LeftBlockOut([out,retval]VARIANT_BOOL* pbLeftBlockOut);

      /// Property indicating if there is a blockout on the right side of the slab
      [propput,helpstring("property RightBlockOut")/*,helpcontext(IDH_IVoidedSlab_RightBlockOut)*/]
      HRESULT RightBlockOut([in]VARIANT_BOOL bRightBlockOut);

      [propget,helpstring("property RightBlockOut")/*,helpcontext(IDH_IVoidedSlab_RightBlockOut)*/]
      HRESULT RightBlockOut([out,retval]VARIANT_BOOL* pbRightBlockOut);

      /// Diameter of the edge (exterior) voids (D1)
      [propput,helpstring("property ExteriorVoidDiameter")/*,helpcontext(IDH_IVoidedSlab_ExteriorVoidDiameter)*/]
      HRESULT ExteriorVoidDiameter([in]Float64 d);

      [propget,helpstring("property ExteriorVoidDiameter")/*,helpcontext(IDH_IVoidedSlab_ExteriorVoidDiameter)*/]
      HRESULT ExteriorVoidDiameter([out,retval]Float64* d);

      /// Diameter of the interior voids (D2)
      [propput,helpstring("property InteriorVoidDiameter")/*,helpcontext(IDH_IVoidedSlab_InteriorVoidDiameter)*/]
      HRESULT InteriorVoidDiameter([in]Float64 d);

      [propget,helpstring("property InteriorVoidDiameter")/*,helpcontext(IDH_IVoidedSlab_InteriorVoidDiameter)*/]
      HRESULT InteriorVoidDiameter([out,retval]Float64* d);

      /// Spacing between the centers of the edge (exterior) and first interior void (S1)
      [propput,helpstring("property ExteriorVoidSpacing")/*,helpcontext(IDH_IVoidedSlab_ExteriorVoidSpacing)*/]
      HRESULT ExteriorVoidSpacing([in]Float64 s);

      [propget,helpstring("property ExteriorVoidSpacing")/*,helpcontext(IDH_IVoidedSlab_ExteriorVoidSpacing)*/]
      HRESULT ExteriorVoidSpacing([out,retval]Float64* s);

      /// Spacing between the centers of interior voids (S2)
      [propput,helpstring("property InteriorVoidSpacing")/*,helpcontext(IDH_IVoidedSlab_InteriorVoidSpacing)*/]
      HRESULT InteriorVoidSpacing([in]Float64 s);

      [propget,helpstring("property InteriorVoidSpacing")/*,helpcontext(IDH_IVoidedSlab_InteriorVoidSpacing)*/]
      HRESULT InteriorVoidSpacing([out,retval]Float64* s);

      /// Distance from the bottom of the slab to the center of an edge (exterior) void (H1)
      [propput,helpstring("property ExteriorVoidElevation")/*,helpcontext(IDH_IVoidedSlab_ExteriorVoidElevation)*/]
      HRESULT ExteriorVoidElevation([in]Float64 h1);

      [propget,helpstring("property ExteriorVoidElevation")/*,helpcontext(IDH_IVoidedSlab_ExteriorVoidElevation)*/]
      HRESULT ExteriorVoidElevation([out,retval]Float64* h1);

      /// Distance from the bottom of the slab to the center of an interior void (H2)
      [propput,helpstring("property InteriorVoidElevation")/*,helpcontext(IDH_IVoidedSlab_InteriorVoidElevation)*/]
      HRESULT InteriorVoidElevation([in]Float64 h2);

      [propget,helpstring("property InteriorVoidElevation")/*,helpcontext(IDH_IVoidedSlab_InteriorVoidElevation)*/]
      HRESULT InteriorVoidElevation([out,retval]Float64* h2);

      /// Total number of voids
      [propput,helpstring("property VoidCount")/*,helpcontext(IDH_IVoidedSlab_VoidCount)*/]
      HRESULT VoidCount([in]CollectionIndexType nv);

      [propget,helpstring("property VoidCount")/*,helpcontext(IDH_IVoidedSlab_VoidCount)*/]
      HRESULT VoidCount([out,retval]CollectionIndexType* nv);

      /// Hook point is at bottom centerline of the shape
      [propget,  helpstring("property HookPoint")/*,helpcontext(IDH_IVoidedSlab_HookPoint)*/]
      HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

      [propputref,  helpstring("property HookPoint")/*,helpcontext(IDH_IVoidedSlab_HookPoint)*/]
      HRESULT HookPoint([in] IPoint2d* hookPnt);

      [helpstring("method GetSlabShape")]
      HRESULT GetSlabShape([out]IShape** ppShape);

      [helpstring("method GetVoidShape")]
      HRESULT GetVoidShape([in]IndexType idx, [out]IShape** ppShape);

      /// The XYPosition property
      [propget,  helpstring("property XYPosition")/*,helpcontext(IDH_IVoidedSlab_XYPosition)*/]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget,  helpstring("property Shape")/*,helpcontext(IDH_IVoidedSlab_Shape)*/]
      HRESULT Shape([out, retval] IShape* *pVal);
   };

   /// Object representing the cross section of a box beam
   ///
   /// \image html BoxBeam/BoxBeam.jpg 
   [
   object,
   uuid(DD2E8D6C-2EC0-4370-AC01-11EA0C01294C),
   oleautomation,
   helpstring("IBoxBeam Interface"),
   //helpcontext(IDH_IBoxBeam),
   pointer_default(unique)
   ]
   interface IBoxBeam : IUnknown
   {
      /// Top exterior taper width
	   [propget,  helpstring("property W1")/*,helpcontext(IDH_IBoxBeam_W1)*/]
	   HRESULT W1([out, retval] Float64 *pVal);

	   [propput,  helpstring("property W1")/*,helpcontext(IDH_IBoxBeam_W1)*/]
	   HRESULT W1([in] Float64 newVal);

      /// Web width
      [propget,  helpstring("property W2")/*,helpcontext(IDH_IBoxBeam_W2)*/]
	   HRESULT W2([out, retval] Float64 *pVal);

	   [propput,  helpstring("property W2")/*,helpcontext(IDH_IBoxBeam_W2)*/]
	   HRESULT W2([in] Float64 newVal);

      /// Interior void width
      [propget,  helpstring("property W3")/*,helpcontext(IDH_IBoxBeam_W3)*/]
	   HRESULT W3([out, retval] Float64 *pVal);

	   [propput,  helpstring("property W3")/*,helpcontext(IDH_IBoxBeam_W3)*/]
	   HRESULT W3([in] Float64 newVal);

      /// Bottom exterior taper width
      [propget,  helpstring("property W4")/*,helpcontext(IDH_IBoxBeam_W4)*/]
	   HRESULT W4([out, retval] Float64 *pVal);

	   [propput,  helpstring("property W4")/*,helpcontext(IDH_IBoxBeam_W4)*/]
	   HRESULT W4([in] Float64 newVal);

      /// Top slab depth
	   [propget,  helpstring("property H1")/*,helpcontext(IDH_IBoxBeam_H1)*/]
	   HRESULT H1([out, retval] Float64 *pVal);

	   [propput,  helpstring("property H1")/*,helpcontext(IDH_IBoxBeam_H1)*/]
	   HRESULT H1([in] Float64 newVal);

      /// Interior void depth
      [propget,  helpstring("property H2")/*,helpcontext(IDH_IBoxBeam_H2)*/]
	   HRESULT H2([out, retval] Float64 *pVal);

	   [propput,  helpstring("property H2")/*,helpcontext(IDH_IBoxBeam_H2)*/]
	   HRESULT H2([in] Float64 newVal);

      /// Bottom slab depth
      [propget,  helpstring("property H3")/*,helpcontext(IDH_IBoxBeam_H3)*/]
	   HRESULT H3([out, retval] Float64 *pVal);

	   [propput,  helpstring("property H3")/*,helpcontext(IDH_IBoxBeam_H3)*/]
	   HRESULT H3([in] Float64 newVal);

      /// Top exterior overhang depth
      [propget,  helpstring("property H4")/*,helpcontext(IDH_IBoxBeam_H4)*/]
	   HRESULT H4([out, retval] Float64 *pVal);

	   [propput,  helpstring("property H4")/*,helpcontext(IDH_IBoxBeam_H4)*/]
	   HRESULT H4([in] Float64 newVal);

      /// Top exterior taper depth
      [propget,  helpstring("property H5")/*,helpcontext(IDH_IBoxBeam_H5)*/]
	   HRESULT H5([out, retval] Float64 *pVal);

	   [propput,  helpstring("property H5")/*,helpcontext(IDH_IBoxBeam_H5)*/]
	   HRESULT H5([in] Float64 newVal);

      /// Bottom exterior taper depth
	   [propget,  helpstring("property H6")/*,helpcontext(IDH_IBoxBeam_H6)*/]
	   HRESULT H6([out, retval] Float64 *pVal);

	   [propput,  helpstring("property H6")/*,helpcontext(IDH_IBoxBeam_H6)*/]
	   HRESULT H6([in] Float64 newVal);

      /// Bottom exterior depth
	   [propget,  helpstring("property H7")/*,helpcontext(IDH_IBoxBeam_H7)*/]
	   HRESULT H7([out, retval] Float64 *pVal);

	   [propput,  helpstring("property H7")/*,helpcontext(IDH_IBoxBeam_H7)*/]
	   HRESULT H7([in] Float64 newVal);

      /// Top interior fillet
	   [propget,  helpstring("property F1")/*,helpcontext(IDH_IBoxBeam_F1)*/]
	   HRESULT F1([out, retval] Float64 *pVal);

	   [propput,  helpstring("property F1")/*,helpcontext(IDH_IBoxBeam_F1)*/]
	   HRESULT F1([in] Float64 newVal);

      /// Bottom interior fillet
      [propget,  helpstring("property F2")/*,helpcontext(IDH_IBoxBeam_F2)*/]
	   HRESULT F2([out, retval] Float64 *pVal);

	   [propput,  helpstring("property F2")/*,helpcontext(IDH_IBoxBeam_F2)*/]
	   HRESULT F2([in] Float64 newVal);

      /// Exterior chamfer 
	   [propget,  helpstring("property C1"),/*helpcontext(IDH_IBoxBeam_C1)*/]
	   HRESULT C1([out, retval] Float64 *pVal);

	   [propput,  helpstring("property C1"),/*helpcontext(IDH_IBoxBeam_C1)*/]
	   HRESULT C1([in] Float64 newVal);

      /// Number of voids.
      /// If VoidCount is set to zero, the shape consists of only the outline.
      /// 0 and 1 are the only valid values for VoidCount.
      [propput,helpstring("property VoidCount")/*,helpcontext(IDH_IBoxBeam_VoidCount)*/]
      HRESULT VoidCount([in]CollectionIndexType nv);

      [propget,helpstring("property VoidCount")/*,helpcontext(IDH_IBoxBeam_VoidCount)*/]
      HRESULT VoidCount([out,retval]CollectionIndexType* nv);

      /// Hook point is at bottom centerline of the shape
      [propget,  helpstring("property HookPoint")/*,helpcontext(IDH_IBoxBeam_HookPoint)*/]
	   HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

      [propputref,  helpstring("property HookPoint")/*,helpcontext(IDH_IBoxBeam_HookPoint)*/]
	   HRESULT HookPoint([in] IPoint2d* hookPnt);

      /// Total width of both webs
	   [propget,  helpstring("property WebWidth")/*,helpcontext(IDH_IBoxBeam_WebWidth)*/]
	   HRESULT WebWidth([out, retval] Float64 *pVal);

      /// Width of the bottom flange
	   [propget,  helpstring("property BottomFlangeWidth")/*,helpcontext(IDH_IBoxBeam_BottomFlangeWidth)*/]
	   HRESULT BottomFlangeWidth(
         [out]Float64* pLeft,  ///< width left of the nominal centerline
         [out]Float64* pRight  ///< width right of the nominal centerline
      );

      /// Width of the top flange
      [propget,  helpstring("property TopFlangeWidth")/*,helpcontext(IDH_IBoxBeam_TopFlangeWidth)*/]
	   HRESULT TopFlangeWidth(
         [out]Float64* pLeft, ///< width left of the nominal centerline
         [out]Float64* pRight ///< width right of the nominal centerline
      );

      /// Property indicating if there is a blockout on the left side of the box.
      /// The block out is the indententation of the side of the box.
      [propput, helpstring("property LeftBlockOut")/*,helpcontext(IDH_IDeckedSlabBeam_LeftBlockOut)*/]
      HRESULT LeftBlockOut([in]VARIANT_BOOL bLeftBlockOut);

      [propget, helpstring("property LeftBlockOut")/*,helpcontext(IDH_IDeckedSlabBeam_LeftBlockOut)*/]
      HRESULT LeftBlockOut([out, retval]VARIANT_BOOL* pbLeftBlockOut);

      /// Property indicating if there is a blockout on the right side of the box.
      /// The block out is the indententation of the side of the box.
      [propput, helpstring("property RightBlockOut")/*,helpcontext(IDH_IDeckedSlabBeam_RightBlockOut)*/]
      HRESULT RightBlockOut([in]VARIANT_BOOL bRightBlockOut);

      [propget, helpstring("property RightBlockOut")/*,helpcontext(IDH_IDeckedSlabBeam_RightBlockOut)*/]
      HRESULT RightBlockOut([out, retval]VARIANT_BOOL* pbRightBlockOut);

      /// Overall width of the shape
      [propget, helpstring("property Width")]
      HRESULT Width([out, retval]Float64* pVal);

      /// Overall height of the shape
      [propget, helpstring("property Height")]
      HRESULT Height([out, retval]Float64* pVal);

      /// Boundary points of the section.
      /// These points differ from the locator points. The TopLeft, TopRight, BottomLeft, and BottomRight locator points are on the bounding box.
      /// In general the top and bottom width of a box beam are not equal. The TopLeft, TopRight, BottomLeft, and BottomRight points are the
      /// extreme corner points, excluding the chamfer geometry. 
      [helpstring("property GetBoundaryPoints")]
      HRESULT GetBoundaryPoints([out]IPoint2d** ppLeftTop, [out]IPoint2d** ppLeftBottom, [out]IPoint2d** ppRightTop, [out]IPoint2d** ppRightBottom);

      [helpstring("method GetBoxShape")]
      HRESULT GetBoxShape([out]IShape** ppShape);

      [helpstring("method GetVoidShape")]
      HRESULT GetVoidShape([in]IndexType idx, [out]IShape** ppShape);

      /// The XYPosition property
      [propget,  helpstring("property XYPosition")/*,helpcontext(IDH_IBoxBeam_XYPosition)*/]
	   HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget,  helpstring("property Shape")/*,helpcontext(IDH_IBoxBeam_Shape)*/]
	   HRESULT Shape([out, retval] IShape* *pVal);
   };


   /// Object representing the cross section of a decked slab beam
   ///
   /// \image html DeckedSlabBeam/DeckedSlabBeam.jpg 
   [
   object,
   uuid(ED1C099C-E020-408c-B9B5-952E0DAAB8D6),
   oleautomation,
   helpstring("IDeckedSlabBeam Interface"),
   //helpcontext(IDH_IDeckedSlabBeam),
   pointer_default(unique)
   ]
   interface IDeckedSlabBeam : IUnknown
   {
      /// Out-to-out width
      [propput,helpstring("property A")/*,helpcontext(IDH_IDeckedSlabBeam_A)*/]
      HRESULT A([in]Float64 a);

      [propget,helpstring("property A")/*,helpcontext(IDH_IDeckedSlabBeam_A)*/]
      HRESULT A([out,retval]Float64* a);

      /// Overhang width
      [propput,helpstring("property B")/*,helpcontext(IDH_IDeckedSlabBeam_B)*/]
      HRESULT B([in]Float64 b);

      [propget,helpstring("property B")/*,helpcontext(IDH_IDeckedSlabBeam_B)*/]
      HRESULT B([out,retval]Float64* b);

      /// Height of box between bottom of girder and bottom of top slab
      [propput,helpstring("property C")/*,helpcontext(IDH_IDeckedSlabBeam_C)*/]
      HRESULT C([in]Float64 c);

      [propget,helpstring("property C")/*,helpcontext(IDH_IDeckedSlabBeam_C)*/]
      HRESULT C([out,retval]Float64* c);

      /// Web width
      [propput,helpstring("property W")/*,helpcontext(IDH_IDeckedSlabBeam_W)*/]
      HRESULT W([in]Float64 W);

      [propget,helpstring("property W")/*,helpcontext(IDH_IDeckedSlabBeam_W)*/]
      HRESULT W([out,retval]Float64* W);

      /// Thickness of the top slab
      [propput,helpstring("property Tt")/*,helpcontext(IDH_IDeckedSlabBeam_Tt)*/]
      HRESULT Tt([in]Float64 Tt);

      [propget,helpstring("property Tt")/*,helpcontext(IDH_IDeckedSlabBeam_Tt)*/]
      HRESULT Tt([out,retval]Float64* Tt);

      /// Thickness of the bottom slab
      [propput,helpstring("property Tb")/*,helpcontext(IDH_IDeckedSlabBeam_Tb)*/]
      HRESULT Tb([in]Float64 Tb);

      [propget,helpstring("property Tb")/*,helpcontext(IDH_IDeckedSlabBeam_Tb)*/]
      HRESULT Tb([out,retval]Float64* Tb);

      /// Top flange bevel offset
      [propput,helpstring("property F")/*,helpcontext(IDH_IDeckedSlabBeam_F)*/]
      HRESULT F([in]Float64 F);

      [propget,helpstring("property F")/*,helpcontext(IDH_IDeckedSlabBeam_F)*/]
      HRESULT F([out,retval]Float64* F);

      /// Property indicating if the bevel on the left flange tip is used
      [propput,helpstring("property LeftBlockOut")/*,helpcontext(IDH_IDeckedSlabBeam_LeftBlockOut)*/]
      HRESULT LeftBlockOut([in]VARIANT_BOOL bLeftBlockOut);

      [propget,helpstring("property LeftBlockOut")/*,helpcontext(IDH_IDeckedSlabBeam_LeftBlockOut)*/]
      HRESULT LeftBlockOut([out,retval]VARIANT_BOOL* pbLeftBlockOut);

      /// Property indicating if the bevel on the right flange tip is used
      [propput,helpstring("property RightBlockOut")/*,helpcontext(IDH_IDeckedSlabBeam_RightBlockOut)*/]
      HRESULT RightBlockOut([in]VARIANT_BOOL bRightBlockOut);

      [propget,helpstring("property RightBlockOut")/*,helpcontext(IDH_IDeckedSlabBeam_RightBlockOut)*/]
      HRESULT RightBlockOut([out,retval]VARIANT_BOOL* pbRightBlockOut);

      /// Number of voids.
      /// If VoidCount is set to zero, the shape consists of only the outline.
      /// 0 and 1 are the only valid values for VoidCount.     
      [propput,helpstring("property VoidCount")/*,helpcontext(IDH_IDeckedSlabBeam_VoidCount)*/]
      HRESULT VoidCount([in]CollectionIndexType nv);

      [propget,helpstring("property VoidCount")/*,helpcontext(IDH_IDeckedSlabBeam_VoidCount)*/]
      HRESULT VoidCount([out,retval]CollectionIndexType* nv);

      /// Overall height of the shape
      [propget,helpstring("property Height")]
      HRESULT Height([out, retval]Float64* pVal);

      /// Hook point is at bottom centerline of the shape
      [propget,  helpstring("property HookPoint")/*,helpcontext(IDH_IDeckedSlabBeam_HookPoint)*/]
      HRESULT HookPoint([out,retval] IPoint2d** hookPnt);

      [propputref,  helpstring("property HookPoint")/*,helpcontext(IDH_IDeckedSlabBeam_HookPoint)*/]
      HRESULT HookPoint([in] IPoint2d* hookPnt);


      [helpstring("method GetSlabShape")]
      HRESULT GetSlabShape([out]IShape** ppShape);

      [helpstring("method GetVoidShape")]
      HRESULT GetVoidShape([in]IndexType idx, [out]IShape** ppShape);

      /// The XYPosition property
      [propget,  helpstring("property XYPosition")/*,helpcontext(IDH_IDeckedSlabBeam_XYPosition)*/]
      HRESULT XYPosition([out, retval] IXYPosition* *pVal);

      /// The Shape property
      [propget,  helpstring("property Shape")/*,helpcontext(IDH_IDeckedSlabBeam_Shape)*/]
      HRESULT Shape([out, retval] IShape* *pVal);
   };


   /// Represents an object that creates typical beam shapes
   [
      object,
      uuid(7C2DDC60-C428-4926-81CE-5DAAB52FBDD0),
      oleautomation,
      helpstring("IBeamShapeFactory Interface"),
      pointer_default(unique)
   ]
   interface IBeamShapeFactory : IUnknown
   {
      /// Factory method that creates beam shapes
      [helpstring("method CreateShape")] 
      HRESULT CreateShape(
          [in]BeamShapeType type, ///< the type of beam shape to create.
          [out,retval]IShape** ppShape ///< a beam shape object.
      );
   };


   [
      object,
      uuid(866B0CBE-62C2-40D5-B12F-1168F7AF1C55),
      oleautomation,
      helpstring("IElasticProperties Interface"),
      helpcontext(IDH_IElasticProperties),
      pointer_default(unique)
   ]
   interface IElasticProperties : IUnknown
   {
      [propget, helpstring("property EA"), helpcontext(IDH_IElasticProperties_EA)]
      HRESULT EA([out, retval] Float64* pVal);

      [propput, helpstring("property EA"), helpcontext(IDH_IElasticProperties_EA)]
      HRESULT EA([in] Float64 newVal);

      [propget, helpstring("property Centroid"), helpcontext(IDH_IElasticProperties_Centroid)]
      HRESULT Centroid([out, retval] IPoint2d** pVal);

      [propput, helpstring("property Centroid"), helpcontext(IDH_IElasticProperties_Centroid)]
      HRESULT Centroid([in] IPoint2d* newVal);

      [propget, helpstring("property EI11"), helpcontext(IDH_IElasticProperties_EI11)]
      HRESULT EI11([out, retval] Float64* pVal);

      [propget, helpstring("property EI22"), helpcontext(IDH_IElasticProperties_EI22)]
      HRESULT EI22([out, retval] Float64* pVal);

      [propget, helpstring("property EI12Max"), helpcontext(IDH_IElasticProperties_EI12Max)]
      HRESULT EI12Max([out, retval] Float64* pVal);

      [propget, helpstring("property EI12Min"), helpcontext(IDH_IElasticProperties_EI12Min)]
      HRESULT EI12Min([out, retval] Float64* pVal);

      [propget, helpstring("property EIxx"), helpcontext(IDH_IElasticProperties_EIxx)]
      HRESULT EIxx([out, retval] Float64* pVal);

      [propput, helpstring("property EIxx"), helpcontext(IDH_IElasticProperties_EIxx)]
      HRESULT EIxx([in] Float64 newVal);

      [propget, helpstring("property EIyy"), helpcontext(IDH_IElasticProperties_EIyy)]
      HRESULT EIyy([out, retval] Float64* pVal);

      [propput, helpstring("property EIyy"), helpcontext(IDH_IElasticProperties_EIyy)]
      HRESULT EIyy([in] Float64 newVal);

      [propget, helpstring("property EIxy"), helpcontext(IDH_IElasticProperties_EIxy)]
      HRESULT EIxy([out, retval] Float64* pVal);

      [propput, helpstring("property EIxy"), helpcontext(IDH_IElasticProperties_EIxy)]
      HRESULT EIxy([in] Float64 newVal);

      [propget, helpstring("property Xleft"), helpcontext(IDH_IElasticProperties_Xleft)]
      HRESULT Xleft([out, retval] Float64* pVal);

      [propput, helpstring("property Xleft"), helpcontext(IDH_IElasticProperties_Xleft)]
      HRESULT Xleft([in] Float64 newVal);

      [propget, helpstring("property Xright"), helpcontext(IDH_IElasticProperties_Xright)]
      HRESULT Xright([out, retval] Float64* pVal);

      [propput, helpstring("property Xright"), helpcontext(IDH_IElasticProperties_Xright)]
      HRESULT Xright([in] Float64 newVal);

      [propget, helpstring("property Ytop"), helpcontext(IDH_IElasticProperties_Ytop)]
      HRESULT Ytop([out, retval] Float64* pVal);

      [propput, helpstring("property Ytop"), helpcontext(IDH_IElasticProperties_Ytop)]
      HRESULT Ytop([in] Float64 newVal);

      [propget, helpstring("property Ybottom"), helpcontext(IDH_IElasticProperties_Ybottom)]
      HRESULT Ybottom([out, retval] Float64* pVal);

      [propput, helpstring("property Ybottom"), helpcontext(IDH_IElasticProperties_Ybottom)]
      HRESULT Ybottom([in] Float64 newVal);

      [propget, helpstring("property Origin"), helpcontext(IDH_IElasticProperties_Origin)]
      HRESULT Origin([out, retval] IPoint2d** pVal);

      [propput, helpstring("property Origin"), helpcontext(IDH_IElasticProperties_Origin)]
      HRESULT Origin([in] IPoint2d* newVal);

      [propget, helpstring("property Orientation"), helpcontext(IDH_IElasticProperties_Orientation)]
      HRESULT Orientation([out, retval] Float64* pVal);

      [propput, helpstring("property Orientation"), helpcontext(IDH_IElasticProperties_Orientation)]
      HRESULT Orientation([in] Float64 newVal);

      [propget, helpstring("property CoordinateSystem"), helpcontext(IDH_IElasticProperties_CoordinateSystem)]
      HRESULT CoordinateSystem([out, retval] CoordinateSystemType* pVal);

      [propput, helpstring("property CoordinateSystem"), helpcontext(IDH_IElasticProperties_CoordinateSystem)]
      HRESULT CoordinateSystem([in] CoordinateSystemType newVal);

      [propget, helpstring("property PrincipleDirection"), helpcontext(IDH_IElasticProperties_PrincipleDirection)]
      HRESULT PrincipleDirection([out, retval] Float64* pVal);

      [helpstring("method AddProperties"), helpcontext(IDH_IElasticProperties_AddProperties)]
      HRESULT AddProperties([in] IElasticProperties* props);

      [helpstring("method TransformProperties"), helpcontext(IDH_IElasticProperties_TransformProperties)]
      HRESULT TransformProperties([in] Float64 E, [out, retval] IShapeProperties** props);
   };

   [
      object,
      uuid(BA78A143-A0DA-4081-BAF5-C7BF7ACF9850),
      oleautomation,
      helpstring("IMassProperties Interface"),
      helpcontext(IDH_IMassProperties),
      pointer_default(unique)
   ]
   interface IMassProperties : IUnknown
   {
      [propget, helpstring("property MassPerLength"), helpcontext(IDH_IMassProperties_MassPerLength)]
      HRESULT MassPerLength([out, retval] Float64* pVal);

      [propput, helpstring("property MassPerLength"), helpcontext(IDH_IMassProperties_MassPerLength)]
      HRESULT MassPerLength([in] Float64 newVal);

      [helpstring("method AddProperties"), helpcontext(IDH_IMassProperties_AddProperties)]
      HRESULT AddProperties([in] IMassProperties* props);
   };

   [
      object,
      uuid(6467790E-93DE-489b-9D3A-00F2A547A172),
      oleautomation,
      helpstring("ISection Interface"),
      helpcontext(IDH_ISection),
      pointer_default(unique)
   ]
   interface ISection : IUnknown
   {
      [propget, helpstring("property BoundingBox"), helpcontext(IDH_ISection_BoundingBox)]
      HRESULT BoundingBox([out, retval] IRect2d** pVal);

      [propget, helpstring("property ElasticProperties"), helpcontext(IDH_ISection_ElasticProperties)]
      HRESULT ElasticProperties([out, retval] IElasticProperties** pVal);

      [propget, helpstring("property MassProperties"), helpcontext(IDH_ISection_MassProperties)]
      HRESULT MassProperties([out, retval] IMassProperties** pVal);

      [helpstring("method ClipIn"), helpcontext(IDH_ISection_ClipIn)]
      HRESULT ClipIn([in] IRect2d* rect, [out, retval] ISection** section);

      [helpstring("method ClipWithLine"), helpcontext(IDH_ISection_ClipWithLine)]
      HRESULT ClipWithLine([in] ILine2d* line, [out, retval] ISection** section);

      [helpstring("method Clone"), helpcontext(IDH_ISection_Clone)]
      HRESULT Clone(ISection** clone);
   };

   [
      object,
      uuid(D7610038-0289-11D5-8BAE-006097C68A9C),
      oleautomation,
      helpstring("ICompositeBeam Interface"),
      helpcontext(IDH_ICompositeBeam),
      pointer_default(unique)
   ]
   interface ICompositeBeam : IUnknown
   {
      [propget, helpstring("property Beam"), helpcontext(IDH_ICompositeBeam_Beam)]
      HRESULT Beam([out, retval] IShape** pVal);

      [propputref, helpstring("property Beam"), helpcontext(IDH_ICompositeBeam_Beam)]
      HRESULT Beam([in] IShape* newVal);

      [propget, helpstring("property EffectiveSlabWidth"), helpcontext(IDH_ICompositeBeam_EffectiveSlabWidth)]
      HRESULT EffectiveSlabWidth([out, retval] Float64* pVal);

      [propput, helpstring("property EffectiveSlabWidth"), helpcontext(IDH_ICompositeBeam_EffectiveSlabWidth)]
      HRESULT EffectiveSlabWidth([in] Float64 newVal);

      [propget, helpstring("property TributarySlabWidth"), helpcontext(IDH_ICompositeBeam_TributarySlabWidth)]
      HRESULT TributarySlabWidth([out, retval] Float64* pVal);

      [propput, helpstring("property TributarySlabWidth"), helpcontext(IDH_ICompositeBeam_TributarySlabWidth)]
      HRESULT TributarySlabWidth([in] Float64 newVal);

      [propget, helpstring("property GrossSlabDepth"), helpcontext(IDH_ICompositeBeam_GrossSlabDepth)]
      HRESULT GrossSlabDepth([out, retval] Float64* pVal);

      [propput, helpstring("property GrossSlabDepth"), helpcontext(IDH_ICompositeBeam_GrossSlabDepth)]
      HRESULT GrossSlabDepth([in] Float64 newVal);

      [propget, helpstring("property SacrificialDepth"), helpcontext(IDH_ICompositeBeam_SacrificialDepth)]
      HRESULT SacrificialDepth([out, retval] Float64* pVal);

      [propput, helpstring("property SacrificialDepth"), helpcontext(IDH_ICompositeBeam_SacrificialDepth)]
      HRESULT SacrificialDepth([in] Float64 newVal);

      [propget, helpstring("property SlabE"), helpcontext(IDH_ICompositeBeam_SlabE)]
      HRESULT SlabE([out, retval] Float64* pVal);

      [propput, helpstring("property SlabE"), helpcontext(IDH_ICompositeBeam_SlabE)]
      HRESULT SlabE([in] Float64 newVal);

      [propget, helpstring("property SlabDensity"), helpcontext(IDH_ICompositeBeam_SlabDensity)]
      HRESULT SlabDensity([out, retval] Float64* pVal);

      [propput, helpstring("property SlabDensity"), helpcontext(IDH_ICompositeBeam_SlabDensity)]
      HRESULT SlabDensity([in] Float64 newVal);

      [propget, helpstring("property HaunchWidth"), helpcontext(IDH_ICompositeBeam_HaunchWidth)]
      HRESULT HaunchWidth([out, retval] Float64* pVal);

      [propput, helpstring("property HaunchWidth"), helpcontext(IDH_ICompositeBeam_HaunchWidth)]
      HRESULT HaunchWidth([in] Float64 newVal);

      [propget, helpstring("property HaunchDepth"), helpcontext(IDH_ICompositeBeam_HaunchDepth)]
      HRESULT HaunchDepth([out, retval] Float64* pVal);

      [propput, helpstring("property HaunchDepth"), helpcontext(IDH_ICompositeBeam_HaunchDepth)]
      HRESULT HaunchDepth([in] Float64 newVal);

      [propget, helpstring("property Section"), helpcontext(IDH_ICompositeBeam_Section)]
      HRESULT Section([out, retval] ISection** pVal);

      [propget, helpstring("property XYPosition"), helpcontext(IDH_ICompositeBeam_XYPosition)]
      HRESULT XYPosition([out, retval] IXYPosition** pVal);

      [propget, helpstring("property BeamE"), helpcontext(IDH_ICompositeBeam_BeamE)]
      HRESULT BeamE([out, retval] Float64* pVal);

      [propput, helpstring("property BeamE"), helpcontext(IDH_ICompositeBeam_BeamE)]
      HRESULT BeamE([in] Float64 newVal);

      [propget, helpstring("property BeamDensity"), helpcontext(IDH_ICompositeBeam_BeamDensity)]
      HRESULT BeamDensity([out, retval] Float64* pVal);

      [propput, helpstring("property BeamDensity"), helpcontext(IDH_ICompositeBeam_BeamDensity)]
      HRESULT BeamDensity([in] Float64 newVal);

      [propget, helpstring("property QSlab"), helpcontext(IDH_ICompositeBeam_QSlab)]
      HRESULT QSlab([out, retval] Float64* pVal);

      [propget, helpstring("property Q"), helpcontext(IDH_ICompositeBeam_Q)]
      HRESULT Q([in] Float64 location, [out, retval] Float64* pVal);
   };


   [
      object,
      uuid(C6B42790-3DC8-487f-B33E-9B65167EFA3B),
      oleautomation,
      helpstring("ICompositeSectionItemEx Interface"),
      helpcontext(IDH_ICompositeSectionItemEx),
      pointer_default(unique)
   ]
   interface ICompositeSectionItemEx : IUnknown
   {
      [propget, helpstring("property Shape"), helpcontext(IDH_ICompositeSectionItemEx_Shape)]
      HRESULT Shape([out, retval] IShape** pVal);

      [propputref, helpstring("property Shape"), helpcontext(IDH_ICompositeSectionItemEx_Shape)]
      HRESULT Shape([in] IShape* newVal);

      [propget, helpstring("property Efg"), helpcontext(IDH_ICompositeSectionItemEx_Efg)]
      HRESULT Efg([out, retval] Float64* pVal);

      [propput, helpstring("property Efg"), helpcontext(IDH_ICompositeSectionItemEx_Efg)]
      HRESULT Efg([in] Float64 newVal);

      [propget, helpstring("property Ebg"), helpcontext(IDH_ICompositeSectionItemEx_Ebg)]
      HRESULT Ebg([out, retval] Float64* pVal);

      [propput, helpstring("property Ebg"), helpcontext(IDH_ICompositeSectionItemEx_Ebg)]
      HRESULT Ebg([in] Float64 newVal);

      [propget, helpstring("property Dfg"), helpcontext(IDH_ICompositeSectionItemEx_Dfg)]
      HRESULT Dfg([out, retval] Float64* pVal);

      [propput, helpstring("property Dfg"), helpcontext(IDH_ICompositeSectionItemEx_Dfg)]
      HRESULT Dfg([in] Float64 newVal);

      [propget, helpstring("property Dbg"), helpcontext(IDH_ICompositeSectionItemEx_Dbg)]
      HRESULT Dbg([out, retval] Float64* pVal);

      [propput, helpstring("property Dbg"), helpcontext(IDH_ICompositeSectionItemEx_Dbg)]
      HRESULT Dbg([in] Float64 newVal);

      [propget, helpstring("property Structural"), helpcontext(IDH_ICompositeSectionItemEx_Structural)]
      HRESULT Structural([out, retval] VARIANT_BOOL* pVal);

      [propput, helpstring("property Structural"), helpcontext(IDH_ICompositeSectionItemEx_Structural)]
      HRESULT Structural([in] VARIANT_BOOL newVal);
   };


   [
      object,
      uuid(EDEA2BF6-8E57-4bfa-8CD6-A007C6E1E032),
      oleautomation,
      helpstring("ICompositeSectionEx Interface"),
      helpcontext(IDH_ICompositeSectionEx),
      pointer_default(unique)
   ]
   interface ICompositeSectionEx : IUnknown
   {
      [propget, helpstring("property _NewEnum")]
      HRESULT _NewEnum([out, retval] IUnknown** pVal);

      [propget, helpstring("property Item"), helpcontext(IDH_ICompositeSectionEx_Item)]
      HRESULT Item([in] CollectionIndexType idx, [out, retval] ICompositeSectionItemEx** pVal);

      [helpstring("method AddSection"), helpcontext(IDH_ICompositeSectionEx_AddSection)]
      HRESULT AddSection([in] IShape* shape, [in] Float64 Efg, [in] Float64 Ebg, [in] Float64 Dfg, [in]Float64 Dbg, [in] VARIANT_BOOL bStructural);

      [helpstring("method AddSectionEx"), helpcontext(IDH_ICompositeSectionEx_AddSectionEx)]
      HRESULT AddSectionEx([in] ICompositeSectionItemEx* sectionItem);

      [helpstring("method Remove"), helpcontext(IDH_ICompositeSectionEx_Remove)]
      HRESULT Remove([in] CollectionIndexType idx);

      [propget, helpstring("property Count"), helpcontext(IDH_ICompositeSectionEx_Count)]
      HRESULT Count([out, retval] CollectionIndexType* pVal);

      [propget, helpstring("property Section"), helpcontext(IDH_ICompositeSectionEx_Section)]
      HRESULT Section([out, retval] ISection** pVal);

      [propget, helpstring("property XYPosition"), helpcontext(IDH_ICompositeSectionEx_XYPosition)]
      HRESULT XYPosition([out, retval] IXYPosition** pVal);
   };

   /// Represents a point in a two dimensional Cartesian coordinate system.
   /// Implements the IPoint2d interface
   [
		uuid(B0D56FA0-C8D6-11D2-8CDF-C55C1CA84A34),
      helpcontext(IDH_IPoint2d),
		helpstring("Point2d Class")
	]
	coclass Point2d
	{
		[default] interface IPoint2d;
	};

   /// Size implementing the ISize2d interface
   [
		uuid(B77D2444-96A0-11D2-88A7-006097C68A9C),
      helpcontext(IDH_ISize2d),
		helpstring("Size2d Class")
	]
	coclass Size2d
	{
		[default] interface ISize2d; 
	};

   /// Rectangle object that implements the IRect2d interface
   ///
   /// A Rect2d object differs from a Rectangle object. A Rect2d is a geometric primitive where a Rectangle is a shape
   [
		uuid(B77D2446-96A0-11D2-88A7-006097C68A9C),
      helpcontext(IDH_IRect2d),
		helpstring("Rect2d Class")
	]
	coclass Rect2d
	{
		[default] interface IRect2d;
	};

   /// A vector in a two dimensional coordinate system
   /// Implements the IVector2d interface
   [
		uuid(55B8EF84-FADF-11D2-8CDF-9849C70CC734),
		helpcontext(IDH_IVector2d),
		helpstring("Vector2d Class")
	]
	coclass Vector2d
	{
		[default] interface IVector2d;
	};

   /// A collection of Point2d objects.
   /// Implements the IPoint2dCollection interface
   [
       uuid(B77D2448-96A0-11D2-88A7-006097C68A9C),
       helpstring("Point2dCollection Class"),
	   helpcontext(IDH_IPoint2dCollection)
   ]
   coclass Point2dCollection
   {
       [default] interface IPoint2dCollection;
   };

   /// Represents a line segment in 2D space.
   /// Implements the ILineSegment2d interface
   [
		uuid(546BBDC2-96C0-11D2-8D11-14830CC10000),
      helpcontext(IDH_ILineSegment2d),
		helpstring("LineSegment2d Class")
	]
	coclass LineSegment2d
	{
		[default] interface ILineSegment2d;
	};

   /// Represents a infinite line in 2D space.
   /// Implements the ILine2d interface
   [
		uuid(D72D7403-F9DB-11D2-8CDF-444553540000),
		helpcontext(IDH_ILine2d),
      helpstring("Line2d Class")
	]
	coclass Line2d
	{
		[default] interface ILine2d;
	};

   /// Properties of geometric shapes.
   /// Implements the IShapeProperties interface
	[
		uuid(66172CA5-FF5A-11D2-8CDF-F43C3928A334),
		helpstring("ShapeProperties Class"),
		helpcontext(IDH_IShapeProperties)
	]
	coclass ShapeProperties
	{
		[default] interface IShapeProperties;
	};

   /// Object representing a shape defined by a sequence of points forming a polygon
   /// Implements the IPolyShape interface
   [
		uuid(94FD8E64-0013-11D3-8CDF-8BF0A4AD5B35),
		helpstring("PolyShape Class"),
		helpcontext(IDH_IPolyShape)
	]
	coclass PolyShape
	{
		[default] interface IPolyShape;
      interface IShape;
      interface IXYPosition;
	};

   /// Object representing a circular shape. 
   /// Implements the ICircle interface
	[
		uuid(219B8FC2-0154-11D3-8CDF-CCA4ADEF4534),
		helpstring("Circle Class"),
		helpcontext(IDH_ICircle)
	]
	coclass Circle
	{
		[default] interface ICircle;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing a rectangular shape.
   /// Implements the IRectangle interface
	[
		uuid(3E07BAA2-01A2-11D3-8CDF-D8B830C3A934),
		helpstring("Rectangle Class"),
		helpcontext(IDH_IRectangle)
	]
	coclass Rect
	{
		[default] interface IRectangle;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing a triangular shape.
   /// Implements the ITriangle interface
   [
		uuid(0C89D3A2-02E2-11D3-8CDF-DDE6AA65DF35),
		helpstring("Triangle Class"),
		helpcontext(IDH_ITriangle)
	]
	coclass Triangle
	{
		[default] interface ITriangle;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a precast concrete I-Beam.
   /// Implements the IPrecastBeam interface.
	[
		uuid(E7E272C2-032F-11D3-8CDF-861E1B8C3634),
		helpstring("PrecastBeam Class"),
		helpcontext(IDH_IPrecastBeam)
	]
	coclass PrecastBeam
	{
		[default] interface IPrecastBeam;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a precast concrete I-Beam.
   /// Implements the IPrecastBeam2 interface.
   [
      uuid(6446F67F-A050-4A49-B6FD-7AC1333855B7),
      helpstring("PrecastBeam2 Class")//,
      //helpcontext(IDH_IPrecastBeam2)
   ]
   coclass PrecastBeam2
   {
      [default] interface IPrecastBeam2;
      interface IShape;
      interface IXYPosition;
   };

   /// Object representing the shape of a University of Nebraska (NU) precast concrete I-Beam.
   /// Implements the INUBeam interface.
   [
		uuid(411AA7A2-67F2-4bb6-86E2-09C2C0F5A096),
		helpstring("NUBeam Class"),
		helpcontext(IDH_INUBeam)
	]
	coclass NUBeam
	{
		[default] interface INUBeam;
		interface IShape;
		interface IXYPosition;
	};
    
   /// Object representing the shape of a UHPC Decked I-Beam based on the University of Nebraska (NU) precast concrete I-Beam.
/// Implements the INUDeckedIBeam interface.
   [
      uuid(F663062C-9209-4D00-88BE-FA82BA411A93),
      helpstring("NUDeckedIBeam Class")
      //helpcontext(IDH_INUBeam)
   ]
   coclass NUDeckedIBeam
   {
      [default] interface INUDeckedIBeam;
      interface IShape;
      interface IXYPosition;
   };

   /// Object representing the shape of a UHPC Decked I-Beam based on the University of Nebraska (NU) precast concrete I-Beam.
   /// Implements the INUDeckedIBeam interface.
   [
      uuid(904FC6A6-EB6A-4066-8D6F-325829DB32B2),
      helpstring("PCIDeckedIBeam Class")
      //helpcontext(IDH_INUBeam)
   ]
   coclass PCIDeckedIBeam
   {
      [default] interface IPCIDeckedIBeam;
      interface IShape;
      interface IXYPosition;
   };

    /// Object representing the shape of a deck bulb tee precast concrete girder.
   /// Implements the IBulbTee interface.
   [
		uuid(83B73726-F71A-4400-BCD0-542E1332EE2A),
		helpstring("BulbTee Class"),
		helpcontext(IDH_IBulbTee)
	]
	coclass BulbTee
	{
		[default] interface IBulbTee;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a deck bulb tee precast concrete girder.
   /// Implements the IBulbTee2 interface.
   [
      uuid(05EB3E1B-4844-43F3-A104-D85B204DEFE2),
      helpstring("BulbTee2 Class"),
      helpcontext(IDH_IBulbTee)
   ]
   coclass BulbTee2
   {
      [default] interface IBulbTee2;
      interface IShape;
      interface IXYPosition;
   };

   /// Object representing the shape of a traffic barrier
   /// Implements the ITrafficBarrier interface.
   [
		uuid(2558CFC2-03CE-11D3-8CDF-EBFB6612CA35),
		helpstring("TrafficBarrier Class"),
		helpcontext(IDH_ITrafficBarrier)
	]
	coclass TrafficBarrier
	{
		[default] interface ITrafficBarrier;
		interface IShape;
		interface IXYPosition;
	};
   
   /// Represents a point in a 3D coordinate systems.
   /// Implements the IPoint2d interface
	[
		uuid(4F37A661-03FE-11D3-8CDF-882D80988F34),
      helpcontext(IDH_IPoint3d),
		helpstring("Point3d Class")
	]
	coclass Point3d
	{
		[default] interface IPoint3d;
	};

   /// Represents a line segment in a two dimensional coordinate system.
   /// Implements the ISegment3d interface and fires
	[
		uuid(56CD2A28-FABF-4015-AA70-F27D95334249),
      //helpcontext(IDH_ILineSegment3d),
		helpstring("LineSegment3d Class")
	]
	coclass LineSegment3d
	{
		[default] interface ILineSegment3d;
	};

   /// Object representing a three dimensional rectangular prism.
   /// Implements the ISize3d interface
	[
		uuid(75DB33E1-0449-11D3-8CDF-9E53F9A4BF35),
      helpcontext(IDH_ISize3d),
		helpstring("Size3d Class")
	]
	coclass Size3d
	{
		[default] interface ISize3d;
	};

   /// Object representing a vector in 3D space.
   /// Implements the IVector3d interface.
	[
		uuid(F97D8402-1871-11D3-8CDF-925649DD1F63),
		helpstring("Vector3d Class"),
		helpcontext(IDH_IVector3d)
	]
	coclass Vector3d
	{
		[default] interface IVector3d;
	};

   /// Object representing plane in 3D space. 
   /// Implements the IPlane3d interface.
	[
		uuid(F97D8404-1871-11D3-8CDF-925649DD1F63),
		helpstring("Plane3d Class"),
		helpcontext(IDH_IPlane3d)
	]
	coclass Plane3d
	{
		[default] interface IPlane3d;
	};

   /// A collection of Point3d objects
   /// Implements the IPoint3dCollection interface
   [
		uuid(818E5101-1942-11D3-8CDF-DCD8D8F12565),
		helpstring("Point3dCollection Class"),
		helpcontext(IDH_IPoint3dCollection)
	]
	coclass Point3dCollection
	{
		[default] interface IPoint3dCollection;
	};

   /// An object that provides 2D and 3D geometric utility methods.
   /// This object also provides the factory objects used to create new instances of points, lines, and line segments.
   /// Implements the IGeomUtil, IGeomUtil2d, and IGeomUtil3d interfaces.
	[
		uuid(110FFB89-2B04-11D3-8952-006097C68A9C),
		helpstring("GeomUtil Class"),
		helpcontext(IDH_IGeomUtil)
	]
	coclass GeomUtil
	{
		[default] interface IGeomUtil;
		interface IGeomUtil2d;
	};

   /// An object that can transform Point3d coordinates between coordinate systems.
   /// Implements the ICoordinateXform3d interface
	[
		uuid(D146B4A5-5103-11D3-8CDF-BFEA3D98042F),
		helpstring("CoordinateXform3d Class"),
		helpcontext(IDH_ICoordinateXform3d)
	]
	coclass CoordinateXform3d
	{
		[default] interface ICoordinateXform3d;
	};

   /// An object that can transform Point2d coordinates between coordinate systems.
   /// Implements the ICoordinateXform2d interface
   [
		uuid(1A1AD39C-5184-11D3-8985-006097C68A9C),
		helpstring("CoordinateXform2d Class"),
		helpcontext(IDH_ICoordinateXform2d)
	]
	coclass CoordinateXform2d
	{
		[default] interface ICoordinateXform2d;
	};

   /// Object representing a circular segment shape. 
   /// Implements the ICircularSegment interface
   [
		uuid(C6C2A641-6563-11D4-8CE4-0080C7380027),
		helpstring("CircularSegment Class"),
		helpcontext(IDH_ICircularSegment)
	]
	coclass CircularSegment
	{
		[default] interface ICircularSegment;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a built-up steel plate girder.
   /// Implements the IPlateGirder interface.	
   [
		uuid(9F28211E-09D6-11D5-8BBF-006097C68A9C),
		helpstring("PlateGirder Class")
	]
	coclass PlateGirder
	{
		[default] interface IPlateGirder;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a trapezoidal, U-Beam, or tub precast concrete girder.
   /// Implements the IUBeam interface.
   [
		uuid(F2921D46-E60C-41FC-84DD-FB4D198902C2),
		helpstring("UBeam Class")
	]
	coclass UBeam 
	{
		[default] interface IUBeam;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a trapezoidal, U-Beam, or tub precast concrete girder.
   /// Implements the IUBeam2 interface.
   [
		uuid(F75025D7-77F4-4581-A74D-4726755462D0),
		helpstring("UBeam2 Class")
	]
	coclass UBeam2
	{
		[default] interface IUBeam2;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a multi-web precast concrete girder.
   /// Implements the IMultiWeb interface.
   [
		uuid(3D4E4B7B-A78C-4419-8DCD-DAF644499AC1),
		helpstring("MultiWeb Class")
	]
	coclass MultiWeb
	{
		[default] interface IMultiWeb;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a multi-web precast concrete girder.
   /// Implements the IMultiWeb2 interface.
   [
		uuid(E115FF80-E81C-4f3f-B275-D7799BFF82A5),
		helpstring("MultiWeb2 Class")
	]
	coclass MultiWeb2
	{
		[default] interface IMultiWeb2;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing a shape that is part of a CompositeShape.
   /// Implements the ICompositeShapeItem interface.
	[
	   uuid(C0D62C37-8408-4fcb-8E9A-AA3D4498CEF4),
	   helpstring("CompositeShapeItem Class")
	]
	coclass CompositeShapeItem
	{
		[default] interface ICompositeShapeItem;
	};

   /// Object representing a generic shape that composite of CompositeShapeItem objects.
   /// Implements the ICompositeShape interface.
   ///
   /// CompositeShape objects are limited by the following assumptions:
   /// * The first shape added will be the overall boundary of the shape
   /// * The perimeter of the overall shape is defined by the boundary of the first shape
   /// * Void shapes are contained within the boundary of the first shape
   /// * Polygon representation is that of the first shape only
   [
	   uuid(57B8E907-F0CD-4915-A7C6-2060C53D7E16),
	   helpstring("CompositeShape Class")
	]
	coclass CompositeShape
	{
		[default] interface ICompositeShape;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a voided slab.
   /// Implements the IVoidedSlab interface.
	[
		uuid(3B31027D-48F3-4a8e-A9F2-3887B74E3D96),
		helpstring("VoidedSlab Class")
	]
	coclass VoidedSlab
	{
		[default] interface IVoidedSlab;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a voided slab.
   /// Implements the IVoidedSlab2 interface.
   [
		uuid(16313108-22B1-4103-9D06-1934A1AF9C3D),
		helpstring("VoidedSlab2 Class")
	]
	coclass VoidedSlab2
	{
		[default] interface IVoidedSlab2;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a box beam.
   /// Implements the IBoxBeam interface.
   [
	   uuid(62292381-C515-4aba-871B-040D739F1BA2),
	   helpstring("BoxBeam Class")
	]
	coclass BoxBeam
	{
	   [default] interface IBoxBeam;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing the shape of a decked slab beam.
   /// Implements the IDeckedSlabBeam interface.
   [
		uuid(09785C7E-27E9-4709-B4E1-4B8120CB1ECD),
		helpstring("DeckedSlabBeam Class")
	]
	coclass DeckedSlabBeam
	{
		[default] interface IDeckedSlabBeam;
		interface IShape;
		interface IXYPosition;
	};

   /// Object representing a generic shape. 
   /// Implements the IGenericShape interface
   [
		uuid(15C754B8-415F-4bf0-89C2-D5E991D51D7C),
		helpstring("GenericShape Class")
	]
	coclass GenericShape
	{
		[default] interface IGenericShape;
		interface IShape;
		interface IXYPosition;
	};

   /// Object that creates typical precast beam shapes
   /// Implements the IBeamShapeFactory interface
   [
      uuid(4B272221-CF8C-40C6-9281-12C8277B668A),
      helpstring("BeamShapeFactory")
   ]
   coclass BeamShapeFactory
   {
      [default] interface IBeamShapeFactory;
   };

   [
      uuid(FD7B2E32-6DB3-4BF2-8A0A-484B19FD1CE6),
      helpstring("ElasticProperties Class"),
      helpcontext(IDH_IElasticProperties)
   ]
   coclass ElasticProperties
   {
      [default] interface IElasticProperties;
   };
   [
      uuid(3925A3FA-34CD-4E06-AEDF-BCD1773E0810),
      helpstring("MassProperties Class"),
      helpcontext(IDH_IMassProperties)
   ]
   coclass MassProperties
   {
      [default] interface IMassProperties;
   };

   [
      uuid(D7610039-0289-11D5-8BAE-006097C68A9C),
      helpstring("CompositeBeam Class"),
      helpcontext(IDH_ICompositeBeam)
   ]
   coclass CompositeBeam
   {
      [default] interface ICompositeBeam;
   };


   [
      uuid(94267249-3C7D-40a3-BB21-DD8916BA4DE0),
      helpstring("CompositeSectionItemEx Class"),
      helpcontext(IDH_ICompositeSectionItemEx)
   ]
   coclass CompositeSectionItemEx
   {
      [default] interface ICompositeSectionItemEx;
   };
   [
      uuid(85AB469B-A6A3-4057-848A-1572DAD74DE0),
      helpstring("CompositeSectionEx Class"),
      helpcontext(IDH_ICompositeSectionEx)
   ]
   coclass CompositeSectionEx
   {
      [default] interface ICompositeSectionEx;
      interface ISection;
      interface IXYPosition;
   };
};
