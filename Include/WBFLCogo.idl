///////////////////////////////////////////////////////////////////////
// COGO - Coordinate Geometry
// Copyright © 1999-2023  Washington State Department of Transportation
//                        Bridge and Structures Office
//
// This library is a part of the Washington Bridge Foundation Libraries
// and was developed as part of the Alternate Route Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the Alternate Route Library Open Source License as 
// published by the Washington State Department of Transportation,
// Bridge and Structures Office.
//
// This program is distributed in the hope that it will be useful,
// but is distributed AS IS, WITHOUT ANY WARRANTY; without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
// PURPOSE.  See the Alternate Route Library Open Source License for more details.
//
// You should have received a copy of the Alternate Route Library Open Source License
// along with this program; if not, write to the Washington State
// Department of Transportation, Bridge and Structures Office,
// P.O. Box 47340, Olympia, WA 98503, USA or e-mail
// Bridge_Support@wsdot.wa.gov
///////////////////////////////////////////////////////////////////////

// COGO.idl : IDL source for COGO.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (COGO.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";
import "WBFLTypes.idl";
import "WBFLTools.idl";
import "WBFLGeometry.idl";
import "WBFLUnitServer.idl";

#include "COGO.hh"
#include "UnitServer.hh"

cpp_quote("#include <WBFLUnitServer.h>")

interface IProfile;
interface IPath;
interface IAlignment;
interface ISurface;
interface IBridgeGeometry;

/// Coordinate Geometry and Roadway Geometrics Modeling Library
[
    uuid(1128D28F-55F7-11D5-8C29-006097C68A9C),
    version(1.0),
   helpcontext(IDH_WBFLCogo),
    helpstring("WBFLCOGO Library")
]
library WBFLCogo
{
   importlib("stdole32.tlb");
   importlib("stdole2.tlb");

    ///     /// Constant describing the general North-South direction of a bearing
    typedef [public,helpstring("Indicates general north/south direction of a bearing"),helpcontext(IDH_NSDirectionType),uuid(AA76DB72-59E7-11d5-8C2D-006097C68A9C)] 
    enum NSDirectionType
    {
       nsNorth = 0, ///< Bearing is in a northerly direction
       nsSouth = 1  ///< Bearing is in a southerly direction
    } NSDirectionType;

    /// Constant describing the general East-West direction of a bearing
    typedef [public,helpstring("Indicates general east/west direction of a bearing"),helpcontext(IDH_EWDirectionType),uuid(AA76DB73-59E7-11d5-8C2D-006097C68A9C)] 
    enum EWDirectionType
    {
       ewEast = 0, ///< Bearing is in an easterly direction
       ewWest = 1  ///< Bearing is in a westerly direction
    } EWDirectionType;

    /// Constant identifying an entry or exit spiral
    typedef [public,helpstring("Indicates the entry or exit spiral of a horizontal curve"),helpcontext(IDH_SpiralType),uuid(66EB558D-4360-47d3-B3C0-0BC65E302333)] 
    enum SpiralType
    {
       spEntry = 0, ///< A spiral transitioning between the back tangent and the beginning of a horizontal curve
       spExit  = 1  ///< A spiral transitioning between the end of a horizontal curve and the forward tangent
    } SpiralType;

    /// Constant describing the direction of a horizontal curve, as viewed ahead on station
    typedef [public,helpstring("Indicates the direction of a horizontal curve"),helpcontext(IDH_CurveDirectionType),uuid(1620A21B-1D7E-437e-B7C8-FF71E6F44BED)] 
    enum CurveDirectionType
    {
       cdLeft  = 0, ///< Curve turns to the left (counter-clockwise)
       cdRight = 1  ///< Curve turns to the right (clockwise)
    } CurveDirectionType;

    /// Constant identifying the type of object associated with a ProfileElement object
    typedef [public,helpstring("Indicates a profile element type"),helpcontext(IDH_ProfileElementType),uuid(667D49B0-8BE7-43e6-8CE6-5245309C128C)] 
    enum ProfileElementType
    {
       pePoint, ///< Associated object is a ProfilePoint
       peProfileSegment, ///< Associated object is a ProfileSegment
       peVertCurve  ///< Associated object is a VertCurve
    } ProfileElementType;

    /// Constant identifying the type of object associated with a PathElement object
    typedef [public, helpstring("Indicates an alignment element type"), helpcontext(IDH_PathElementType), uuid(A5FC1519-B488-4943-94FC-ACBA59BCB733)]
    enum PathElementType
    {
       petPoint          , ///< Associated object is a WBFLGeometry::Point2d
       petPathSegment    , ///< Associated object is a PathSegment
       petCircularCurve  , ///< Associated object is a CircularCurve
       petTransitionCurve, ///< Associated object is a TransitionCurve
       petCompoundCurve  , ///< Associated object is a CompoundCurve
       petCubicSpline    , ///< Associated object is a CubicSpline
       petPath             ///< Associated object is a Path
    } PathElementType;

    /// Constant identifying the direction of the angle formed by a circular curve tangent line and the line connecting the centers of circles. See documentation for ITangent interface for usage.
    typedef [public,helpstring("Indicates the direction of the angle formed by a circular tangent line and the line connecting the centers of the circles"),helpcontext(IDH_TangentSignType),uuid(ED58941C-11B9-484e-A9D6-D07ADB1FA0A3)] 
    enum TangentSignType
    {
       tsCCW = 1, ///< Counter-clockwise angle
       tsCW  = -1, ///< Clockwise angle
    } TangentSignType;

    /// Constant describing the method by which the degree of curve is computed
    typedef [public,helpstring("Indicates the method for computing the degree of curvature"),helpcontext(IDH_DegreeCurvatureType),uuid(26428AC0-AEE2-4bdb-8CC9-8C13F531A4B7)] 
    enum DegreeCurvatureType
    {
       dcChord    =  1, ///< Computed by the length of chord method
       dcArc      =  2, ///< Computed by the length of arc method
       dcRailroad =  1, ///< Same as dcChord
       dcHighway  =  2, ///< Same as dcArc
    } DegreeCurvatureType;

    /// Constant defining the type of transition curve
    typedef [public, helpstring("Indicates the type of transition curve"), uuid(29D2E57D-1010-432F-86C5-39EE00405248)]
    enum TransitionCurveType
    {
       Clothoid, ///< A clothoid curve
       //Bloss, ... and others in the future
    } TransitionCurveType;

    /// Constant describing how an offset is measured
    typedef [public,helpstring("Indicates how an offset is measured"),uuid(50A94F9E-EACB-4b60-936F-23E5F4F24C86)] 
    enum OffsetMeasureType
    {
       omtAlongDirection =  0, ///< Offset is measured along a line projecting from an object
       omtNormal         =  1, ///< Offset is measured normal to object
    } OffsetMeasureType;

    /// Constant defining the type of superelevation transition
    typedef [public,helpstring("Defines superelevation transition type"),uuid(9CF798F5-D551-4b7f-A5BB-FAF9C3AEDA8B)]
    enum SuperTransitionType
    {
       stLinear,    ///< Superelevation transition is linear
       stParabolic  ///< Superelevation transition is parabolic
    } SuperTransitionType;

    /// Constant defining how a template segment slope is measured
    typedef [public,helpstring("Defines how a template segment slope is measured"),uuid(E565E720-42ED-47b5-A00C-6435E6E8195A)]
    enum TemplateSlopeType
    {
       tsHorizontal,      ///< measured as rise over 1
       tsFixedHorizontal, ///< measured as rise over 1 and is not changed by superelevations
       tsFixedVertical    ///< measured as 1 over run and is not changed by superelevations
    } TemplateSlopeType;


    typedef [public, helpstring("enum GirderLineType"), uuid(621DA6BE-19C3-49FE-9227-95F988D8A6BF)]
       enum
    {
       glChord = 0, // straight line chord
       glPath = 1  // finite length path (curved)
    } GirderLineType;

    // un-comment after GenericBridge becomes obsolete
    typedef [public, helpstring("enum PierFaceType"), uuid(FC45D43A-BE9D-4725-8913-E2B2947CEC73)]
       enum
    {
       pfBack = 0,
       pfAhead = 1
    } PierFaceType;

    typedef [public, helpstring("enum DeckBoundaryEdgeType"), uuid(45561BA8-9178-4AEF-8B2B-C25BA2D09E1B)]
       enum
    {
       setPier, // DeckBoundary edge defined by pier CL
       setLayout // DeckBoundary edge defined by layout line
    } DeckBoundaryEdgeType;

    typedef [public, helpstring("enum MeasurementType"), uuid(A8F6552D-A5A9-40DB-9562-B33623CC9C31)]
       enum
    {
       mtAlongItem = 0,
       mtNormal = 1
    } MeasurementType;

    typedef [public, helpstring("enum MeasurementLocation"), uuid(A884BF5A-0C8F-4D89-BDA7-114E6944A9D0)]
       enum
    {
       mlPierLine = 0,
       mlCenterlineBearing = 1
    } MeasurementLocation;

    typedef [public, helpstring("enum EndType"), uuid(834FAD6D-79ED-4253-A49C-8B3CB270C899)]
       enum
    {
       etStart = 0,
       etEnd = 1
    } EndType;

    typedef [public, helpstring("enum SideType"), uuid(73C1F1F8-36DE-4042-A9A5-A1CC07F1C323)]
       enum
    {
       stLeft = 0,
       stRight = 1
    } SideType;


    /// Interface for objects that represents an angle. 
    /// Counter-clockwise angles (Left) angles have positive values
    [
        object,
        uuid(2C98A246-55F7-11D5-8C29-006097C68A9C),
        oleautomation,
      helpcontext(IDH_Angle),
        helpstring("IAngle Interface"),
        pointer_default(unique)
    ]
    interface IAngle : IUnknown
    {
       /// The value of the angle in radians.
        [propget, helpstring("property Value"),helpcontext(IDH_Angle_Value)] HRESULT Value([out, retval] Float64 *pVal);
        [propput, helpstring("property Value"),helpcontext(IDH_Angle_Value)] HRESULT Value([in] Float64 newVal);
        
        /// Returns the degree portion of the angle in DMS format
        [propget, helpstring("property Degree"),helpcontext(IDH_Angle_Degree)] HRESULT Degree([out, retval] long *pVal);

        /// Returns the minute portion of the angle in DMS format
        [propget, helpstring("property Minute"),helpcontext(IDH_Angle_Minute)] HRESULT Minute([out, retval] long *pVal);

        /// Returns the second portion of the angle in DMS format
        [propget, helpstring("property Second"),helpcontext(IDH_Angle_Second)] HRESULT Second([out, retval] Float64 *pVal);

        /// Normalizes the angle by causing the value to be between 0 and \f$2\pi\f$ radians
        [helpstring("method Normalize"),helpcontext(IDH_Angle_Normalize)] HRESULT Normalize();

        /// Sets the value of the angle from DMS values
        [helpstring("method FromDMS"),helpcontext(IDH_Angle_FromDMS)] HRESULT FromDMS([in] long deg,[in] long min,[in] Float64 sec);

        /// Sets the value of the angle from a text string. The format of the text string is described in \ref WBFL_COGO_Angles_Directions_Stations
        [helpstring("method FromString"),helpcontext(IDH_Angle_FromString)] HRESULT FromString([in] BSTR bstrAngle);

        /// Sets the value of the angle using a VARIANT. The VARIANT can contain the angle as a value or a string. The format of the text string is described in \ref WBFL_COGO_Angles_Directions_Stations
        [helpstring("method FromVariant")] HRESULT FromVariant([in] VARIANT varAngle);

        ///	Creates a new Angle that is equal to this Angle plus a increment
        /// The increment angle can be specified using an Angle object, numeric value, or string.
        [helpstring("method Increment"),helpcontext(IDH_Angle_Increment)] HRESULT Increment(
           [in] VARIANT varAngle, ///< the increment angle
           [out,retval] IAngle* *pVal ///< the new angle
        );

        /// Increments this Angle by a specified angle
        /// The increment angle can be specified using an Angle object, numeric value, or string. The resulting angle is not normalized.
        [helpstring("method IncrementBy"),helpcontext(IDH_Angle_IncrementBy)] HRESULT IncrementBy([in] VARIANT varAngle);

        /// Creates a copy of this object
        [helpstring("method Clone"),helpcontext(IDH_Angle_Clone)] HRESULT Clone([out,retval] IAngle* *clone);
    };

    /// Interface for objects that represents a direction. A direction can be a bearing or an azimuth.
    [
        object,
        uuid(2C98A251-55F7-11D5-8C29-006097C68A9C),
        oleautomation,
      helpcontext(IDH_Direction),
        helpstring("IDirection Interface"),
        pointer_default(unique)
    ]
    interface IDirection : IUnknown
    {
        /// Returns the direction value as an azimuth
        [propget, helpstring("property Azimuth"),helpcontext(IDH_Direction_Azimuth)] HRESULT Azimuth([out, retval] Float64 *pVal);

        /// Value of the direction as a bearing
        [propget, helpstring("property Value"),helpcontext(IDH_Direction_Value)] HRESULT Value([out, retval] Float64 *pVal);
        [propput, helpstring("property Value"),helpcontext(IDH_Direction_Value)] HRESULT Value([in] Float64 newVal);

        /// North-South direction
        [propget, helpstring("property NSDirection"),helpcontext(IDH_Direction_NSDirection)] HRESULT NSDirection([out, retval] NSDirectionType *pVal);
        [propput, helpstring("property NSDirection"),helpcontext(IDH_Direction_NSDirection)] HRESULT NSDirection([in] NSDirectionType newVal);

        /// East-West direction
        [propget, helpstring("property EWDirection"),helpcontext(IDH_Direction_EWDirection)] HRESULT EWDirection([out, retval] EWDirectionType *pVal);
        [propput, helpstring("property EWDirection"),helpcontext(IDH_Direction_EWDirection)] HRESULT EWDirection([in] EWDirectionType newVal);

        /// Degree portion of the direction (DMS format)
        [propget, helpstring("property Degree"),helpcontext(IDH_Direction_Degree)] HRESULT Degree([out, retval] long *pVal);
        [propput, helpstring("property Degree"),helpcontext(IDH_Direction_Degree)] HRESULT Degree([in] long newVal);

        /// Minute portion of the direction (DMS format)
        [propget, helpstring("property Minute"),helpcontext(IDH_Direction_Minute)] HRESULT Minute([out, retval] long *pVal);
        [propput, helpstring("property Minute"),helpcontext(IDH_Direction_Minute)] HRESULT Minute([in] long newVal);

        /// Second portion of the direction (DMS format)
        [propget, helpstring("property Second"),helpcontext(IDH_Direction_Second)] HRESULT Second([out, retval] Float64 *pVal);
        [propput, helpstring("property Second"),helpcontext(IDH_Direction_Second)] HRESULT Second([in] Float64 newVal);

        /// Creates a new direction that is equal to this direction plus an angular increment
        [helpstring("method Increment"),helpcontext(IDH_Direction_Increment)] HRESULT Increment(
           [in] VARIANT varAngle, ///< The angular increment in one of the formats described in \ref WBFL_COGO_Angles_Directions_Stations
           [out,retval] IDirection* *pVal ///< The new direction object
        );

        /// Increments this direction by a specified angle
        [helpstring("method IncrementBy"),helpcontext(IDH_Direction_IncrementBy)] HRESULT IncrementBy(
           [in] VARIANT varAngle ///< The angular increment in one of the formats described in \ref WBFL_COGO_Angles_Directions_Stations
        );

        /// Sets the value of this direction from a text string. The format of the text string is described in \ref WBFL_COGO_Angles_Directions_Stations
        [helpstring("method FromString"),helpcontext(IDH_Direction_FromString)] HRESULT FromString(
           [in] BSTR bstrDir ///< Direction as a text string as described in \ref WBFL_COGO_Angles_Directions_Stations
        );

        /// Sets the value of this direction from DMS values
        [helpstring("method FromDMS"),helpcontext(IDH_Direction_FromDMS)] HRESULT FromDMS(
           [in] NSDirectionType ns, ///< North-South direction
           [in] long Degree, ///< degree portion of angle
           [in] long Minute,  ///< minute portion of angle
           [in] Float64 Second,  ///< second portion of angle
           [in] EWDirectionType ew ///< East-West direction
        );

        /// Sets the value of this direction with a floating point azimuth value
        [helpstring("method FromAzimuth"),helpcontext(IDH_Direction_FromAzimuth)] HRESULT FromAzimuth(
           [in] Float64 azimuth ///< azimuth as a decimal value
        );

        /// Sets the value of this direction with an azimuth in DMS format
        [helpstring("method FromAzimuth"),helpcontext(IDH_Direction_FromAzimuth)] HRESULT FromAzimuthEx(
           [in] long Degree,  ///< degree portion of azimuth
           [in] long Minute,  ///< minute portion of azimuth
           [in] Float64 Second ///< second portion of azimuth
        );

        /// Sets the value of this direction using a VARIANT. The VARIANT can contain the direction as a value or a string. The format of the text string is described in \ref WBFL_COGO_Angles_Directions_Stations
        [helpstring("method FromVariant")] HRESULT FromVariant(
           [in] VARIANT varDirection ///< direction value
        );

        /// Returns the angle between this direction object an another direction object
        /// \image html AngleBetween.jpg
        [helpstring("method AngleBetween"),helpcontext(IDH_Direction_AngleBetween)] HRESULT AngleBetween(
           [in] IDirection* dir, ///< the direction with which this angle is to be computed
           [out,retval]IAngle** pVal ///< Angle between the two directions
        );

        /// Creates a clone of this object
        [helpstring("method Clone"),helpcontext(IDH_Direction_Clone)] HRESULT Clone([out,retval] IDirection* *clone);

        /// Compares this and another direction. Returns S_OK if they are equal, otherwise returns S_FALSE
        [helpstring("method IsEqual")] HRESULT IsEqual(IDirection* pDirection);
    };

    /// Extends the IDisplayUnitFormatter interface to format angles
   [
      object,
      uuid(739D2AB4-A3E9-4BCC-AC06-75E8293C08B7),
      oleautomation,
      helpcontext(IDH_AngleDisplayUnitFormatter),
      helpstring("IAngleDisplayUnitFormatter Interface"),
      pointer_default(unique)
   ]
   interface IAngleDisplayUnitFormatter : IDisplayUnitFormatter
   {
      /// Specifies whether the condensed angle format should be used.
      ///
      /// When the minutes and seconds part of an angle are zero, such as "45 00 00 L", the zeros are omitted when condensed formatting is used resulting in "45 L"
      [propget, helpstring("property CondensedFormat"),helpcontext(IDH_AngleDisplayUnitFormatter_CondensedFormat)] HRESULT CondensedFormat([out, retval] VARIANT_BOOL *pVal);
      [propput, helpstring("property CondensedFormat"),helpcontext(IDH_AngleDisplayUnitFormatter_CondensedFormat)] HRESULT CondensedFormat([in] VARIANT_BOOL newVal);

      /// Specifies if the angle is formatted as a signed angle or a directional angle.
      ///
      /// The degrees portion of a signed angle is preceded with a minus sign (-) if its value is less than zero. Otherwise, the formatted angle will be adorned with L or R. 
      /// Example: value = -45, signed format: -45° 00' 00", not signed format 45° 00' 00" R
      [propget, helpstring("property Signed"),helpcontext(IDH_AngleDisplayUnitFormatter_Signed)] HRESULT Signed([out, retval] VARIANT_BOOL *pVal);
      [propput, helpstring("property Signed"),helpcontext(IDH_AngleDisplayUnitFormatter_Signed)] HRESULT Signed([in] VARIANT_BOOL newVal);
   };

   /// Extends the IDisplayUnitFormatter interface to format directions
   [
      object,
      uuid(FFA2F69D-8B5B-40ED-9802-35BEA09551B7),
      oleautomation,
      helpcontext(IDH_DirectionDisplayUnitFormatter),
      helpstring("IDirectionDisplayUnitFormatter Interface"),
      pointer_default(unique)
   ]
   interface IDirectionDisplayUnitFormatter : IDisplayUnitFormatter
   {
      /// Specifies whether the condensed direction format should be used.
      ///
      /// When the minutes and seconds part of a direction are zero, such as "N 45 00 00 E", the zeros are omitted when condensed formatting is used resulting in "N 45 E"
      [propget, helpstring("property CondensedFormat"),helpcontext(IDH_DirectionDisplayUnitFormatter_CondensedFormat)] HRESULT CondensedFormat([out, retval] VARIANT_BOOL *pVal);
      [propput, helpstring("property CondensedFormat"),helpcontext(IDH_DirectionDisplayUnitFormatter_CondensedFormat)] HRESULT CondensedFormat([in] VARIANT_BOOL newVal);

      /// Specifies if the direction is formatted as a bearing or an azimuth.
      [propget, helpstring("property BearingFormat"),helpcontext(IDH_DirectionDisplayUnitFormatter_BearingFormat)] HRESULT BearingFormat([out, retval] VARIANT_BOOL *pVal);
      [propput, helpstring("property BearingFormat"),helpcontext(IDH_DirectionDisplayUnitFormatter_BearingFormat)] HRESULT BearingFormat([in] VARIANT_BOOL newVal);
   };

    /// Interface for path segments
    /// 
    [
       object,
       uuid(005E87F7-F9B1-4CEA-B628-0EE3442728B6),
       oleautomation,
       helpstring("IPathSegment Interface"),
       pointer_default(unique)
    ]
    interface IPathSegment : IUnknown //IPathElement // See note for ICompoundCurve
    {
       [helpstring("method ThroughPoints")] HRESULT ThroughPoints(IPoint2d* pStart, IPoint2d* pEnd);
       [] HRESULT Offset(Float64 offset);
    };

    /// Interface for transition curves
    ///
    /// The curve radii must have the same sign (reverse curves are not supported). Positive values indicate curves to the left.
    /// Use a radius of 0.0 to indicate infinite radius (such as tangency to a straight line)
    [
       object,
       uuid(FF1D5D07-D3A3-402E-86F6-E3D56E3EB44C),
       oleautomation,
       helpstring("ITransitionCurve Interface"),
       pointer_default(unique)
    ]
    interface ITransitionCurve : IUnknown//IPathElement // See note for ICompoundCurve
    {
        /// Initializes the curve. Use a radius of zero to indicate infinite radius.
       [helpstring("method Init")] HRESULT Init(
          [in]IPoint2d* pStart,  ///< Start point of the transition curve
          [in]VARIANT varStartDirection,  ///< Direction of curve tangent at the start of the transition curve
          [in]Float64 R1,  ///< Radius at the start of the curve (Positive values for curves to the left)
          [in]Float64 R2,  ///< Radius at the end of the curve (Positive values for curves to the left)
          [in]Float64 L, ///< Length of the curve
          [in]TransitionCurveType type ///< Transition curve type
       );

       /// Returns the tangent direction at the start of the curve
       [propget, helpstring("property StartDirection")] HRESULT StartDirection([out, retval]IDirection * *pStartDirection);

       /// Returns the tangent direction at the end of the curve
       [propget, helpstring("property EndDirection")] HRESULT EndDirection([out, retval]IDirection** pEndDirection);

       /// Returns the radius at the start of the curve
       [propget, helpstring("property R1")] HRESULT R1([out, retval]Float64* pR1);

       /// Returns the radius at the end of the curve
       [propget, helpstring("property R2")] HRESULT R2([out, retval]Float64* pR2);

       /// Returns the type of transition curve
       [propget, helpstring("property Type")] HRESULT Type([out, retval]TransitionCurveType* pType);

       /// Returns the radius at the specified distance from the start of the transition curve
       /// Radius of zero indicates infinite radius
       [helpstring("method GetRadius")] HRESULT GetRadius([in]Float64 distance, [out, retval]Float64* pRadius);

       /// Returns the distance along the tangent from the start of the curve to a perpendicular offset to the end of the spiral.
       /// \image html /TransitionCurve/Spiral.png
       [propget, helpstring("property X")] HRESULT X([out, retval]Float64* x);

       /// Returns the offset from the tangent to the spiral at its maximum degree of curvature measured along a perpendicular from the tangent to the end of the transition curve.
       /// \image html /TransitionCurve/Spiral.png
       [propget, helpstring("property Y")] HRESULT Y([out, retval]Float64* y);

       /// Returns the long tangent of the spiral
       /// \image html /TransitionCurve/Spiral.png
       [propget, helpstring("property LongTangent")] HRESULT LongTangent([out, retval]Float64* u);

       /// Returns the short tangent of the spiral
       /// \image html /TransitionCurve/Spiral.png
       [propget, helpstring("property ShortTangent")] HRESULT ShortTangent([out, retval]Float64* v);

       /// Returns the intersection point of the curve tangents
       [propget, helpstring("property PI")] HRESULT PI([out, retval]IPoint2d** pPI);

       /// Returns the subtended angle of the curve
       [propget, helpstring("property Angle")] HRESULT Angle([out, retval]IAngle** ppAngle);

       /// Returns the direction if the curve. The direction is as viewed looking ahead on station.
       [propget, helpstring("property Direction")] HRESULT Direction([out, retval] CurveDirectionType* dir);

       /// Projects a point onto the curve such that a line perpendicular to the curve passes through the point. 
       /// If the projected point falls before the Start point, or after the End point, then it will be a point on the back or forward tangent, respectively.
       [helpstring("method ProjectPoint")] HRESULT ProjectPoint(
          [in] IPoint2d* point,  ///< Point to be projected
          [out] IPoint2d** pNewPoint,  ///< Projection point
          [out] Float64* distFromStart, ///< Distance from start of curve to projection point
          [out] VARIANT_BOOL* pvbOnProjection ///< Set to VARIANT_TRUE if the point projects onto the back or forward tangent
       );
       
       /// Computes the distance along the curve from the start point to a specified point
       [helpstring("method DistanceFromStart")] HRESULT DistanceFromStart([in] IPoint2d* point, [out, retval] Float64* dist);

       /// Determines the points where a line intersects the curve
       [helpstring("method Intersect")] HRESULT Intersect(
          [in]ILine2d* line, ///< The line to intersect with the spline
          [in]VARIANT_BOOL bProjectBack, ///< If VARIANT_TRUE, the back tangent is projected and intersected with line
          [in]VARIANT_BOOL bProjectAhead, ///< If VARIANT_TRUE, the ahead tangent is projected and intersected with line
          [out, retval]IPoint2dCollection** points ///< A collection of intersection points
       );
    };

    /// Interface for compound horizontal curve objects.
    ///
    /// A compound curve is defined by a point on the back tangent, the intersection point of the back and forward tangents, 
    /// a point on the forward tangent, and the radius. Entry and/or exit clothoid spirals can be added to the curve by 
    /// defining their length. Input values are denoted in red in the figure below. 
    /// \image html /CompoundCurve/CompoundCurve.jpg
   [
       object,
       uuid(7E56BBC9-AC81-4B6D-8366-319DEE51A0D8),
       oleautomation,
      helpcontext(IDH_CompoundCurve),
       helpstring("ICompoundCurve Interface"),
       pointer_default(unique)
   ]
   interface ICompoundCurve : IUnknown//IPathElement // Not sure why but when ICompoundCurve inherits from IPathElement the IDL files that import this IDL file (like WBFLBridgeGeomtry.idl) don't compile. For consistency, all IPathElement objects derive from IUnknown
   {
      /// Point on back tangent
       [propget, helpstring("property PBT"), helpcontext(IDH_CompoundCurve_PBT)] HRESULT PBT([out, retval] IPoint2d* *pVal);
       [propput, helpstring("property PBT"), helpcontext(IDH_CompoundCurve_PBT)] HRESULT PBT([in] IPoint2d* newVal);

       /// Point of intersection
       [propget, helpstring("property PI"), helpcontext(IDH_CompoundCurve_PI)] HRESULT PI([out, retval] IPoint2d* *pVal);
       [propput, helpstring("property PI"), helpcontext(IDH_CompoundCurve_PI)] HRESULT PI([in] IPoint2d* newVal);

       /// Point on forward tangent
       [propget, helpstring("property PFT"), helpcontext(IDH_CompoundCurve_PFT)] HRESULT PFT([out, retval] IPoint2d* *pVal);
       [propput, helpstring("property PFT"), helpcontext(IDH_CompoundCurve_PFT)] HRESULT PFT([in] IPoint2d* newVal);

       /// Circular curve radius
       [propget, helpstring("property Radius"), helpcontext(IDH_CompoundCurve_Radius)] HRESULT Radius([out, retval] Float64 *pVal);
       [propput, helpstring("property Radius"), helpcontext(IDH_CompoundCurve_Radius)] HRESULT Radius([in] Float64 newVal);

       /// Length of transition spiral
       [propget, helpstring("property SpiralLength"), helpcontext(IDH_CompoundCurve_SpiralLength)] HRESULT SpiralLength([in] SpiralType spType,[out, retval] Float64 *pVal);
       [propput, helpstring("property SpiralLength"), helpcontext(IDH_CompoundCurve_SpiralLength)] HRESULT SpiralLength([in] SpiralType spType,[in] Float64 newVal);

       /// Returns the spiral curve angle
       [propget, helpstring("property SpiralAngle"), helpcontext(IDH_CompoundCurve_SpiralAngle)] HRESULT SpiralAngle([in] SpiralType spType,[out, retval] IAngle* *pVal);

       /// Returns the distance along the tangent from TS (or ST) to a perpendicular offset to the end of the spiral.
       /// \image html /CompoundCurve/Spiral.jpg
      [propget, helpstring("property X"), helpcontext(IDH_CompoundCurve_X)] HRESULT X([in]SpiralType spType,[out,retval]Float64* x);

      /// Returns the offset from the tangent to the spiral at its maximum degree of curvature measured along a perpendicular from the tangent to SC (or CS).
      /// \image html /CompoundCurve/Spiral.jpg
      [propget, helpstring("property Y"), helpcontext(IDH_CompoundCurve_Y)] HRESULT Y([in]SpiralType spType,[out,retval]Float64* y);

      /// Returns the offset distance that the entire circular curve is radially set in from the tangents to allow for spiral connections.
      /// \image html /CompoundCurve/Spiral.jpg
      [propget, helpstring("property Q"), helpcontext(IDH_CompoundCurve_Q)] HRESULT Q([in]SpiralType spType,[out,retval]Float64* q);

      /// Returns the distance T
      /// \image html /CompoundCurve/Spiral.jpg
      [propget, helpstring("property T"), helpcontext(IDH_CompoundCurve_T)] HRESULT T([in]SpiralType spType,[out,retval]Float64* t);

      /// Returns the back tangent bearing
      [propget, helpstring("property BkTangentBrg"), helpcontext(IDH_CompoundCurve_BkTangentBrg)] HRESULT BkTangentBrg([out,retval]IDirection* *brg);

      /// Returns the forward tangent bearing
      [propget, helpstring("property FwdTangentBrg"), helpcontext(IDH_CompoundCurve_FwdTangentBrg)] HRESULT FwdTangentBrg([out,retval]IDirection* *brg);

      /// Returns the back tangent length
      [propget, helpstring("property BkTangentLength"), helpcontext(IDH_CompoundCurve_BkTangentLength)] HRESULT BkTangentLength([out,retval]Float64* t);

      /// Returns the forward tangent length.
      [propget, helpstring("property FwdTangentLength"), helpcontext(IDH_CompoundCurve_FwdTangentLength)] HRESULT FwdTangentLength([out,retval]Float64* t);
      
      /// Returns the total angle of the curve.
      [propget, helpstring("property CurveAngle"), helpcontext(IDH_CompoundCurve_CurveAngle)] HRESULT CurveAngle([out, retval] IAngle* *pVal);

      /// Returns the tangent to spiral point
      [propget, helpstring("property TS"), helpcontext(IDH_CompoundCurve_TS)] HRESULT TS([out, retval] IPoint2d* *pVal);

      /// Returns the spiral to tangent point
       [propget, helpstring("property ST"), helpcontext(IDH_CompoundCurve_ST)] HRESULT ST([out, retval] IPoint2d* *pVal);

       /// Returns the spiral to circular curve point
       [propget, helpstring("property SC"), helpcontext(IDH_CompoundCurve_SC)] HRESULT SC([out, retval] IPoint2d* *pVal);

       /// returns the circular curve to spiral point
       [propget, helpstring("property CS"), helpcontext(IDH_CompoundCurve_CS)] HRESULT CS([out, retval] IPoint2d* *pVal);

       /// Returns the chord length of the circular curve
       /// \image html /CompoundCurve/CircularCurve.jpg
      [propget, helpstring("property Chord"), helpcontext(IDH_CompoundCurve_Chord)] HRESULT Chord([out,retval]Float64* chord);

      /// Returns the internal angle of the circular curve
       [propget, helpstring("property CircularCurveAngle"), helpcontext(IDH_CompoundCurve_CircularCurveAngle)] HRESULT CircularCurveAngle([out, retval] IAngle* *pVal);

       /// Returns the length of the circular curve tangent
       /// \image html /CompoundCurve/CircularCurve.jpg
       [propget, helpstring("property Tangent"), helpcontext(IDH_CompoundCurve_Tangent)] HRESULT Tangent([out,retval]Float64* tangent);

       /// Returns the length of the circular curve mid-ordinate
       /// \image html /CompoundCurve/CircularCurve.jpg
       [propget, helpstring("property MidOrdinate"), helpcontext(IDH_CompoundCurve_MidOrdinate)] HRESULT MidOrdinate([out,retval]Float64* mo);

       /// Returns the length of the circular curve external
       /// \image html /CompoundCurve/CircularCurve.jpg
       [propget, helpstring("property External"), helpcontext(IDH_CompoundCurve_External)] HRESULT External([out,retval]Float64* external);
      
       /// Returns the deviation angle of the spiral
       /// \image html /CompoundCurve/Spiral.jpg
       [propget, helpstring("property DE"), helpcontext(IDH_CompoundCurve_DE)] HRESULT DE([in]SpiralType spType,[out,retval]IAngle* *pDE);
       
       /// Returns the long tangent of the spiral
       /// \image html /CompoundCurve/Spiral.jpg
       [propget, helpstring("property LongTangent"), helpcontext(IDH_CompoundCurve_LongTangent)] HRESULT LongTangent([in]SpiralType spType,[out,retval]Float64* u);

       /// Returns the short tangent of the spiral
       /// \image html /CompoundCurve/Spiral.jpg
       [propget, helpstring("property ShortTangent"), helpcontext(IDH_CompoundCurve_ShortTangent)] HRESULT ShortTangent([in]SpiralType spType,[out,retval]Float64* v);

       /// Returns the center point of the curve. The center point of the curve is taken to be the intersection of lines perpendicular to the back and forward tangents at TS and ST.
       [propget, helpstring("property CC"), helpcontext(IDH_CompoundCurve_CC)] HRESULT CC([out, retval] IPoint2d* *pVal);

       /// Returns the intersection point of the circular curve tangents
       [propget, helpstring("property PCI"), helpcontext(IDH_CompoundCurve_PCI)] HRESULT PCI([out, retval] IPoint2d* *pVal);

       /// Returns the intersection point of the spiral tangents
      [propget, helpstring("property SPI"), helpcontext(IDH_CompoundCurve_SPI)] HRESULT SPI([in]SpiralType spType,[out,retval]IPoint2d** pSPI);

      /// Returns the back tangent of the circular curve
      [propget, helpstring("property CurveBkTangentBrg"), helpcontext(IDH_CompoundCurve_CurveBkTangentBrg)] HRESULT CurveBkTangentBrg([out,retval]IDirection* *brg);

      /// Returns the forward tangent of the circular curve
      [propget, helpstring("property CurveFwdTangentBrg"), helpcontext(IDH_CompoundCurve_CurveFwdTangentBrg)] HRESULT CurveFwdTangentBrg([out,retval]IDirection* *brg);

      /// Returns the center point of the circular curve. The center point of the curve is taken to be the intersection of lines perpendicular to the back and forward tangents of the circular curve at SC and CS.
       [propget, helpstring("property CCC"), helpcontext(IDH_CompoundCurve_CCC)] HRESULT CCC([out, retval] IPoint2d* *pVal);
       
       /// Returns the deflection angle of the spiral
       /// \image html /CompoundCurve/Spiral.jpg
       [propget, helpstring("property DF"), helpcontext(IDH_CompoundCurve_DF)] HRESULT DF([in]SpiralType spType,[out,retval] IAngle** pDF);

       /// Returns the difference between DE and DF
       /// \image html /CompoundCurve/Spiral.jpg
       [propget, helpstring("property DH"), helpcontext(IDH_CompoundCurve_DH)] HRESULT DH([in]SpiralType spType,[out,retval] IAngle** pDH);

       /// Returns the chord length of the spiral
         [propget, helpstring("property SpiralChord"), helpcontext(IDH_CompoundCurve_SpiralChord)] HRESULT SpiralChord([in]SpiralType spType,[out,retval] Float64* cs);

         /// Returns the direction if the curve. The direction is as viewed looking ahead on station.
         [propget, helpstring("property Direction"), helpcontext(IDH_CompoundCurve_Direction)] HRESULT Direction([out,retval] CurveDirectionType* dir);

         /// Returns the length of the circular curve
      [propget, helpstring("property CurveLength"), helpcontext(IDH_CompoundCurve_CurveLength)] HRESULT CurveLength([out,retval] Float64* pVal);

      /// Returns the total length of the horizontal curve
      [propget, helpstring("property TotalLength"), helpcontext(IDH_CompoundCurve_TotalLength)] HRESULT TotalLength([out,retval] Float64* pVal);

      /// Returns the degree of curvature of the circular curve.
      ///
      /// The degree of curvature can be computed by either the arc or chord method.
      ///
      /// Arc Method: \f[ dc = \frac{\Delta}{R} \f]
      /// Chord Method: \f[ dc = 2\sin^{-1}\frac{\Delta}{2R} \f]
      [propget, helpstring("property DegreeCurvature"), helpcontext(IDH_CompoundCurve_DegreeCurvature)] HRESULT DegreeCurvature([in] Float64 D,[in] DegreeCurvatureType dcMethod,[out,retval] IAngle** pDC);
   };

   /// Interface for circular horizontal curve objects.
   ///
   /// A circular curve is defined by a point on the back tangent, the intersection point of the back and forward tangents, 
   /// a point on the forward tangent, and the radius. Entry and/or exit clothoid spirals can be added to the curve by 
   /// defining their length. Input values are denoted in red in the figure below. 
   /// \image html /CircularCurve/CircularCurve.png
   [
       object,
       uuid(D02C31CC-24E5-439F-9E2C-1E61C7203C69),
       oleautomation,
       helpstring("ICircularCurve Interface"),
       pointer_default(unique)
   ]
   interface ICircularCurve : IUnknown//IPathElement // See note for ICompoundCurve
   {
       /// Point on back tangent
       [propget, helpstring("property PBT")] HRESULT PBT([out, retval] IPoint2d** pVal);
       [propput, helpstring("property PBT")] HRESULT PBT([in] IPoint2d* newVal);

       /// Point of intersection
       [propget, helpstring("property PI")] HRESULT PI([out, retval] IPoint2d** pVal);
       [propput, helpstring("property PI")] HRESULT PI([in] IPoint2d* newVal);

       /// Point on forward tangent
       [propget, helpstring("property PFT")] HRESULT PFT([out, retval] IPoint2d** pVal);
       [propput, helpstring("property PFT")] HRESULT PFT([in] IPoint2d* newVal);

       /// Circular curve radius
       [propget, helpstring("property Radius")] HRESULT Radius([out, retval] Float64* pVal);
       [propput, helpstring("property Radius")] HRESULT Radius([in] Float64 newVal);

       /// Returns the point of curvature at the start of the curve
       [propget, helpstring("property PC")] HRESULT PC([out, retval] IPoint2d** pVal);

       /// Returns the point of tangency at the end of the curve
       [propget, helpstring("property PT")] HRESULT PT([out, retval] IPoint2d** pVal);
       
       /// Returns the back tangent bearing
       [propget, helpstring("property BkTangentBrg")] HRESULT BkTangentBrg([out, retval]IDirection** brg);

       /// Returns the forward tangent bearing
       [propget, helpstring("property FwdTangentBrg")] HRESULT FwdTangentBrg([out, retval]IDirection** brg);

       /// Returns the tangent length
       [propget, helpstring("property TangentLength")] HRESULT TangentLength([out, retval]Float64* t);

       /// Returns the total angle of the curve.
       [propget, helpstring("property Angle")] HRESULT Angle([out, retval] IAngle** pVal);

       /// Returns the chord length of the circular curve
       /// \image html /CircularCurve/CircularCurve.png
       [propget, helpstring("property Chord")] HRESULT Chord([out, retval]Float64* chord);

       /// Returns the length of the circular curve tangent
       /// \image html /CircularCurve/CircularCurve.png
       [propget, helpstring("property Tangent")] HRESULT Tangent([out, retval]Float64* tangent);

       /// Returns the length of the circular curve mid-ordinate
       /// \image html /CircularCurve/CircularCurve.png
       [propget, helpstring("property MidOrdinate")] HRESULT MidOrdinate([out, retval]Float64* mo);

       /// Returns the length of the circular curve external
       /// \image html /CircularCurve/CircularCurve.png
       [propget, helpstring("property External")] HRESULT External([out, retval]Float64* external);

       /// Returns the center point of the curve. The center point of the curve is taken to be the intersection of lines perpendicular to the back and forward tangents at TS and ST.
       [propget, helpstring("property Center")] HRESULT Center([out, retval] IPoint2d** pVal);

       /// Returns the direction if the curve. The direction is as viewed looking ahead on station.
       [propget, helpstring("property Direction")] HRESULT Direction([out, retval] CurveDirectionType* dir);

       /// Returns the degree of curvature of the circular curve.
       ///
       /// The degree of curvature can be computed by either the arc or chord method.
       ///
       /// Arc Method: \f[ dc = \frac{\Delta}{R} \f]
       /// Chord Method: \f[ dc = 2\sin^{-1}\frac{\Delta}{2R} \f]
       [propget, helpstring("property DegreeCurvature")] HRESULT DegreeCurvature([in] Float64 D, [in] DegreeCurvatureType dcMethod, [out, retval] IAngle** pDC);
   };

   /// Interface for objects that represent a Station.
   [
      object,
      uuid(337799AD-766C-4FB7-A238-9A4C61FFBE29),
      oleautomation,
      helpcontext(IDH_Station),
      helpstring("IStation Interface"),
      pointer_default(unique)
   ]
   interface IStation : IUnknown
   {
      /// Initializes the station object using a variant.
      ///
      /// The variant can be:
      /// * an IUnknown or IDispatch pointer for an object implementing the IStation interface.
      /// * a floating point value
      /// * a string such as 5+01.25. The string is first interpreted as being in US format, then SI format.
      [helpstring("method FromVariant")] HRESULT FromVariant([in] VARIANT varStation);

      /// The station zone index property.
      ///
      /// This property relates this station to a zone in a StationEquation object. A value of INVALID_INDEX means the station is not related to a StationEquation.
      [propget, helpstring("property StationZoneIndex"), helpcontext(IDH_Station_StationZoneIndex)] HRESULT StationZoneIndex([out, retval] ZoneIndexType *pVal);
      [propput, helpstring("property StationZoneIndex"), helpcontext(IDH_Station_StationZoneIndex)] HRESULT StationZoneIndex([in] ZoneIndexType newVal);

      /// Value of the station
      [propget, helpstring("property Value"), helpcontext(IDH_Station_Value)] HRESULT Value([out, retval] Float64 *pVal);
      [propput, helpstring("property Value"), helpcontext(IDH_Station_Value)] HRESULT Value([in] Float64 newVal);

      /// Offsets the station
      [helpstring("method Offset")] HRESULT Offset([in]Float64 offset);

      /// Gets the station zone and value.
      [helpstring("method GetStation")] HRESULT GetStation([out]ZoneIndexType* pZoneIdx,[out]Float64* pStation);

      /// Sets the station zone and value.
      [helpstring("method SetStation")] HRESULT SetStation([in]ZoneIndexType zoneIdx,[in]Float64 station);

      /// Initializes the station object with a string
      [helpstring("method FromString"), helpcontext(IDH_Station_FromString)] HRESULT FromString([in] BSTR station,[in] UnitModeType unitMode);

      /// Returns a string representation of the station.
      [helpstring("method AsString"), helpcontext(IDH_Station_AsString)] HRESULT AsString(
         [in] UnitModeType unitMode, ///< Unit format for the station. A unit conversion is not performed.
         [in] VARIANT_BOOL vbIncludeStationZone,  ///< Indicates if the station zone should be appended to the string. e.g. 5+01.23,2 The trailing ,2 indicates station zone 2
         [out,retval] BSTR* station ///< The string
      );

      /// Creates a copy of the object
      [helpstring("method Clone"), helpcontext(IDH_Station_Clone)] HRESULT Clone([out,retval] IStation* *clone);
   };

   /// Interface for objects that define a station equation. StationEquation objects must be created in a StationEquationCollection.
   ///
   /// A station equation is used when the stationing along an alignment is discontinuous. Station equations resolve overlapping or gaps in stationing.
   /// This might occur when an alignment is re-routed making it longer or shorter than the original. 
   /// A station equation is used to define the stationing back and ahead of the point where the original and new stationing no longer match.
   /// Stationing zones are the ranges of stationing between station equations. 
   /// Station objects are defined with respect to the zone where they are located. 
   [
      object,
      uuid(F3EE95F1-C4B9-4c9b-9B44-17DC06F7444A),
      oleautomation,
      helpcontext(IDH_StationEquation),
      helpstring("IStationEquation Interface"),
      pointer_default(unique)
   ]
   interface IStationEquation : IUnknown
   {
      /// Gets the back and ahead stations at the equation point.
      [helpstring("method GetEquation"),helpcontext(IDH_StationEquation_GetEquation)] HRESULT GetEquation([out]Float64* pBackStation,[out]Float64* pAheadStation);

      /// Returns the back station.
      [propget,helpstring("property Back"),helpcontext(IDH_StationEquation_Back)] HRESULT Back([out,retval]Float64* pBack);

      /// Returns the ahead station.
      [propget,helpstring("property Ahead"),helpcontext(IDH_StationEquation_Ahead)] HRESULT Ahead([out,retval]Float64* pAhead);

      /// Returns the station at this equation point, normalized to the start of the associated alignment
      [propget,helpstring("property NormalizedValue"),helpcontext(IDH_StationEquation_NormalizedValue)] HRESULT NormalizedValue([out,retval]Float64* pNormalizedValue);
   };

   /// Interface for objects that represent a point in a vertical profile.
   ///
   /// A profile point is defined by its station and elevation.
   [
       object,
       uuid(2D5F25CA-875B-484F-B4D0-AB02B0522EC2),
       oleautomation,
      helpcontext(IDH_ProfilePoint),
       helpstring("IProfilePoint Interface"),
       pointer_default(unique)
   ]
   interface IProfilePoint : IUnknown
   {
       /// The station
       [propget, helpstring("property Station"),helpcontext(IDH_ProfilePoint_Station)] HRESULT Station([out, retval] IStation* *station);
       [propput, helpstring("property Station"),helpcontext(IDH_ProfilePoint_Station)] HRESULT Station([in] VARIANT varStation);

       /// The elevation.
       [propget, helpstring("property Elevation"),helpcontext(IDH_ProfilePoint_Elevation)] HRESULT Elevation([out, retval] Float64 *pVal);
       [propput, helpstring("property Elevation"),helpcontext(IDH_ProfilePoint_Elevation)] HRESULT Elevation([in] Float64 newVal);

       [] HRESULT Location([out]IStation** pStation, [out]Float64* pElevation);
       [] HRESULT Move([in]VARIANT varStation, [in]Float64 elevation);

       [] HRESULT Clone(IProfilePoint** ppClone);
   };

   /// Interface used to enumerate values in a container
   [
      object,
      uuid(E669818B-B0E6-4fda-9255-49FDAF56114E),
      helpstring("IEnumProfilePoints Interface"),
      //helpcontext(IDH_IEnumProfilePoints),
      oleautomation,
      hidden,restricted,
      pointer_default(unique)
   ]
   interface IEnumProfilePoints : IUnknown
   {
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumProfilePoints** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
      HRESULT Next(
         [in] ULONG celt,  ///< Number of elements being requested
         [out] IProfilePoint** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// Interface for objects that represent a parabolic vertical curve.
   ///
   /// \image html /VertCurve/VertCurve.png
   /// * PBG = Point on Back Grade
   /// * PFG = Point on Forward Grade
   /// * PVI = Point of Vertical Intersection
   /// * BVC = Begin Vertical Curve
   /// * EVC = End Vertical Curve
   /// * E = Vertical distance from curve to tangent lines
   /// * H = Vertical distance from curve to PVI
   /// * g1 = Entry Grade
   /// * g2 = Exit Grade
   /// * L1 = Entry length
   /// * L2 = Exit Length
   [
       object,
       uuid(E003ECBB-BE61-4CB1-AB4B-819D98B3C45C),
       oleautomation,
      helpcontext(IDH_VertCurve),
       helpstring("IVerticalCurve Interface"),
       pointer_default(unique)
   ]
   interface IVerticalCurve : IUnknown //IProfileElement // Not sure why but when IVerticalCurves inherits from IProfileElement the IDL files that import this IDL file (like WBFLBridgeGeomtry.idl) don't compile. For consistency, all IProfileElement objects derive from IUnknown
   {
      [] HRESULT Init(IProfilePoint* pPBT, IProfilePoint* pPVI, IProfilePoint* pPFT, Float64 L1, Float64 L2);
      [] HRESULT Init2(IProfilePoint* pPBT, IProfilePoint* pPFT, Float64 g1, Float64 g2);

       /// The point on back grade
       [propget, helpstring("property PBG"), helpcontext(IDH_VertCurve_PBG)] HRESULT PBG([out, retval] IProfilePoint* *pVal);
       [propput, helpstring("property PBG"), helpcontext(IDH_VertCurve_PBG)] HRESULT PBG([in] IProfilePoint* newVal);

       /// The point of vertical intersection
       [propget, helpstring("property PVI"), helpcontext(IDH_VertCurve_PVI)] HRESULT PVI([out, retval] IProfilePoint* *pVal);
       [propput, helpstring("property PVI"), helpcontext(IDH_VertCurve_PVI)] HRESULT PVI([in] IProfilePoint* newVal);

       /// The point on forward grade
       [propget, helpstring("property PFG"), helpcontext(IDH_VertCurve_PFG)] HRESULT PFG([out, retval] IProfilePoint* *pVal);
       [propput, helpstring("property PFG"), helpcontext(IDH_VertCurve_PFG)] HRESULT PFG([in] IProfilePoint* newVal);

       /// The length of the entry half of the curve or the full length of a symmetric curve if L2 is zero
      [propget, helpstring("property L1"), helpcontext(IDH_VertCurve_L1)] HRESULT L1([out,retval] Float64* pVal);
      [propput, helpstring("property L1"), helpcontext(IDH_VertCurve_L1)] HRESULT L1([in] Float64 newVal);

      /// The length of the exit half of the curve. When zero, L1 is the full length of a symmetric curve.
      [propget, helpstring("property L2"), helpcontext(IDH_VertCurve_L2)] HRESULT L2([out,retval] Float64* pVal);
      [propput, helpstring("property L2"), helpcontext(IDH_VertCurve_L2)] HRESULT L2([in] Float64 newVal);

      /// The begin vertical curve point
       [propget, helpstring("property BVC"), helpcontext(IDH_VertCurve_BVC)] HRESULT BVC([out, retval] IProfilePoint* *pVal);

       /// The end vertical curve point
       [propget, helpstring("property EVC"), helpcontext(IDH_VertCurve_EVC)] HRESULT EVC([out, retval] IProfilePoint* *pVal);
       
       /// Profile grade entering the curve
       [propput, helpstring("property EntryGrade"), helpcontext(IDH_VertCurve_EntryGrade)] HRESULT EntryGrade([in] Float64 pVal);
       [propget, helpstring("property EntryGrade"), helpcontext(IDH_VertCurve_EntryGrade)] HRESULT EntryGrade([out, retval] Float64 *pVal);

       /// Profile grade exiting the curve
       [propput, helpstring("property ExitGrade"), helpcontext(IDH_VertCurve_ExitGrade)] HRESULT ExitGrade([in] Float64 pVal);
       [propget, helpstring("property ExitGrade"), helpcontext(IDH_VertCurve_ExitGrade)] HRESULT ExitGrade([out, retval] Float64 *pVal);

       /// The lowest point in the vertical curve. The lowest point can occur at the start or end of the curve.
       [propget, helpstring("property LowPoint"), helpcontext(IDH_VertCurve_LowPoint)] HRESULT LowPoint([out, retval] IProfilePoint* *pVal);

       /// The highest point in the vertical curve. The highest point can occur at the start or end of the curve.
       [propget, helpstring("property HighPoint"), helpcontext(IDH_VertCurve_HighPoint)] HRESULT HighPoint([out, retval] IProfilePoint* *pVal);

       /// Computes the profile elevation at the specified station
       [helpstring("method Elevation"), helpcontext(IDH_VertCurve_Elevation)] HRESULT Elevation([in] VARIANT varStation,[out,retval] Float64* elev);

       /// Computes the profile grade at the specified station
       [helpstring("method Grade"), helpcontext(IDH_VertCurve_Grade)] HRESULT Grade([in] VARIANT varStation,[out,retval]Float64* grade);

      /// Creates a copy of the curve
      //[helpstring("method Clone"), helpcontext(IDH_VertCurve_Clone)] HRESULT Clone([out,retval] IVerticalCurve* *clone);

      /// Algebraic difference in gradients
      ///
      /// \f$ A = g_2 - g_1 \f$
     [propget, helpstring("property A"), helpcontext(IDH_VertCurve_A)] HRESULT A([out,retval]Float64* a);

     /// Vertical curve constant for left half of curve if unsymmetric or the entire curve is symmetric. Horizontal distance need to make a 0.01 change in gradient.
     /// 
     /// \f$ K = \frac{A}{L} \f$
     /// 
     /// The K value is effectively an express for degree of curvature. The inverse of K is the minimum radius.
     /// \f$ \frac{K}{2} \f$ is the second derivative of the curve equation and represents the rate of change of the profile grade.
     [propget, helpstring("property K"), helpcontext(IDH_VertCurve_K)] HRESULT K1([out, retval]Float64* k);

     /// Vertical curve constant for right half of curve if unsymmetric or the entire curve is symmetric. Horizontal distance need to make a 0.01 change in gradient.
     [propget, helpstring("property K"), helpcontext(IDH_VertCurve_K)] HRESULT K2([out, retval]Float64* k);

     /// Vertical distance from the curve to the VPI. 
     ///
     /// \f$ H = \frac{L_1 L_2 A}{2(L_1 + L_2)} \f$
     [propget, helpstring("property H"), helpcontext(IDH_VertCurve_H)] HRESULT H([out,retval]Float64* h);

     /// Vertical distance at any point on the curve to the tangent grade. 
     ///
     /// \f$ t < L_1, E = H \left(\frac{t}{L_1} \right)^2 \f$, otherwise \f$ E = H \left( \frac{L-t}{L_2} \right)^2 \f$
     [propget, helpstring("property E"), helpcontext(IDH_VertCurve_E)] HRESULT E([in]Float64 t,[out,retval]Float64* e);
   };

   /// Interface for objects that represent a cubic spline.
   ///
   /// A cubic spline consists of at least two end points and the tangent directions at the end points. Additional points between the end points can be included. 
   /// A clamped cubic spline is modeled with a series of piecewise cubic segments.
   [
      object,
      uuid(EA2DD8A2-5B17-4b36-AE3D-38CB7CB059E5),
      oleautomation,
      //helpcontext(IDH_CubicSpline),
      helpstring("ICubicSpline Interface"),
      pointer_default(unique)
   ]
   interface ICubicSpline : IUnknown//IPathElement // See note for ICompoundCurve
   {
      /// Adds a collection of points to the spline
      [helpstring("method AddPoints")] HRESULT AddPoints([in]IPoint2dCollection* points);

      /// Adds an individual point to the spline. The point object is created with the associated Point2dFactory object.
     [helpstring("method AddPoint")] HRESULT AddPoint([in]Float64 x,[in]Float64 y);

     /// Adds a Point2d object to the spline.
     [helpstring("method AddPointEx")] HRESULT AddPointEx([in]IPoint2d* point);

     /// Returns the number of points
     [propget,helpstring("property PointCount")] HRESULT PointCount([out,retval]CollectionIndexType* nPoints);

     /// Returns a point at the specified index.
     [propget,helpstring("property Point")] HRESULT Point([in]CollectionIndexType idx,[out,retval]IPoint2d** point);

     /// Returns a collection containing all spline points.
     [propget,helpstring("property Points")] HRESULT Points([out,retval]IPoint2dCollection** ppPoints);

     /// Removes all points from the spline.
     [helpstring("method Clear")] HRESULT Clear();

     /// Direction of a line tangent to the spline at the start point
     [propput, helpstring("property StartDirection")] HRESULT StartDirection([in] VARIANT varDirection);
     [propget, helpstring("property StartDirection")] HRESULT StartDirection([out,retval]IDirection** dir);

     /// Direction of a line tangent to the spline at the end point
     [propput, helpstring("property EndDirection")] HRESULT EndDirection([in] VARIANT varDirection);
     [propget, helpstring("property EndDirection")] HRESULT EndDirection([out,retval]IDirection** dir);

      /// Computes the bearing of a line tangent to the spline at a specified point.
     [helpstring("method BearingAtPoint")] HRESULT BearingAtPoint([in]CollectionIndexType idx,[out,retval]IDirection** pDir);

     /// Computes the bearing of a line normal to the spline at a specified point.
     [helpstring("method NormalAtPoint")] HRESULT NormalAtPoint([in]CollectionIndexType idx,[out,retval]IDirection** pDir);

      /// Computes the distance along the spline from the start point to a specified point
      [helpstring("method DistanceFromStartAtPoint")] HRESULT DistanceFromStartAtPoint([in] CollectionIndexType idx,[out,retval] Float64* dist);
   };

   /// Interface for objects that represent a Surface widening modification
   ///
   /// A widening can be applied to one or two segments of the SurfaceTemplate. This is to facilitate symmetric widening with a single Widening object.
   [
      object,
      uuid(5FA0BC50-322E-4b8c-84AB-5315122966AE),
      oleautomation,
      //helpcontext(IDH_Widening),
      helpstring("IWidening Interface"),
      pointer_default(unique)
   ]
   interface IWidening : IUnknown
   {
      /// Initialize the object
      [helpstring("method Init")] HRESULT Init(
         [in] VARIANT varBeginStation, ///< Station where the entry widening transition begins
         [in] VARIANT varBeginFullStation,  ///< Station where the full widening begins
         [in] VARIANT varEndFullStation, ///< Station where the fill widening ends
         [in] VARIANT varEndStation, ///< Station where the exit widening transition ends
         [in] Float64 widening, ///< The width of the widening. Positive values widen the surface and negative values make it more narrow.
         [in] SegmentIndexType templateSegmentIdx1, ///< Index of a TemplateSegment to widen
         [in] SegmentIndexType templateSegmentIdx2 ///< Index of a TemplateSegment to widen. Use INVALID_INDEX if the widening is applied to only one TemplateSegment.
      );

      /// The associated Surface
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Station where the entry widening transition begins
      [propput,helpstring("property BeginTransition")] HRESULT BeginTransition([in]VARIANT varStation);
      [propget,helpstring("property BeginTransition")] HRESULT BeginTransition([out,retval]IStation** station);

      /// Station where the full widening begins
      [propput,helpstring("property BeginFullWidening")] HRESULT BeginFullWidening([in]VARIANT varStation);
      [propget,helpstring("property BeginFullWidening")] HRESULT BeginFullWidening([out,retval]IStation** station);

      /// Station where the full widening ends
      [propput,helpstring("property EndFullWidening")] HRESULT EndFullWidening([in]VARIANT varStation);
      [propget,helpstring("property EndFullWidening")] HRESULT EndFullWidening([out,retval]IStation** station);

      /// Station where the exit widening transition ends
      [propput,helpstring("property EndTransition")] HRESULT EndTransition([in]VARIANT varStation);
      [propget,helpstring("property EndTransition")] HRESULT EndTransition([out,retval]IStation** station);

      /// The width of the widening. Positive values widen the surface and negative values make it more narrow.
      [propput,helpstring("property Widening")] HRESULT Widening([in]Float64 value);
      [propget,helpstring("property Widening")] HRESULT Widening([out,retval]Float64* value);

      /// Index of the TemplateSegment to be widened.
      ///
      /// \param pntIdx 0 or 1 to indicate which of the two widenings the segment index applies
      /// \param templateSegmentIdx Index of the TemplateSegment to widen
      [propput,helpstring("property Segment")] HRESULT Segment([in]IndexType pntIdx,[in]IndexType templateSegmentIdx);
      [propget,helpstring("property Segment")] HRESULT Segment([in]IndexType pntIdx,[out,retval]IndexType* templateSegmentIdx);

      /// Computes the widening for the specified TemplateSegment at a station.
      [helpstring("method GetWidening")] HRESULT GetWidening(
         [in]VARIANT varStation, ///< The station where the widening is to be computed
         [in]IndexType templateSegmentIdx, ///< Index of the TemplateSegment for which the widening is to be computed
         [out,retval]Float64* pWidening ///< The computed widening. If the specified TemplateSegment is not widened the computed widening is zero.
      );
   };

   /// Interface for objects that represent a Surface superelevation modification
   ///
   /// A superelevation is defined by its limits, transitions, rate, and pivot point.
   /// Superelvation transitions can be linear or parabolic.
   [
      object,
      uuid(C261362D-E01F-49c5-95ED-E8A8FBC68FB9),
      oleautomation,
      //helpcontext(IDH_Superelevation),
      helpstring("ISuperelevation Interface"),
      pointer_default(unique)
   ]
   interface ISuperelevation : IUnknown
   {
      /// Initialize the object
      [helpstring("method Init")] HRESULT Init(
         [in] VARIANT varBeginStation, ///< Station where the entry superelevation transition begins
         [in] VARIANT varBeginFullStation,  ///< Station where the full superelevation begins
         [in] VARIANT varEndFullStation, ///< Station where the full superelevation ends
         [in] VARIANT varEndStation, ///< Station where the exit superelevation transition ends
         [in] Float64 rate, ///< The superelevation rate (cross slope). Positive values indicates the roadway slopes upwards from left to right.
         [in]IndexType pivotPointIdx, ///< Ridge point index that the superelevation pivot occurs about.
         [in]SuperTransitionType beginType, ///< Entry transition type
         [in]Float64 beginL1, ///< If the entry transition is parabolic, this is the length of the parabola at the beginning of the transition
         [in]Float64 beginL2, ///< If the entry transition is parabolic, this is the length of the parabola at the beginning of full superelevation
         [in]SuperTransitionType endType, ///< Exit transition type
         [in]Float64 endL1, ///< If the exit transition is parabolic, this is the length of the parabola at the end of full superelevation
         [in]Float64 endL2 ///< If the exit transition is parabolic, this is the length of the parabola at the end of the transition
      );

      /// The associated Surface
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);
      
      /// Station where the entry superelevation transition begins 
      [propput, helpstring("property BeginTransition")] HRESULT BeginTransition([in] VARIANT varBeginTransition);
      [propget, helpstring("property BeginTransition")] HRESULT BeginTransition([out,retval] IStation** ppBeginTransition);

      /// Station where the full superelevation begins
      [propput, helpstring("property BeginFullSuper")] HRESULT BeginFullSuper([in] VARIANT varBeginFullSuper);
      [propget, helpstring("property BeginFullSuper")] HRESULT BeginFullSuper([out,retval] IStation** ppBeginFullSuper);

      /// Station where the full superelevation ends
      [propput, helpstring("property EndFullSuper")] HRESULT EndFullSuper([in] VARIANT varEndFullSuper);
      [propget, helpstring("property EndFullSuper")] HRESULT EndFullSuper([out,retval] IStation** ppEndFullSuper);

      /// Station where the exit superelevation transition ends
      [propput, helpstring("property EndTransition")] HRESULT EndTransition([in] VARIANT varEndTransition);
      [propget, helpstring("property EndTransition")] HRESULT EndTransition([out,retval] IStation** ppEndTransition);

      /// The superelevation rate (cross slope). Positive values indicates the roadway slopes upwards from left to right.
      [propput, helpstring("property Rate")] HRESULT Rate([in]Float64 rate);
      [propget, helpstring("property Rate")] HRESULT Rate([out,retval]Float64* rate);

      /// Ridge point index that the superelevation pivot occurs about.
      [propput, helpstring("property PivotPoint")] HRESULT PivotPoint([in]IndexType pivotPointIdx);
      [propget, helpstring("property PivotPoint")] HRESULT PivotPoint([out,retval]IndexType* pivotPointIdx);

      /// Entry transition type
      [propput, helpstring("property BeginTransitionType")] HRESULT BeginTransitionType([in]SuperTransitionType type);
      [propget, helpstring("property BeginTransitionType")] HRESULT BeginTransitionType([out,retval]SuperTransitionType* type);

      /// Entry transition parameters for parabolic transitions
      /// \param L1 Length of the parabola at the beginning of the transition
      /// \param L2 Length of the parabola at the beginning of full superelevation
      [helpstring("method SetBeginTransitionParameters")] HRESULT SetBeginTransitionParameters([in]Float64 L1,[in]Float64 L2);
      [helpstring("method GetBeginTransitionParameters")] HRESULT GetBeginTransitionParameters([out]Float64* L1,[out]Float64* L2);

      /// Exit transition type
      [propput, helpstring("property EndTransitionType")] HRESULT EndTransitionType([in]SuperTransitionType type);
      [propget, helpstring("property EndTransitionType")] HRESULT EndTransitionType([out,retval]SuperTransitionType* type);

      /// Exit transition parameters for parabolic transitions
      /// \param L1 Length of the parabola at the end of full superelevation
      /// \param L2 Length of the parabola at the end of the transition
      [helpstring("method SetEndTransitionParameters")] HRESULT SetEndTransitionParameters([in]Float64 L1,[in]Float64 L2);
      [helpstring("method GetEndTransitionParameters")] HRESULT GetEndTransitionParameters([out]Float64* L1,[out]Float64* L2);

      /// Computes the slope at the specified station
      [helpstring("method GetSlope")] HRESULT GetSlope(
         [in]VARIANT varStation, ///< The station where the slope is computed
         [in]Float64 templateSlope, ///< The basic slope of the template before superelevation transitions are applied.
         [out,retval]Float64* pSlope ///< The roadway cross slope
      );
   };

   /// Interface defining a SurfaceTemplateSegment.
   [
      object,
      uuid(B3D0955A-0174-4085-A6F7-C71ACAC612D7),
      oleautomation,
      //helpcontext(IDH_TemplateSegment),
      helpstring("ISurfaceTemplateSegment Interface"),
      pointer_default(unique)
   ]
   interface ISurfaceTemplateSegment : IUnknown
   {
      /// Initializes the segment
      [helpstring("method Init")] HRESULT Init(
         [in]Float64 width, ///< Width of the segment
         [in]Float64 slope, ///< Slope of the segment
         [in]TemplateSlopeType slopeType ///< Type of slope used to define the segment
      );

      /// Width of the segment
      [propput, helpstring("property Width")] HRESULT Width([in]Float64 width);
      [propget, helpstring("property Width")] HRESULT Width([out,retval]Float64* width);

      /// Slope of the segment
      [propput, helpstring("property Slope")] HRESULT Slope([in]Float64 slope);
      [propget, helpstring("property Slope")] HRESULT Slope([out,retval]Float64* slope);

      /// Type of slope used to define the segment
      [propput, helpstring("property SlopeType")] HRESULT SlopeType([in]TemplateSlopeType type);
      [propget, helpstring("property SlopeType")] HRESULT SlopeType([out,retval]TemplateSlopeType* type);
   };

   /// Interface defining a surface template.
   ///
   /// A surface template defines the cross section of a surface. The template consists of a sequence of straight line segments, defined left to right looking in the forward direction (ahead on station).
   /// The end points of the segments are known as ridge points.
   [
      object,
      uuid(D2286685-D34F-4a59-B7C7-9B531D1C9713),
      oleautomation,
      //helpcontext(IDH_SurfaceTemplate),
      helpstring("ISurfaceTemplate Interface"),
      pointer_default(unique)
   ]
   interface ISurfaceTemplate : IUnknown
   {
      /// The associated Surface object
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Station where this SurfaceTemplate is applied
      [propget,helpstring("property Station")] HRESULT Station([out,retval]IStation** station);

      [] HRESULT GetSegmentParameters(IndexType segmentIdx, Float64* pWidth, Float64* pSlope, TemplateSlopeType* pSlopeType);

      /// Updates a segment to the template.
      [helpstring("method UpdateSegment")] HRESULT UpdateSegmentParameters(
         [in]IndexType segmentIdx, ///< Index of segment to update
         [in]Float64 width, ///< Width of the segment
         [in]Float64 slope,///< Slope of the segment
         [in]TemplateSlopeType slopeType ///< Type of slope used to define the segment
      );

      /// Returns the number of segments in the template.
      ///
      /// > NOTE: All SurfaceTemplates associated with a Surface must have the same number of Segments.
      [propget,helpstring("property Count")] HRESULT Count([out,retval]CollectionIndexType* count);

      /// Gets a SurfaceTemplate
      [propget,helpstring("property Item")] HRESULT Item([in]CollectionIndexType idx,[out,retval]ISurfaceTemplateSegment** segment);

      /// Computes the change in elevation between two ridge points.
      [helpstring("method GetRidgePointElevationChange")] 
      HRESULT GetRidgePointElevationChange(
         [in]CollectionIndexType ridgePointIdx1, ///< The first ridge point
         [in]CollectionIndexType ridgePointIdx2, ///< The second ridge point
         [out,retval]Float64* deltaElevation ///< The change in elevation from the first to second ridge points
      );

      /// Computes the elevation change from a ridge point to an offset point
      [helpstring("method GetElevationChange")] 
      HRESULT GetElevationChange(
         [in]CollectionIndexType ridgePointIdx, ///< Index of a ridge point
         [in]Float64 offset, ///< Offset from the ridge point
         [out,retval]Float64* deltaElevation ///< Change of elevation between the ridge point and the offset point
      );

      /// Computes the slope at a point offset from a ridge point
      [helpstring("method GetSlope")] 
      HRESULT GetSlope(
         [in]CollectionIndexType ridgePointIdx, ///< Index of a ridge point
         [in]Float64 offset, ///< Offset from the ridge point
         [out,retval]Float64* pSlope ///< Slope at the offset point
      );

      /// Returns the slope from horizontal of a segment
      [helpstring("method GetSegmentSlope")] HRESULT GetSegmentSlope([in]CollectionIndexType segmentIdx,[out,retval]Float64* pSlope);

      /// Computes the offset from a reference ridge point to another ridge point
      [helpstring("method GetRidgePointOffset")] 
      HRESULT GetRidgePointOffset(
         [in]IndexType ridgePoint1Idx, ///< Index of the first ridge point
         [in]IndexType ridgePoint2Idx, ///< Index of the second ridge point
         [out]Float64* pOffset ///< The offset distance from ridge point 1 to ridge point 2
      );

      /// Returns the elevation of a ridge point.
      [helpstring("method GetRidgePointElevation")] HRESULT GetRidgePointElevation(
         [in]IndexType ridgePointIdx, ///< The ridge point index
         [out]Float64* pElev ///< The elevation of the ridge point
      );

      /// Computes the offset from a reference ridge point to another ridge point and the elevation at that ridge point
      [helpstring("method GetRidgePointOffsetAndElevation")] 
      HRESULT GetRidgePointOffsetAndElevation(
         [in]IndexType ridgePoint1Idx, ///< Index of the first ridge point
         [in]IndexType ridgePoint2Idx, ///< Index of the second ridge point
         [out]Float64* pOffset, ///< Offset from ridge point 1 to ridge point 2
         [out]Float64* pElev ///< Elevation at ridge point 2
      );

      /// Removes all TemplateSegments from this SurfaceTemplate
      [helpstring("method Clear")] HRESULT Clear();
   };

   /// Interface for objects that represent a point in a SurfaceProfile
   ///
   /// A surface point is defined by it's station, normal offset, cut line offset, elevation, and plan view coordinate.
   [
       object,
       uuid(D4CD4F83-7F81-4ee9-B9AD-546E23014880),
       oleautomation,
      //helpcontext(IDH_SurfacePoint),
       helpstring("ISurfacePoint Interface"),
       pointer_default(unique)
   ]
   interface ISurfacePoint : IUnknown
   {
      /// The associated Surface object
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Station where this point occurs
       [propget, helpstring("property Station")]HRESULT Station([out, retval] IStation* *station);
       [propput, helpstring("property Station")] HRESULT Station([in] VARIANT varStation);

       /// Normal offset from the alignment, at the location of the Station property, to this point
       [propget, helpstring("property NormalOffset")] HRESULT NormalOffset([out, retval] Float64 *pVal);
       [propput, helpstring("property NormalOffset")] HRESULT NormalOffset([in] Float64 newVal);

       /// Offset from the alignment, at the location of the Station property, measured along a cut line to this point
       [propget, helpstring("property CutLineOffset")] HRESULT CutLineOffset([out, retval] Float64 *pVal);
       [propput, helpstring("property CutLineOffset")] HRESULT CutLineOffset([in] Float64 newVal);

       /// Elevation of this point
       [propget, helpstring("property Elevation")] HRESULT Elevation([out, retval] Float64 *pVal);
       [propput, helpstring("property Elevation")] HRESULT Elevation([in] Float64 newVal);

       /// Plan view coordinate of this point represented with a Point2d object
       [propget, helpstring("property Location")] HRESULT Location([out,retval]IPoint2d** ppLocation);
       [propput, helpstring("property Location")] HRESULT Location([in]IPoint2d* ppLocation);

       /// Spatial representation of this point as a Point3d object
       [helpstring("method GetPoint")] HRESULT GetPoint([out,retval]IPoint3d** ppPoint);
   };

   /// Interface for objects that represent a SurfaceProfile
   ///
   /// Surface points are defined left to right along the surface profile.
   [
      object,
      uuid(677A9E7B-7CA1-47ef-95FF-EBB88CC2CA0A),
      oleautomation,
      //helpcontext(IDH_SurfaceProfile),
      helpstring("ISurfaceProfile Interface"),
      pointer_default(unique)
   ]
   interface ISurfaceProfile : IUnknown
   {
      /// The associated Surface object
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Station that locates this SurfaceProfile along an alignment
      [propget,helpstring("property Station")] HRESULT Station([out,retval]IStation** station);

      /// Skew angle of a cutline defining this SurfaceProfile
      [propget,helpstring("property SkewAngle")] HRESULT SkewAngle([out,retval]IAngle** skewAngle);

      /// Direction of a cutline defining this SurfaceProfile
      [propget, helpstring("property Direction")] HRESULT Direction([out, retval]IDirection** direction);

      /// Gets the number of surface points
      [propget,helpstring("property Count")] HRESULT Count([out,retval]CollectionIndexType* count);

      /// Gets the SurfacePoint at the specified index
      [propget,helpstring("property Item")] HRESULT Item([in]CollectionIndexType idx,[out,retval]ISurfacePoint** point);

      /// Gets the change in elevation between two surface points
      [helpstring("method GetSurfacePointElevationChange")] 
      HRESULT GetSurfacePointElevationChange(
         [in]CollectionIndexType surfacePointIdx1, ///< Index of the first surface point
         [in]CollectionIndexType surfacePointIdx2, ///< Index of the second surface point
         [out,retval]Float64* deltaElevation ///< The change in elevation from the first to the second surface points.
      );

      /// Computes the elevation change from a surface point to an offset
      [helpstring("method GetElevationChange")] 
      HRESULT GetElevationChange(
         [in]CollectionIndexType surfacePointIdx, ///< Index of a surface point
         [in]Float64 offset, ///< Offset from the surface point
         [out,retval]Float64* deltaElevation ///< Change of elevation between the surface point and the offset point
      );

      /// Computes the slope at a point offset from a surface point
      [helpstring("method GetSlope")] 
      HRESULT GetSlope(
         [in]CollectionIndexType surfacePointIdx, ///< Index of a surface point
         [in]Float64 offset, ///< Offset from the surface point
         [out,retval]Float64* pSlope ///< Slope in the direction of the cutline at the offset point
      );

      /// Returns the slope from horizontal in the direction of the cutline
      [helpstring("method GetSegmentSlope")] HRESULT GetSegmentSlope([in]CollectionIndexType segmentIdx,[out,retval]Float64* pSlope);

      /// Returns the offset distance along the cutline to a surface point
      [helpstring("method GetSurfacePointOffset")] HRESULT GetSurfacePointOffset([in]IndexType ridgePointIdx,[out]Float64* pOffset);

      /// Computes the offset distance along the cutline and elevation of a surface point
      [helpstring("method GetSurfacePointElevation")] 
      HRESULT GetSurfacePointElevation(
         [in]IndexType ridgePointIdx, ///< Index of a surface point
         [out]Float64* pOffset, ///< Offset to the surface point along the cutline
         [out]Float64* pElev ///< Elevation of the surface point
      );
   };

   /// Interface defining a surface.
   [
      object,
      uuid(07A3322F-F4C1-4635-9339-7B2954BB589D),
      oleautomation,
      //helpcontext(IDH_Surface),
      helpstring("ISurface Interface"),
      pointer_default(unique)
   ]
   interface ISurface : IUnknown
   {
      /// The associated profile
      [propget, helpstring("property Profile")] HRESULT Profile([out, retval] IProfile* *pVal);
      [propputref, helpstring("property Profile")] HRESULT Profile([in] IProfile* newVal);

      /// Index of the SurfaceTemplate point coincident with the Alignment
      [propput, helpstring("property AlignmentPoint")] HRESULT AlignmentPoint([in]IndexType pntIdx);
      [propget, helpstring("property AlignmentPoint")] HRESULT AlignmentPoint([out, retval]IndexType* pntIdx);

      /// Index of the SurfaceTemplate point coincident with the Profile
      [propput, helpstring("property ProfileGradePoint")] HRESULT ProfileGradePoint([in]IndexType pntIdx);
      [propget, helpstring("property ProfileGradePoint")] HRESULT ProfileGradePoint([out, retval]IndexType* pntIdx);

      [propput] HRESULT SurfaceTemplateSegmentCount([in]IndexType nSegments);
      [propget] HRESULT SurfaceTemplateSegmentCount([out, retval]IndexType* pnSegments);

      [] HRESULT CreateSurfaceTemplate([in]VARIANT varStation, [out, retval]ISurfaceTemplate** ppTemplate);
      [] HRESULT GetSurfaceTemplateCount(IndexType* pCount);
      [] HRESULT GetSurfaceTemplate(IndexType idx, ISurfaceTemplate** ppTemplate);

      [] HRESULT ClearSurfaceTemplates();

      [] HRESULT AddSuperelevation([in] ISuperelevation* pSuperelevation);

      [] HRESULT FindSuperelevation([in]VARIANT varStation, [out, retval]ISuperelevation** ppSuperelevation);

      [] HRESULT ClearSuperelevations();

      [] HRESULT AddWidening([in]IWidening* pWidening);
      [] HRESULT FindWidening([in]VARIANT varStation, [out, retval]IWidening** ppWidening);
      [] HRESULT ClearWidenings();

      /// A plan view line for the first SurfaceTemplate. This line is normal to the associated alignment. The line ranges between the left and right-most ridge points.
      [propget,helpstring("property StartBoundaryLine")] HRESULT StartBoundaryLine([in]ILineSegment2d** ppEndLine);

      /// A plan view line for the last SurfaceTemplate. This line is normal to the associated alignment. The line ranges between the left and right-most ridge points.
      [propget,helpstring("property EndBoundaryLine")] HRESULT EndBoundaryLine([in]ILineSegment2d** ppEndLine);

      /// The station range covered by this surface
      [helpstring("method GetStationRange")] HRESULT GetStationRange([out]IStation** ppStart,[out]IStation** ppEnd);

      /// Creates a SurfaceTemplate at the specified station.
      [helpstring("method CreateSurfaceTemplateSectionCut")] HRESULT CreateSurfaceTemplateSectionCut(
         [in]VARIANT varStation, ///< Station where the surface template is created
         [in]VARIANT_BOOL bApplySuperelevations, ///< If VARIANT_TRUE, Superelevation modifiers are applied
         [out,retval]ISurfaceTemplate** ppSurfaceTemplate ///< The SurfaceTemplate
      );

      /// Creates a SurfaceProfile along a cut line passing through the specified station at the specified direction.
      [helpstring("method CreateSurfaceProfileSectionCut")] HRESULT CreateSurfaceProfileSectionCut(
         [in]VARIANT varStation, ///< Station where the surface profile is created
         [in]VARIANT varSkewAngle, ///< Skew angle of the cut line relative to the alignment normal.
         [in]VARIANT_BOOL bApplySuperelevation, ///< If VARIANT_TRUE, Superelevation modifiers are applied
         [out,retval]ISurfaceProfile** ppSurfaceProfile ///< The SurfaceProfile
      );
   };

   /// Interface for objects that represent an element in a profile.
   [
      object,
      uuid(885D3FAE-E15A-4BF0-AAD0-8622700D4250),
      oleautomation,
      helpcontext(IDH_ProfileElement),
      helpstring("IProfileElement Interface"),
      pointer_default(unique)
   ]
   interface IProfileElement : IUnknown
   {
      /// The associated Profile object
      [propget, helpstring("property Profile"), helpcontext(IDH_VertCurve_Profile)] HRESULT Profile([out, retval] IProfile** pVal);
      [propput, helpstring("property Profile"), helpcontext(IDH_VertCurve_Profile)] HRESULT Profile([in] IProfile* newVal);

      [] HRESULT GetStartPoint([out, retval]IProfilePoint** ppPoint);
      [] HRESULT GetEndPoint([out, retval]IProfilePoint** ppPoint);
      [] HRESULT GetLength([out, retval]Float64* pLength);
      [] HRESULT ComputeGradeAndElevation([in]VARIANT varStation, Float64* pGrade, Float64* pElevation);
   };

   /// Interface for objects that present a linear segment in a profile
   [
      object,
      uuid(3F01F89F-8617-4514-A303-F4C36FD1FC95),
      oleautomation,
      helpstring("IProfileSegment Interface"),
      pointer_default(unique)
   ]
   interface IProfileSegment : IUnknown //IProfileElement, See note on IVerticalCurve
   {
      [] HRESULT SetStartPoint([in]IProfilePoint* pStart);
      [] HRESULT SetEndPoint([in]IProfilePoint* pEnd);
      [] HRESULT Move([in]IProfilePoint* pStart, [in]IProfilePoint* pEnd);
      [] HRESULT Location([out]IProfilePoint** ppStart, [out]IProfilePoint** ppEnd);
   };
   
   /// Interface defining a Profile object.
   [
      object,
      uuid(33CC0CE8-3BF5-4E27-A483-8EA6B4A2327B),
      oleautomation,
      helpcontext(IDH_Profile),
      helpstring("IProfile Interface"),
      pointer_default(unique)
   ]
   interface IProfile : IUnknown
   {
      /// Associates alignment with this profile.
      [propput, helpstring("property Alignment")] HRESULT Alignment([in]IAlignment* ppAlignment);

      /// Returns the associated alignment
      [propget, helpstring("property Alignment")] HRESULT Alignment([out, retval]IAlignment** ppAlignment);

      /// Adds a ProfileElement to the collection
      [helpstring("method AddProfileElement"), helpcontext(IDH_Profile_Add)] HRESULT AddProfileElement([in] IProfileElement* element);

      /// A ProfileElement item
      [propget, helpstring("property Item"), helpcontext(IDH_Profile_Item)] HRESULT Item([in] CollectionIndexType idx, [out, retval] IProfileElement** pVal);

      /// The number of ProfileElement items in the path
      [propget, helpstring("property ProfileElementCount"), helpcontext(IDH_Profile_Count)] HRESULT ProfileElementCount([out, retval] CollectionIndexType* pVal);

      /// Removes all ProfileElement objects from the profile
      [helpstring("method ClearProfileElements"), helpcontext(IDH_Profile_Clear)] HRESULT ClearProfileElements();
      
      [] HRESULT AddSurface(IDType id, ISurface* pSurface);
      [] HRESULT GetSurface(IDType id, ISurface** ppSurface);
      [] HRESULT ClearSurfaces();

      [] HRESULT Clear();

      [] HRESULT CreateSurfaceTemplateSectionCut(IDType surfaceID, VARIANT varStation, VARIANT_BOOL vbApplySuperelevation, ISurfaceTemplate** ppTemplate);
      [] HRESULT CreateSurfaceTemplateSectionCutEx(ISurface* pSurface, VARIANT varStation, VARIANT_BOOL vbApplySuperelevation, ISurfaceTemplate** ppTemplate);

      /// Computes elevation at a specified station and offset
      [helpstring("method Elevation"), helpcontext(IDH_Profile_Elevation)] 
      HRESULT Elevation(
         [in] IDType surfaceID, ///< ID of the surface on which the elevation is computed. Use INVALID_ID for the Profile Grade Line
         [in] VARIANT varStation, ///< Station where the elevation is computed
         [in] Float64 offset, ///< Offset from the profile grade line. Offset ignored if surfaceID is INVALID_ID
         [out,retval] Float64* elev ///< The profile element
      );

      /// Computes the profile grade at a specified station
      [helpstring("method Grade"), helpcontext(IDH_Profile_Grade)] 
      HRESULT Grade(
         [in] VARIANT varStation, ///< Station where the grade is computed
         [out,retval] Float64* grade ///< The profile grade
      );

      /// Computes the cross slope at a specified station and offset
      [helpstring("method CrossSlope"), helpcontext(IDH_Profile_Slope)] 
      HRESULT CrossSlope(
         [in] IDType surfaceID, ///< ID of the surface on which the elevation is computed. Use INVALID_ID for the Profile Grade Line
         [in] VARIANT varStation, ///< Station where the slope is computed
         [in] Float64 offset, ///< Offset from the profile grade line. Offset ignored if surfaceID is INVALID_ID
         [out,retval] Float64* slope ///< The cross slope
      );

      /// Returns a surface template slope with respect to the horizontal
      [helpstring("method SurfaceTemplateSegmentSlope")] 
      HRESULT SurfaceTemplateSegmentSlope(
         [in]IDType surfaceID, ///< ID of a Surface object
         [in]VARIANT varStation, ///< Station where a SurfaceTemplate is created
         [in]CollectionIndexType templateSegmentIdx, ///< Index of the SurfaceTemplateSegment from which the slope is returned
         [out,retval]Float64* pSlope ///< The SurfaceTemplateSegment slope
      );

      /// Returns the Surface identified by surfaceID and containing the specified station.
      [helpstring("method GetSurfaceContainingStation")] HRESULT GetSurfaceContainingStation(
         [in]VARIANT varStation, ///< The station
         [out]IDType* pSurfaceID,///< ID of a Surface object
         [out,retval]ISurface** ppSurface ///< The Surface object
      );

      /// Returns the offset of a ridge point relative to another ridge point.
      [helpstring("method GetRidgePointOffset")] HRESULT GetRidgePointOffset(
         [in]IDType surfaceID, ///< ID of a Surface object
         [in]VARIANT varStation, ///< Station where a SurfaceTemplate is created
         [in]IndexType ridgePoint1Idx, ///< The first ridge point
         [in]IndexType ridgePoint2Idx, ///< The second ridge point
         [out]Float64* pOffset ///< The offset from the reference point to the ridge point
      );

      /// Returns the elevation of a ridge point.
      [helpstring("method GetRidgePointElevation")] HRESULT GetRidgePointElevation(
         [in]IDType surfaceID, ///< ID of a Surface object
         [in]VARIANT varStation, ///< Station where a SurfaceTemplate is created
         [in]IndexType ridgePointIdx, ///< The ridge point index
         [out]Float64* pElev ///< The elevation of the ridge point
      );

      /// Returns the offset and elevation of a ridge point relative to a reference ridge point.
      [helpstring("method GetRidgePointOffsetAndElevation")] HRESULT GetRidgePointOffsetAndElevation(
         [in]IDType surfaceID, ///< ID of a Surface object
         [in]VARIANT varStation, ///< Station where a SurfaceTemplate is created
         [in]IndexType ridgePoint1Idx, ///< The ridge point index
         [in]IndexType ridgePoint2Idx, ///< The reference point index
         [out]Float64* pOffset, ///< The offset from the reference point to the ridge point
         [out]Float64* pElev ///< The elevation of the ridge point
      );
   };

   /// Interface for objects that represent an element in a path.
   [
      object,
      uuid(60F5D239-6851-41B6-AD37-7CBA6BB9D78A),
      oleautomation,
      helpcontext(IDH_PathElement),
      helpstring("IPathElement Interface"),
      pointer_default(unique)
   ]
   interface IPathElement : IUnknown
   {
      /// Creates a copy of the path element. Copies the contained elements.
      [helpstring("method Clone"), helpcontext(IDH_PathElement_Clone)] HRESULT Clone([out,retval] IPathElement* *clone);

      /// Moves the path element
      [helpstring("method Move")] 
      HRESULT Move(
         [in] Float64 dist, ///< Distance to move the path element. The path element is moved in the opposite direction then the Direction object indicates when this parameter is less than zero.
         [in] VARIANT varDirection ///< The direction to move the path element.
      );

      /// Offsets the position of the path element
      [helpstring("method Offset")] HRESULT Offset(
         [in]Float64 dx, ///< Offset in the X (East-West) direction
         [in]Float64 dy ///< Offset in the Y (North-South) direction
      );

      /// Locates a point on the curve at a specified distance from TS. If the specified distance is less than zero or if it is greater than the curve length, the point will be located on the back or forward tangent, respectively.
      [helpstring("method PointOnCurve")] HRESULT PointOnCurve([in] Float64 distance, [out, retval]IPoint2d** pVal);

      /// \brief Returns the start point of the element
      /// \return 
      [] HRESULT GetStartPoint([out, retval]IPoint2d** ppPoint);

      /// \brief Returns the end point of the element
      /// \return 
      [] HRESULT GetEndPoint([out, retval]IPoint2d** ppPoint);

      /// \brief Returns the length of the path element
      /// \return 
      [] HRESULT GetLength([out, retval]Float64* pLength);

      /// \brief Returns a collection of key points on the element
      [] HRESULT GetKeyPoints(IPoint2dCollection** ppPoints);

      /// \brief Creates a point on the path element at the specified location
      /// \param distFromStart Distance from the start of the path element from with the point is to be located
      /// \param offsetType Specifies how offset is measured
      /// \param offset Offset from the path element to the point
      /// \param direction Direction from the path element at which to locate the point
      /// \return The point
      [] HRESULT LocatePoint(Float64 distFromStart, OffsetMeasureType offsetType, Float64 offset, VARIANT varDirection,IPoint2d** ppPoint);

      /// \brief Computes the bearing of the path element at a specified location
      /// \param distFromStart Distance from the start of the path element
      /// \return 
      [] HRESULT GetBearing(Float64 distFromStart,IDirection** ppDirection);

      /// \brief Computes the normal to the path element at the specified location
      /// \param distFromStart Distance from the start of the path element
      /// \return 
      [] HRESULT GetNormal(Float64 distFromStart, IDirection** ppNormal);

      /// \brief Project a point onto the path element
      /// \param point The point to project onto the path element
      /// \return Returns the tuple<NewPoint,DistFromStart,OnProjection> where NewPoint is the point on the path element, 
      /// DistFromStart is the distance from the start of the path element to the projected point, and OnProjection is a boolean
      /// with value of true indicating the point is on a projection of the path element
      [] HRESULT ProjectPoint(IPoint2d* point, IPoint2d** ppProjPoint, Float64* pDistFromStart, VARIANT_BOOL* pvbOnProjection);

      /// \brief Intersects a line with the path element
      /// \param line Line to intersect with the path element
      /// \param bProjectBack If true, the back tangent line at the start of the path element is considered to be part of the element
      /// \param bProjectAhead If true, the ahead tangent line at the end of the path element is considered to be part of the element
      /// \return 
      [] HRESULT Intersect(ILine2d* pLine, VARIANT_BOOL vbProjectBack, VARIANT_BOOL vbProjectAhead,IPoint2dCollection** ppPoints);

      /// \brief Creates a new path that is offset from this path element. Some PathElement types require
      /// multiple PathElement objects to represent the offset element.
      /// \param offset The offset distance, measure normal to the path element
      /// \return Collection of path elements
      [] HRESULT CreateOffsetPath(Float64 offset,IPath** ppPath);

      /// \brief Creates a new path that is a subset of this path element. Some PathElement types require
      /// multiple PathElement objects to represent the sub-path
      /// \param start Distance from the start of the element to the start of the sub-path element
      /// \param end Distance from the start of the element to the end of the sub-path element
      /// \return 
      [] HRESULT CreateSubpath(Float64 start, Float64 end, IPath** ppPath);
   };

   /// Interface defining a Path object.
   [
      object,
      uuid(A43DACE9-956A-4421-9A3A-01D2453FCE03),
      oleautomation,
      helpcontext(IDH_Path),
      helpstring("IPath Interface"),
      pointer_default(unique)
   ]
   interface IPath : IUnknown //IPathElement
   {
      /// A PathElement item in the path
      [propget, helpstring("property Item"), helpcontext(IDH_Path_Item)] HRESULT Item([in] CollectionIndexType idx,[out, retval] IPathElement* *pVal);
      [propput, helpstring("property Item"), helpcontext(IDH_Path_Item)] HRESULT Item([in] CollectionIndexType idx,[in] IPathElement *pVal);

      /// The number of PathElement items in the path
      [propget, helpstring("property Count"), helpcontext(IDH_Path_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a PathElement to the collection
      [helpstring("method Add"), helpcontext(IDH_Path_Add)] HRESULT Add([in] IPathElement* element);

      /// Inserts a PathElement object into the Path at the specified index.
      [helpstring("method Insert"), helpcontext(IDH_Path_Insert)] HRESULT Insert([in] CollectionIndexType idx,[in] IPathElement* element);

      /// Removes all PathElement objects from the path
      [helpstring("method Clear"), helpcontext(IDH_Path_Clear)] HRESULT Clear();
      

      /// Computes the distance along the path and the offset from the path for a given point
      /// \image html /Path/Offset.jpg
      [helpstring("method DistanceAndOffset"), helpcontext(IDH_Path_Offset)] 
      HRESULT DistanceAndOffset(
         [in] IPoint2d* point, ///< The point whose distance and offset is to be computed
         [out] Float64* distance, ///< The distance from the start of the path where a normal line passing through point intersects the path
         [out] Float64* offset ///< The offset from the path to the point
      );

      /// Intersects a Line2d object with the Path, projecting the start and end tangents, returning the intersection point nearest a specified point.
      [helpstring("method Intersect")] HRESULT Intersect(
         [in] ILine2d* line, ///< The line to intersect with the path.
         [in]IPoint2d* pNearest, ///< A point used for comparison with multiple intersection points.
         [out,retval]IPoint2d** point ///< The intersection point closed to pNearest.
      );

      /// Intersects a Line2d object with the Path returning the intersection point nearest a specified point.
      [helpstring("method IntersectEx")] HRESULT IntersectEx(
         [in]ILine2d* line, ///< The line to intersect with the path.
         [in]IPoint2d* pNearest, ///< A point used for comparison with multiple intersection points.
         [in]VARIANT_BOOL vbProjectBack, ///< If VARIANT_TRUE, the back tangent line at the start of the path is considered to be part of the path
         [in]VARIANT_BOOL vbProjectAhead, ///< If VARIANT_TRUE, the ahead tangent line at the end of the path is considered to be part of the path
         [out,retval]IPoint2d** point ///< The intersection point closed to pNearest.
      );

      /// Creates a copy of the path. Copies all PathElements.
      [helpstring("method Clone"), helpcontext(IDH_Path_Clone)] HRESULT Clone([out, retval] IPath* *clone);
   };

   /// Interface defining an Alignment object
   [
      object,
      uuid(30638CFA-0F23-4784-8FC9-D1A2E4A50F02),
      oleautomation,
      helpcontext(IDH_Alignment),
      helpstring("IAlignment Interface"),
      pointer_default(unique)
   ]
   interface IAlignment : IUnknown
   {
      /// The alignment reference station.
      ///
      /// The reference station defines the stationing of the entire alignment. The reference station is the station at the beginning of the first PathElement. 
      /// If the first PathElement represents an CompoundCurve object, the reference station is at the TS point of the curve.
      [propget, helpstring("property RefStation"), helpcontext(IDH_Alignment_RefStation)] HRESULT RefStation([out, retval] IStation* *station);
      [propput, helpstring("property RefStation"), helpcontext(IDH_Alignment_RefStation)] HRESULT RefStation([in] VARIANT varStation);

      /// Adds a PathElement to the alignment
      [helpstring("method AddPathElement"), helpcontext(IDH_Alignment_Add)] HRESULT AddPathElement([in] IPathElement* element);

      /// Inserts a PathElement object into the alignment at the specified index.
      [helpstring("method InsertPathElement"), helpcontext(IDH_Alignment_Insert)] HRESULT InsertPathElement([in] CollectionIndexType idx,[in] IPathElement* element);

      /// A PathElement item in the alignment
      [propget, helpstring("property Item"), helpcontext(IDH_Alignment_Item)] HRESULT Item([in] CollectionIndexType idx, [out, retval] IPathElement** pVal);

      /// The number of PathElement items in the alignment
      [propget, helpstring("property Count"), helpcontext(IDH_Alignment_Count)] HRESULT Count([out, retval] CollectionIndexType* pVal);

      /// Removes all PathElement objects from the alignment
      [helpstring("method ClearPathElements"), helpcontext(IDH_Alignment_Clear)] HRESULT ClearPathElements();
      
      [] HRESULT AddProfile(IDType id, IProfile* pProfile);
      [] HRESULT GetProfile(IDType, IProfile** ppProfile);
      [] HRESULT ClearProfiles();

      /// Moves the alignment
      [helpstring("method Move"), helpcontext(IDH_Alignment_Move)]
      HRESULT Move(
         [in] Float64 dist, ///< Distance to move the alignment. The alignment is moved in the opposite direction then the Direction object indicates when this parameter is less than zero.
         [in] VARIANT varDirection ///< The direction to move the alignment.
      );

      /// Computes the station and offset from the alignment for a given point
      /// \image html /Alignment/Offset.jpg
      [helpstring("method StationAndOffset"), helpcontext(IDH_Alignment_Offset)]
      HRESULT StationAndOffset(
         [in] IPoint2d* point,///< The point whose station and offset is to be computed
         [out] IStation** station, ///< The station where a normal line passing through point intersects the alignment
         [out] Float64* offset ///< The offset from the alignment to the point
      );

      /// Projects a point onto the alignment
      /// If the projected point falls before the start or after the end of the alignment, then it will be a point on the back or forward tangent, respectively.
      /// \image html /Alignment/ProjectPoint.jpg
      [helpstring("method ProjectPoint"), helpcontext(IDH_Alignment_ProjectPoint)]
      HRESULT ProjectPoint(
         [in] IPoint2d* point, ///< The point to project onto the alignment
         [out] IPoint2d** newPoint, ///< The point on the alignment
         [out] IStation** ppStation, ///< Station on the alignment of the projected point
         [out] VARIANT_BOOL* pvbOnProjection ///< Set to VARIANT_TRUE if the point projects onto the back or forward tangent
      );

      /// Creates a Point object on the alignment at a specified location.
      /// \image html /Alignment/LocatePoint.jpg
      [helpstring("method LocatePoint"), helpcontext(IDH_Alignment_LocatePoint)] 
      HRESULT LocatePoint(
         [in] VARIANT varStation,  ///< Station from which the point is to be located
         [in] OffsetMeasureType offsetMeasure, ///< Specifies how offset is measured
         [in] Float64 offset,  ///< Offset from the path to the point
         [in] VARIANT varDir, ///< Direction from the path at which to locate the point
         [out,retval] IPoint2d* *newPoint///< The new point
      ); 

      /// Intersects a Line2d object with the alignment, projecting the start and end tangents, returning the intersection point nearest a specified point.
      [helpstring("method Intersect")] HRESULT Intersect(
         [in] ILine2d* line, ///< The line to intersect with the alignment.
         [in]IPoint2d* pNearest, ///< A point used for comparison with multiple intersection points.
         [out, retval]IPoint2d** point ///< The intersection point closest to pNearest.
      );

      /// Intersects a Line2d object with the Path returning the intersection point nearest a specified point.
      [helpstring("method IntersectEx")] HRESULT IntersectEx(
         [in]ILine2d* line, ///< The line to intersect with the alignment.
         [in]IPoint2d* pNearest, ///< A point used for comparison with multiple intersection points.
         [in]VARIANT_BOOL vbProjectBack, ///< If VARIANT_TRUE, the back tangent line at the start of the alignment is considered to be part of the alignment
         [in]VARIANT_BOOL vbProjectAhead, ///< If VARIANT_TRUE, the ahead tangent line at the end of the alignment is considered to be part of the alignment
         [out, retval]IPoint2d** point ///< The intersection point closest to pNearest.
      );

      /// Computes the bearing of the alignment at a specified station.
      /// \image html /Alignment/Bearing.jpg
      [helpstring("method GetBearing"), helpcontext(IDH_Alignment_Bearing)] 
      HRESULT GetBearing(
         [in] VARIANT varStation, ///< Station at which the bearing is to be computed
         [out,retval] IDirection* *dir ///< A Direction object representing the bearing
      );

      /// Computes the normal to the alignment at a specified station.
      /// \image html /Alignment/Normal.jpg
      [helpstring("method GetNormal"), helpcontext(IDH_Alignment_Normal)] 
      HRESULT GetNormal(
         [in] VARIANT varStation, ///< Station at which the normal is to be computed
         [out,retval] IDirection* *dir ///< A Direction object representing the normal
      );

      /// Gets the direction of a line at a specified station.
      ///
      /// The line orientation is a text string that represents an angle, a direction, or the keyword **Normal** indicating a line normal to the alignment. See \ref WBFL_COGO_Angles_Directions_Stations.
      [helpstring("method GetDirection")]
      HRESULT GetDirection(
         [in] VARIANT varStation, ///< Station where the direction is to be determined
         [in] BSTR bstrOrientation, ///< Orientation of the line.
         [out, retval] IDirection** direction ///< A Direction object representing the line.
      );

      /// Returns the length of the alignment
      [propget,helpstring("property Length")] HRESULT Length([out,retval]Float64* pLength);
      
      /// Creates a new Alignment that is offset from this Alignment.
      ///
      /// HorizCurve objects are degraded to points if the offset is on the same side of the Alignment as the center point and the offset exceeds the radius.
      /// CubicSpline objects are degraded to a point if lines normal to the spline at the control points intersect on the same side of the Alignment as the offset and the offset distance exceeds the distance from the spline to the intersection point.
      [helpstring("method CreateOffsetAlignment"),helpcontext(IDH_Alignment_CreateOffsetAlignment)] 
      HRESULT CreateOffsetAlignment(
         [in] Float64 offset, ///< Offset to the new alignment. The new alignment is to the right of the original alignment for positive values.
         [out,retval]IAlignment** alignment ///< The new Alignment object
      );

      /// Creates a new Alignment that is a subset of this Alignment.
      [helpstring("method CreateSubAlignment"),helpcontext(IDH_Alignment_CreateSubAlignment)] 
      HRESULT CreateSubAlignment(
         [in]VARIANT varStartStation, ///< Station of the start of the sub-alignment
         [in]VARIANT varEndStation, ///< Station of the end of the sub-alignment
         [out,retval]IAlignment** alignment ///< A new Alignment object
      );

      /// Creates a new Path that is parallel to the this Alignment.
      ///
      /// HorizCurve objects are degraded to points if the offset is on the same side of the Path as the center point and the offset exceeds the radius.
      /// CubicSpline objects are degraded to a point if lines normal to the spline at the control points intersect on the same side of the Path as the offset and the offset distance exceeds the distance from the spline to the intersection point.
      [helpstring("method CreateOffsetPath"),helpcontext(IDH_Alignment_CreateOffsetPath)] 
      HRESULT CreateOffsetPath(
         [in] Float64 offset,///< Offset to the new path. The new path is to the right of the original path for positive values.
         [out,retval]IPath** path /// The new path.
      );

      /// Creates a new Path that is a subset of this Alignment.
      [helpstring("method CreateSubPath"),helpcontext(IDH_Alignment_CreateSubPath)] 
      HRESULT CreateSubPath(
         [in]VARIANT varStartStation, ///< Station at the start of the sub-path
         [in]VARIANT varEndStation, ///< Station at the end of the sub-path
         [out,retval]IPath** path ///< A new Path object
      );

      [] HRESULT AddStationEquation(Float64 back, Float64 ahead);
      [] HRESULT GetStationEquationCount(IndexType* pCount);
      [] HRESULT GetStationEquation(IndexType i, IStationEquation** ppEquation);
      [] HRESULT ClearStationEquations();
      
      /// Creates a new station that is offset from the specified value. The new station is defined relative to its preceding station equation.
      [helpstring("method IncrementStation")] HRESULT IncrementStation([in]VARIANT varStation, [in] Float64 value, [out, retval]IStation** station);

      /// Moves a station by a specified offset. The resulting station is defined relative to its preceding station equation.
      [helpstring("method IncrementStationBy")] HRESULT IncrementStationBy([in]IStation* station, [in] Float64 value);

      /// Converts a station relative to a station equation to a station normalized to the associated alignment.
      [helpstring("method ConvertToNormalizedStation")] HRESULT ConvertToNormalizedStation([in] VARIANT varStation, [out, retval] Float64* station);

      /// Converts a station relative to a station equation to a station normalized to the associated alignment.
      [helpstring("method ConvertToNormalizedStationEx")] HRESULT ConvertToNormalizedStationEx([in] VARIANT varStation, [out, retval] IStation** station);

      /// Converts a station that is normalized to the associated alignment to a station relative to a station equation.
      [helpstring("method ConvertFromNormalizedStation")] HRESULT ConvertFromNormalizedStation([in] Float64 normalizedStation, [out, retval] IStation** station);

      /// Converts a station that is normalized to the associated alignment to a station relative to a station equation.
      [helpstring("method ConvertFromNormalizedStationEx")] HRESULT ConvertFromNormalizedStationEx([in] VARIANT varStation, [out, retval] IStation** station);

      [] HRESULT CompareStations(VARIANT varStation1, VARIANT varStation2, Int8* pResult);

      /// Computes the distance between stations, taking into account the station equations.
      ///
      /// Effectively computes \f$ distance = station2 - station1 \f$.
      [helpstring("method DistanceBetweenStations")] 
      HRESULT DistanceBetweenStations(
         [in] VARIANT station1, ///< The first station
         [in] VARIANT station2, ///< The second station
         [out,retval]Float64* pDist ///< The distance between stations.
      );

      /// Creates a copy of the alignment. Copies all PathElements.
      [helpstring("method Clone"), helpcontext(IDH_Alignment_Clone)] HRESULT Clone([out, retval] IAlignment* *clone);
   };

   /// Interface for measuring angles, distances, and angles in a COGO model.
   [
        object,
        uuid(C659E538-5EBE-11d5-8C32-006097C68A9C),
        oleautomation,
      helpcontext(IDH_IMeasure),
        helpstring("IMeasure Interface"),
        pointer_default(unique)
    ]
    interface IMeasure : IUnknown
    {
       /// Measures the angle formed by three non-coincident points.
       ///
       /// \image html /Measure/Angle.jpg
        [helpstring("method Angle"),helpcontext(IDH_IMeasure_Angle)] HRESULT Angle(
           [in] IDType fromID, ///< ID of the point the angle is measured from
           [in] IDType vertexID, ///< ID of the point at the vertex of the angle
           [in] IDType toID, ///< ID of the point the angle is measured to
           [out,retval] IAngle** angle ///< The angle
        );

        /// Measures the angle of a polygon.
        ///
        /// \image html /Measure/Area.jpg
        /// The polygon must consist of at least three non-colinear points. Points may be defined either clockwise or counter-clockwise. The last point need not be the same as the first. 
        /// Degenerate polygons (polygon with intersecting edges such as a bow-tie shape) are not detected. An incorrect area will be computed if a degenerate polygon is input.
        /// This method is not available to JavaScript clients.However, as an alternative, you can use a WBFLGeometry::Polyshape object to compute area.
        [helpstring("method Area"),helpcontext(IDH_IMeasure_Area)] HRESULT Area(
           [in] VARIANT IDs, ///< An array of IDs identifying the points that comprise the polygon
           [out,retval] Float64* area ///< The area of the polygon
        );

        /// Measures the distance between two points.
        ///
        /// \image html /Measure/Distance.jpg
        [helpstring("method Distance"),helpcontext(IDH_IMeasure_Distance)] HRESULT Distance(
           [in] IDType fromID, ///< ID of the first point
           [in] IDType toID, ///< ID of the second point
           [out,retval] Float64* dist ///< Distance between the points
        );

        /// Measures the direction between two points.
        ///
        /// \image html /Measure/Direction.jpg
        [helpstring("method Direction"),helpcontext(IDH_IMeasure_Direction)] HRESULT Direction(
           [in] IDType fromID, ///< ID of the first point
           [in] IDType toID, ///< ID of the second point
           [out,retval] IDirection** dir ///< Direction of the line from the first to second point
        );

        /// Measures the distance and direction between two points.
        ///
        /// \image html /Measure/Direction.jpg
        [helpstring("method Inverse"),helpcontext(IDH_IMeasure_Inverse)] HRESULT Inverse(
           [in] IDType fromID, ///< ID of the first point
           [in] IDType toID, ///< ID of the second point
           [out] Float64* dist, ///< Distance between the points
           [out] IDirection** dir ///< Direction of the line from the first to second point
        );
    };

    /// Interface for measuring angles, distances, and angles
    [
        object,
        uuid(677836E0-0FC9-42b3-867E-F26D7DB5591D),
        oleautomation,
      helpcontext(IDH_IMeasure),
        helpstring("IMeasure2 Interface"),
        pointer_default(unique)
    ]
    interface IMeasure2 : IUnknown
    {
       /// Measures the angle formed by three non-coincident points.
       ///
       /// \image html /Measure2/Angle.jpg
       [helpstring("method Angle"),helpcontext(IDH_IMeasure_Angle)] HRESULT Angle(
          [in] IPoint2d* from, ///< Point the angle is measured from
          [in] IPoint2d* vertex, ///< Point at the vertex of the angle
          [in] IPoint2d* to, ///< Point the angle is measured to
          [out,retval] IAngle** angle ///< The angle
       );
       
       /// Measures the angle of a polygon.
       ///
       /// \image html /Measure2/Area.jpg
       /// The polygon must consist of at least three non-colinear points. Points may be defined either clockwise or counter-clockwise. The last point need not be the same as the first. 
       /// Degenerate polygons (polygon with intersecting edges such as a bow-tie shape) are not detected. An incorrect area will be computed if a degenerate polygon is input.
       [helpstring("method Area"),helpcontext(IDH_IMeasure_Area)] HRESULT Area(
          [in] IPoint2dCollection* points, ///< Collection of points that comprise the polygon
          [out,retval] Float64* area ///< The area of the polygon
       );

       /// Measures the distance between two points.
       ///
       /// \image html /Measure2/Distance.jpg
       [helpstring("method Distance"),helpcontext(IDH_IMeasure_Distance)] HRESULT Distance(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to, ///< The second point
          [out,retval] Float64* dist ///< Distance between the points
       );

       /// Measures the direction between two points.
       ///
       /// \image html /Measure2/Direction.jpg
       [helpstring("method Direction"),helpcontext(IDH_IMeasure_Direction)] HRESULT Direction(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to, ///< The second point
          [out,retval] IDirection** dir ///< Direction of the line from the first to second point
       );

       /// Measures the distance and direction between two points.
       ///
       /// \image html /Measure2/Direction.jpg
       [helpstring("method Inverse"),helpcontext(IDH_IMeasure_Inverse)] HRESULT Inverse(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to,///< The second point
          [out] Float64* dist, ///< Distance between the points
          [out] IDirection** dir ///< Direction of the line from the first to second point
       );
    };

    /// Interface for locating points and lines in a COGO model.
    [
        object,
        uuid(26FFDDD8-5EB8-11d5-8C32-006097C68A9C),
        oleautomation,
      helpcontext(IDH_ILocate),
        helpstring("ILocate Interface"),
        pointer_default(unique)
    ]
    interface ILocate : IUnknown
    {
       /// Locates a point by distance and angle
       /// \image html /Locate/ByDistAngle.jpg
        [helpstring("method ByDistAngle"),helpcontext(IDH_ILocate_ByDistAngle)] HRESULT ByDistAngle(
           [in] IDType newID, ///< ID for storing the new point
           [in] IDType fromID, ///< ID of the first point
           [in] IDType toID,  ///< ID of the second point
           [in] Float64 dist,  ///< Distance from the second point where the new point is located
           [in] VARIANT varAngle,  ///< Angle from the line between the first and second point at which to locate the new point
           [in] Float64 offset ///< Offset from the line between the first and second point.
        );

        /// Locates a point by distance and deflection angle
        /// \image html /Locate/ByDistDefAngle.jpg
        [helpstring("method ByDistDefAngle"),helpcontext(IDH_ILocate_ByDistDefAngle)] HRESULT ByDistDefAngle(
           [in] IDType newID, ///< ID for storing the new point
           [in] IDType fromID, ///< ID of the first point
           [in] IDType toID,  ///< ID of the second point
           [in] Float64 dist,  ///< Distance from the second point where the new point is located
           [in] VARIANT varDefAngle, ///< Deflection angle the line between the first and second point at which to locate the point
           [in] Float64 offset ///< Offset from the line between the first and second point.
        );

        /// Locates a point by distance and direction
        /// \image html /Locate/ByDistDir.jpg
        [helpstring("method ByDistDir"),helpcontext(IDH_ILocate_ByDistDir)] HRESULT ByDistDir(
           [in] IDType newID, ///< ID for storing the new point
           [in] IDType fromID, ///< ID of the point the new point is located from
           [in] Float64 dist, ///< Distance from the point to the new point
           [in] VARIANT varDir,  ///< Direction at which to locate the point
           [in] Float64 offset ///< Offset from the line defined by the point and direction
        );

        /// Locates a point on a line
        /// \image html /Locate/PointOnLine.jpg
        [helpstring("method PointOnLine"),helpcontext(IDH_ILocate_PointOnLine)] HRESULT PointOnLine(
           [in] IDType newID, ///< ID for storing the new point
           [in] IDType fromID,  ///< ID of the point the new point is located from
           [in] IDType toID,   ///< ID of the second point
           [in] Float64 dist, ///< Distance from the first point to the new point. If a negative value is used, the new point will be located before the start point.
           [in] Float64 offset ///< Offset from the line between the first and second point to the new point.
        );

        /// Locates a line parallel to a line defined by two points.
        /// \image html /Locate/ParallelLineByPoints.jpg
        [helpstring("method ParallelLineByPoints"),helpcontext(IDH_ILocate_ParallelLineByPoints)] HRESULT ParallelLineByPoints(
           [in] IDType newFromID, ///< ID for storing the new line start point
           [in] IDType newToID, ///< ID for storing the new line end point
           [in] IDType fromID, ///< ID of the start point of the line
           [in] IDType toID,  ///< ID of the end point of the line
           [in] Float64 offset ///< Offset from the source line to the new line.
        );

        /// Locates a parallel line segment.
        /// \image html /Locate/ParallelLineSegment.jpg
        [helpstring("method ParallelLineSegment"),helpcontext(IDH_ILocate_ParallelLineSegment)] HRESULT ParallelLineSegment(
           [in] IDType newLineID, ///< ID for storing the new line
           [in] IDType newFromID, ///< ID for storing the start point for the new line segment
           [in] IDType newToID, ///< ID for storing the end point for the new line segment
           [in] IDType lineID, ///< ID of the source line segment
           [in] Float64 offset ///< Offset from the source line segment
        );
    };

    /// Interface for locating points and lines
    [
        object,
        uuid(2F0AAEBF-F043-4d50-8E11-709CF6079F5F),
        oleautomation,
      helpcontext(IDH_ILocate),
        helpstring("ILocate Interface"),
        pointer_default(unique)
    ]
    interface ILocate2 : IUnknown
    {
       /// Locates a point by distance and angle
       /// \image html /Locate2/ByDistAngle.jpg
       [helpstring("method ByDistAngle"),helpcontext(IDH_ILocate_ByDistAngle)] HRESULT ByDistAngle(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to, ///< The second point
          [in] Float64 dist, ///< Distance from the second point to the new point
          [in] VARIANT varAngle,  ///< Angle from the line between the first and second point at which to locate the new point
          [in] Float64 offset, ///< Offset from the line between the first and second point
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Locates a point by distance and deflection angle
       /// \image html /Locate2/ByDistDefAngle.jpg
       [helpstring("method ByDistDefAngle"),helpcontext(IDH_ILocate_ByDistDefAngle)] HRESULT ByDistDefAngle(
          [in] IPoint2d* from,  ///< The first point
          [in] IPoint2d* to, ///< The second point
          [in] Float64 dist, ///< Distance from the second point to the new point
          [in] VARIANT varDefAngle, ///< Deflection angle the line between the first and second point at which to locate the point
          [in] Float64 offset, ///< Offset from the line between the first and second point.
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Locates a point by distance and direction
       /// \image html /Locate2/ByDistDir.jpg
       [helpstring("method ByDistDir"),helpcontext(IDH_ILocate_ByDistDir)] HRESULT ByDistDir(
          [in] IPoint2d* from, ///< The point the new point is located from
          [in] Float64 dist, ///< Distance from the point to the new point
          [in] VARIANT varDir,  ///< Direction at which to locate the point
          [in] Float64 offset, ///< Offset from the line defined by the point and direction
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Locates a point on a line
       /// \image html /Locate2/PointOnLine.jpg
       [helpstring("method PointOnLine"),helpcontext(IDH_ILocate_PointOnLine)] HRESULT PointOnLine(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to, ///< The second point 
          [in] Float64 dist, ///< Distance from the first point to the new point. If a negative value is used, the new point will be located before the start point.
          [in] Float64 offset,///< Offset from the line between the first and second point to the new point.
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Locates a line parallel to a line defined by two points.
       /// \image html /Locate2/ParallelLineByPoints.jpg
       [helpstring("method ParallelLineByPoints"),helpcontext(IDH_ILocate_ParallelLineByPoints)] HRESULT ParallelLineByPoints(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to,  ///< The second point
          [in] Float64 offset, ///< Offset from the source line to the new line
          [out]IPoint2d** p1, ///< Start point of the new line
          [out]IPoint2d** p2 ///< End point of the new line
       );

       /// Locates a parallel line segment.
       /// \image html /Locate2/ParallelLineSegment.jpg
       [helpstring("method ParallelLineSegment"),helpcontext(IDH_ILocate_ParallelLineSegment)] HRESULT ParallelLineSegment(
          [in] ILineSegment2d* ls, ///< A line segment
          [in] Float64 offset, ///< Offset from the line segment to the new line segment
          [out,retval]ILineSegment2d** linesegment ///< The new line segment
       );
    };

    /// Interface for intersecting lines and circles in a COGO model.
    [
        object,
        uuid(26FFDDD6-5EB8-11d5-8C32-006097C68A9C),
        oleautomation,
      helpcontext(IDH_IIntersect),
        helpstring("IIntersect Interface"),
        pointer_default(unique)
    ]
    interface IIntersect : IUnknown
    {
       /// Intersects two lines defined by point and direction.
       /// \image html /Intersect/Bearings.jpg
      [helpstring("method Bearings"),helpcontext(IDH_IIntersect_Bearings)] HRESULT Bearings(
         [in] IDType newID, ///< ID for storing the new point
         [in] IDType id1, ///< ID of a point on the first line
         [in] VARIANT varDir1,  ///< Direction of the first line
         [in] Float64 offset1, ///< Offset from the first line
         [in] IDType id2,  ///< ID of a point on the second line
         [in] VARIANT varDir2, ///< Direction of the second line
         [in] Float64 offset2,  ///< Offset from the second line
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects a line defined by a point and direction with a circle.
      /// \image html /Intersect/BearingCircle.jpg
      [helpstring("method BearingCircle"),helpcontext(IDH_IIntersect_BearingCircle)] HRESULT BearingCircle(
         [in]IDType newID, ///< ID for storing the new point
         [in] IDType id1,  ///< ID of a point on the line
         [in] VARIANT varDir, ///< Direction of the line
         [in] Float64 offset, ///< Offset from the line
         [in] IDType idc,  ///< ID of the circle center point 
         [in] Float64 radius,  ///< Circle radius
         [in] IDType idNearest,  ///< ID of a point that will be nearest the solution point in the event two intersection points are found
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );


      /// Intersects two circles
      /// \image html /Intersect/Circles.jpg
      [helpstring("method Circles"),helpcontext(IDH_IIntersect_Circles)] HRESULT Circles(
         [in]IDType newID, ///< ID for storing the new point
         [in] IDType id1,  ///< ID of the first circle center point
         [in] Float64 r1,  ///< Radius of the first circle
         [in] IDType id2,  ///< ID of the second circle center point
         [in] Float64 r2,  ///< Radius of the second circle
         [in] IDType idNearest,  ///< ID of a point that will be nearest the solution point in the event two intersection points are found 
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects a line defined by two points with a circle.
      /// \image html /Intersect/LineByPointsCircle.jpg
      [helpstring("method LineByPointsCircle"),helpcontext(IDH_IIntersect_LineByPointsCircle)] HRESULT LineByPointsCircle(
         [in]IDType newID, ///< ID for storing the new point
         [in] IDType id1, ///< ID of first point on the line
         [in] IDType id2,  ///< ID of the second point on the line
         [in] Float64 offset, ///< Offset from the line
         [in] IDType idc,  ///< ID of the circle center point
         [in] Float64 radius, ///< Circle radius
         [in] IDType idNearest,  ///< ID of a point that will be nearest the solution point in the event two intersection points are found 
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects two lines defined by points.
      /// \image html /Intersect/LinesByPoints.jpg
      [helpstring("method LinesByPoints"),helpcontext(IDH_IIntersect_LinesByPoints)] HRESULT LinesByPoints(
         [in]IDType newID, ///< ID for storing the new point
         [in] IDType id11, ///< ID of first point through which the first line passes
         [in] IDType id12,  ///< ID of second point through which the first line passes
         [in] Float64 offset1, ///< Offset from first line
         [in] IDType id21, ///< ID of first point through which the second line passes
         [in] IDType id22, ///< ID of second point through which the second line passes
         [in] Float64 offset2, ///< Offset from second line
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects two line segments.
      /// \image html /Intersect/Lines.jpg
      [helpstring("method Lines"),helpcontext(IDH_IIntersect_Lines)] HRESULT Lines(
         [in]IDType newID, ///< ID for storing the new point
         [in]IDType id1, ///< ID of first line segment
         [in]Float64 offset1, ///< Offset from first line segment
         [in]IDType id2, ///< ID of second line segment
         [in]Float64 offset2, ///< Offset from second line segment
         [out,retval]VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects a line segment and a circle
      /// \image html /Intersect/LineSegmentCircle.jpg
      [helpstring("method LineSegmentCircle"),helpcontext(IDH_IIntersect_LineSegmentCircle)] HRESULT LineSegmentCircle(
         [in]IDType newID, ///< ID for storing the new point
         [in] IDType lineID, ///< ID of the line segment
         [in] Float64 offset, ///< Offset from the line segment
         [in] IDType idc,  ///< ID of the circle center point
         [in] Float64 radius,  ///< Circle radius
         [in] IDType idNearest,  ///< ID of a point that will be nearest the solution point in the event two intersection points are found 
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );
    };

    /// Interface for intersection lines and circles
    [
        object,
        uuid(5AFCF67A-4802-42cf-9C5C-AF5A61D4D0D4),
        oleautomation,
      helpcontext(IDH_IIntersect),
        helpstring("IIntersect Interface"),
        pointer_default(unique)
    ]
    interface IIntersect2 : IUnknown
    {
       /// Intersects two lines defined by point and direction.
       /// \image html /Intersect2/Bearings.jpg
       [helpstring("method Bearings"),helpcontext(IDH_IIntersect_Bearings)] HRESULT Bearings(
          [in] IPoint2d* p1, ///< First point on the first line
          [in] VARIANT varDir1,  ///< Direction of the first line
          [in] Float64 offset1, ///< Offset from the first line
          [in] IPoint2d* p2, ///< Point on the second line 
          [in] VARIANT varDir2,  ///< Direction of the second line
          [in] Float64 offset2,  ///< Offset from the second line
          [out,retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects a line defined by a point and direction with a circle.
       /// \image html /Intersect2/BearingCircle.jpg
       [helpstring("method BearingCircle"),helpcontext(IDH_IIntersect_BearingCircle)] HRESULT BearingCircle(
          [in] IPoint2d* p1, ///< Point on the line
          [in] VARIANT varDir,  ///< Direction of the line
          [in] Float64 offset, ///< Offset from the line
          [in] IPoint2d* center,  ///< Center of the circle
          [in] Float64 radius,  ///< Circle radius
          [in] IPoint2d* nearest,  ///< Point that will be nearest the solution point in the event two intersection points are found
          [out,retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects two circles
       /// \image html /Intersect2/Circles.jpg
       [helpstring("method Circles"),helpcontext(IDH_IIntersect_Circles)] HRESULT Circles(
          [in] IPoint2d* p1, ///< Center of first circle
          [in] Float64 r1, ///< Radius of first circle
          [in] IPoint2d* p2,  ///< Center of second circle
          [in] Float64 r2,  ///< Radius of second circle
          [in] IPoint2d* nearest,  ///< Point that will be nearest the solution point in the event two intersection points are found
          [out, retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects a line defined by two points with a circle.
       /// \image html /Intersect2/LineByPointsCircle.jpg
       [helpstring("method LineByPointsCircle"),helpcontext(IDH_IIntersect_LineByPointsCircle)] HRESULT LineByPointsCircle(
          [in] IPoint2d* p1, ///< First point on the line
          [in] IPoint2d* p2,  ///< Second point on the line
          [in] Float64 offset, ///< Offset from the line
          [in] IPoint2d* center,  ///< Center of the circle
          [in] Float64 radius,  ///< Circle radius
          [in] IPoint2d* nearest,  ///< Point that will be nearest the solution point in the event two intersection points are found
          [out, retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects two lines defined by points.
       /// \image html /Intersect2/LinesByPoints.jpg
       [helpstring("method LinesByPoints"),helpcontext(IDH_IIntersect_LinesByPoints)] HRESULT LinesByPoints(
          [in] IPoint2d* p11, ///< First point through which the first line passes
          [in] IPoint2d* p12, ///< Second point through which the first line passes 
          [in] Float64 offset1, ///< Offset from the first line
          [in] IPoint2d* p21,  ///< First point through which the second line passes
          [in] IPoint2d* p22,  ///< Second point through which the second line passes
          [in] Float64 offset2, ///< Offset from the second line
          [out,retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects two line segments.
       /// \image html /Intersect2/Lines.jpg
       [helpstring("method Lines"),helpcontext(IDH_IIntersect_Lines)] HRESULT Lines(
          [in]ILineSegment2d* l1, ///< First line segment
          [in]Float64 offset1, ///< Offset from first line segment
          [in]ILineSegment2d* l2, ///< Second line segment
          [in]Float64 offset2, ///< Offset from second line segment
          [out,retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects a line segment and a circle
       /// \image html /Intersect2/LineSegmentCircle.jpg
       [helpstring("method LineSegmentCircle"),helpcontext(IDH_IIntersect_LineSegmentCircle)] HRESULT LineSegmentCircle(
          [in] ILineSegment2d* pSeg, ///< The line segment
          [in] Float64 offset, ///< Offset from the line segment
          [in] IPoint2d* center,  ///< Center of circle
          [in] Float64 radius,  ///< Circle radius
          [in] IPoint2d* nearest,  ///< Point that will be nearest the solution point in the event two intersection points are found
          [out, retval] IPoint2d** point ///< The intersection point
       );
    };

    /// Interface for creating points by projection onto lines and curves in a COGO model.
    [
        object,
        uuid(6B161BA4-6582-11d5-8C3D-006097C68A9C),
        oleautomation,
      helpcontext(IDH_IProject),
        helpstring("IProject Interface"),
        pointer_default(unique)
    ]
    interface IProject : IUnknown
    {
       /// Projects a point onto a CompoundCurve. If the point projects before or after the TS or ST point on the curve, the projected point will be on the Back or Forward Tangent, respectively.
       /// \image html /Project/PointOnCurve.jpg
       [helpstring("method PointOnCurve"), helpcontext(IDH_IProject_PointOnCurve)] HRESULT PointOnCurve(
          [in]IDType newID,  ///< ID for storing the new point
          [in] IDType fromID, ///< ID of the point to project
          [in]IDType curveID ///< ID of the curve
       );

       /// Projects a point onto a line defined by two points.
       /// \image html /Project/PointOnLineByPoints.jpg
       [helpstring("method PointOnLineByPoints"),helpcontext(IDH_IProject_PointOnLineByPoints)] HRESULT PointOnLineByPoints(
          [in] IDType newID, ///< ID for storing the new point
          [in] IDType fromID, ///< ID of the point to be projected
          [in] IDType startID,  ///< ID of first point on the line
          [in] IDType endID, ///< ID of second point on the line
          [in] Float64 offset ///< Offset from the line
       );

       /// Projects a point onto a line segment.
       /// \image html /Project/PointOnLneSegment.jpg
       [helpstring("method PointOnLineSegment"),helpcontext(IDH_IProject_PointOnLineSegment)] HRESULT PointOnLineSegment(
          [in]IDType newID, ///< ID for storing the new point
          [in]IDType fromID, ///< ID of the point to be projected
          [in] IDType lineID, ///< ID of the line segment
          [in] Float64 offset ///< Offset from the line segment
       );
    };

    /// Interface for creating points by projection onto lines and curves.
    [
        object,
        uuid(FB5BBBA8-6CFD-4cfe-8A0B-DEAB8A7AF254),
        oleautomation,
      helpcontext(IDH_IProject),
        helpstring("IProject Interface"),
        pointer_default(unique)
    ]
    interface IProject2 : IUnknown
    {
       /// Projects a point onto a line defined by two points.
       /// \image html /Project2/PointOnLineByPoints.jpg
       [helpstring("method PointOnLineByPoints"),helpcontext(IDH_IProject_PointOnLineByPoints)] HRESULT PointOnLineByPoints(
          [in] IPoint2d* pnt, ///< The point to project
          [in] IPoint2d* start, ///< First point on the line
          [in] IPoint2d* end,  ///< Second point on the line
          [in] Float64 offset, ///< Offset from the line
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Projects a point onto a line segment.
       /// \image html /Project2/PointOnLneSegment.jpg
       [helpstring("method PointOnLineSegment"),helpcontext(IDH_IProject_PointOnLineSegment)] HRESULT PointOnLineSegment(
          [in] IPoint2d* from, ///< The point to project
          [in] ILineSegment2d* seg,  ///< The line segment
          [in] Float64 offset, ///< Offset from the line segment
          [out,retval]IPoint2d** point ///< The new point
       );
    };

    /// Interface for creating points by dividing distances, lines, and arcs in a COGO model.
    [
      object,
      uuid(2754C92C-D653-40ef-875B-D4126671E5B5),
      oleautomation,
     helpcontext(IDH_IDivide),
      helpstring("IDivide Interface"),
      pointer_default(unique)
   ]
   interface IDivide : IUnknown
   {
      /// Divides an arc into equal length segments.
      /// This method will divide an arc into nParts equally spaced points. nParts-2 points will be created. The end points of the arc are not duplicated. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DivideArc.jpg
      [helpstring("method Arc"),helpcontext(IDH_IDivide_Arc)] HRESULT Arc(
         [in]IDType firstID, ///< ID of the first new point
         [in] IDType idInc, ///< Point ID increment
         [in] IDType fromID,  ///< ID of the point the arc is measured from
         [in] IDType vertexID,  ///< ID of the vertex point
         [in] IDType toID, ///< ID of the point the arc is measured to
         [in] CollectionIndexType nParts ///< Number of parts to divide the arc into.
      );

      /// Divides the distance between two points.
      /// This method will divide a line segment defined by two points into nParts equally spaced points. nParts-2 points will be created. The end points of the line segment are not duplicated. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DivideBetweenPoints.jpg
      [helpstring("method BetweenPoints"),helpcontext(IDH_IDivide_BetweenPoints)] HRESULT BetweenPoints(
         [in]IDType firstID, ///< ID of the first new point
         [in] IDType idInc, ///< Point ID increment
         [in] IDType fromID,  ///< ID of the start line segment point
         [in] IDType toID, ///< ID of the end line segment point
         [in] CollectionIndexType nParts ///< Number of parts to divide the line segment into.
      );

      /// Divides a line segment.
      /// This method will divide a line segment into nParts equally spaced points. nParts-2 points will be created. The end points of the line segment are not duplicated. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DivideLineSegment.jpg
      [helpstring("method LineSegment"),helpcontext(IDH_IDivide_LineSegment)] HRESULT LineSegment(
         [in]IDType firstID, ///< ID of the first new point
         [in] IDType idInc,  ///< Point ID increment
         [in] IDType lineID, ///< ID of the line segment
         [in] CollectionIndexType nParts ///< Number of parts to divide the line segment into.
      );

      /// Divides a CompoundCurve.
      /// This method will divide a horizontal curve into nParts equally spaced points. nParts-2 points will be created. The end points of the horizontal curve (TS and ST) are not duplicated. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DivideCompoundCurve.jpg
      [helpstring("method CompoundCurve"),helpcontext(IDH_IDivide_CompoundCurve)] HRESULT CompoundCurve(
         [in]IDType firstID,  ///< ID of the first new point
         [in] IDType idInc,  ///< Point ID increment
         [in] IDType curveID, ///< ID of the CompoundCurve
         [in] CollectionIndexType nParts ///< Number of parts to divide the CompoundCurve into.
      );

      /// Divides a Path.
      /// This method will divide a path into nParts equally spaced points. nParts+1 points will be created. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DividePath.png
      [helpstring("method Path"),helpcontext(IDH_IDivide_Path)] HRESULT Path(
         [in]IDType firstID,///< ID of the first new point
         [in]IDType idInc,///< Point ID increment
         [in] IDType pathID, ///< ID of the Path
         [in] CollectionIndexType nParts, ///< Number of parts to divide the Path into.
         [in] Float64 start, ///< Distance from the start of the path to the start of the divided range
         [in] Float64 end ///< Distance from the start of the path to the end of the divided range
      );
   };

   /// Interface for creating points by dividing distances, lines, and arcs.
   [
      object,
      uuid(BF909705-8DEE-4797-A497-4BEDB2156BB5),
      oleautomation,
     helpcontext(IDH_IDivide),
      helpstring("IDivide Interface"),
      pointer_default(unique)
   ]
   interface IDivide2 : IUnknown
   {
      /// Divides an arc into equal length segments.
      /// This method will divide an arc into nParts equally spaced points. nParts-2 points will be created. The end points of the arc are not duplicated.
      /// \image html /Divide2/DivideArc.jpg
      [helpstring("method Arc"),helpcontext(IDH_IDivide_Arc)] HRESULT Arc(
         [in] IPoint2d* from, ///< Point arc is measured from
         [in] IPoint2d* vertex,  ///< Vertex point
         [in] IPoint2d* to, ///< Point arc is measured to
         [in] CollectionIndexType nParts, ///< Number of parts to divide the arc into.
         [out,retval] IPoint2dCollection** points ///< A collection of the resulting points.
      );

      /// Divides the distance between two points.
      /// This method will divide a line segment defined by two points into nParts equally spaced points. nParts-2 points will be created. The end points of the line segment are not duplicated.
      /// \image html /Divide2/DivideBetweenPoints.jpg
      [helpstring("method BetweenPoints"),helpcontext(IDH_IDivide_BetweenPoints)] HRESULT BetweenPoints(
         [in] IPoint2d* from, ///< Start point
         [in] IPoint2d* to,///< End points
         [in] CollectionIndexType nParts, ///< Number of parts to divide the line segment into.
         [out,retval] IPoint2dCollection** points ///< A collection of the resulting points.
      );

      /// Divides a line segment.
      /// This method will divide a line segment into nParts equally spaced points. nParts-2 points will be created. The end points of the line segment are not duplicated.
      /// \image html /Divide2/DivideLineSegment.jpg
      [helpstring("method LineSegment"),helpcontext(IDH_IDivide_LineSegment)] HRESULT LineSegment(
         [in] ILineSegment2d* seg, ///< Line segment to divide
         [in] CollectionIndexType nParts, ///< Number of parts to divide the line segment into.
         [out,retval]IPoint2dCollection** points ///< A collection of the resulting points.
      );

      /// Divides a CompoundCurve.
      /// This method will divide a horizontal curve into nParts equally spaced points. nParts-2 points will be created. The end points of the horizontal curve (TS and ST) are not duplicated.
      /// \image html /Divide2/DivideCompoundCurve.jpg
      [helpstring("method CompoundCurve"),helpcontext(IDH_IDivide_CompoundCurve)] HRESULT CompoundCurve(
         [in] ICompoundCurve* curve, ///< CompoundCurve to divide
         [in] CollectionIndexType nParts,  ///< Number of parts to divide the CompoundCurve into.
         [out,retval] IPoint2dCollection** points ///< A collection of the resulting points.
      );

      /// Divides a Path.
      /// This method will divide a path into nParts equally spaced points. nParts+1 points will be created.
      /// \image html /Divide2/DividePath.png
      [helpstring("method Path"),helpcontext(IDH_IDivide_Path)] HRESULT Path(
         [in]IPath* pPath, ///< The Path to divide
         [in] CollectionIndexType nParts, ///< Number of parts to divide the Path into.
         [in] Float64 start, ///< Distance from the start of the path to the start of the divided range
         [in] Float64 end, ///< Distance from the start of the path to the end of the divided range
         [out,retval]IPoint2dCollection** points ///< A collection of the resulting points.
      );
   };

   /// Interface for locating tangents to curves in a COGO model.
   [
      object,
      uuid(E2984C32-607E-4ca3-8424-F8041D5F49D1),
      oleautomation,
     helpcontext(IDH_ITangent),
      helpstring("ITangent Interface"),
      pointer_default(unique)
   ]
   interface ITangent : IUnknown
   {
      /// Locates points tangent to two circles where the tangent lines cross between circles.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent/Cross.gif
      [helpstring("method Cross"),helpcontext(IDH_ITangent_Cross)] HRESULT Cross(
         [in] IDType newID1,  ///< ID of the new point on the first circle
         [in] IDType idCenter1,  ///< ID of the second circle center point
         [in] Float64 radius1, ///< First circle radius
         [in] IDType newID2, ///< ID of the new point on the second circle
         [in] IDType idCenter2,  ///< ID of the second circle center point
         [in] Float64 radius2,  ///< Second circle radius
         [in] TangentSignType tangent ///< Indicates which of the two tangent lines to use to locate the tangent points
      );

      /// Locates points tangent to two circles where the tangent lines are external to the circles.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent/External.gif
      [helpstring("method External"), helpcontext(IDH_ITangent_External)] HRESULT External(
         [in] IDType newID1,  ///< ID of the new point on the first circle
         [in] IDType idCenter1,  ///< ID of first circle center point
         [in] Float64 radius1, ///< First circle radius
         [in] IDType newID2, ///< ID of the new point on the second circle
         [in] IDType idCenter2,  ///< ID of the second circle center point
         [in] Float64 radius2,  ///< Second circle radius
         [in] TangentSignType tangent ///< Indicates which of the two tangent lines to use to locate the tangent points
      );

      /// Locates point tangent to a circle.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent/Point.gif
      [helpstring("method Point"),helpcontext(IDH_ITangent_Point)] HRESULT Point(
         [in] IDType newID,  ///< ID of the new point
         [in] IDType idCenter,  ///< ID of the circle center point
         [in] Float64 radius, ///< Circle radius
         [in] IDType pointID, ///< ID of the point forming a line passing through the circle center point
         [in] TangentSignType tangent ///< Indicates which of the two tangent lines to use to locate the tangent points
      );
   };

   /// Interface for locating tangents to curves.
   [
      object,
      uuid(F51A43BB-85DD-41a1-9B32-B61D9005B0D0),
      oleautomation,
     helpcontext(IDH_ITangent),
      helpstring("ITangent Interface"),
      pointer_default(unique)
   ]
   interface ITangent2 : IUnknown
   {
      /// Locates points tangent to two circles where the tangent lines cross between circles.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent2/Cross.gif
      [helpstring("method Cross"),helpcontext(IDH_ITangent_Cross)] HRESULT Cross(
         [in] IPoint2d* center1, ///< Center of the first circle
         [in] Float64 radius1, ///< Radius of the first circle
         [in] IPoint2d* center2,  ///< Center of the second circle
         [in] Float64 radius2,  ///< Radius of the second circle
         [in] TangentSignType tangent,  ///< Indicates which of the two tangent lines to use to locate the tangent points
         [out] IPoint2d** t1, ///< Tangent point on first circle
         [out] IPoint2d** t2 ///< Tangent point on second circle
      );

      /// Locates points tangent to two circles where the tangent lines are external to the circles.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent2/External.gif
      [helpstring("method External"), helpcontext(IDH_ITangent_External)] HRESULT External(
         [in] IPoint2d* center1, ///< Center of the first circle
         [in] Float64 radius1, ///< Radius of the first circle
         [in] IPoint2d* center2,  ///< Center of the second circle
         [in] Float64 radius2,  ///< Radius of the second circle
         [in] TangentSignType tangent,  ///< Indicates which of the two tangent lines to use to locate the tangent points
         [out] IPoint2d** t1, ///< Tangent point on first circle
         [out] IPoint2d** t2 ///< Tangent point on second circle
      );

      /// Locates point tangent to a circle.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent2/Point.gif
      [helpstring("method Point"),helpcontext(IDH_ITangent_Point)] HRESULT Point(
         [in] IPoint2d* center, ///< Center of the circle
         [in] Float64 radius, ///< Circle radius
         [in] IPoint2d* point, ///< Point forming a line passing through the circle center point
         [in] TangentSignType tangent,  ///< Indicates which of the two tangent lines to use to locate the tangent points
         [out] IPoint2d** pntTangent ///< The tangent point
      );
   };

   /// Interface defining a coordinate geometry computational engine
   [
      object,
      uuid(AF7FCB40-3E8B-45BE-B8E9-AC8ADF4DDB81),
   
      helpstring("ICogoEngine Interface"),
      pointer_default(unique)
   ]
   interface ICogoEngine : IUnknown
   {
      /// Interface for computing intersections
      [propget, helpstring("property Intersect"),helpcontext(IDH_CogoModel_Intersect)] HRESULT Intersect([out, retval] IIntersect2* *pVal);

      /// Interface for locating points
      [propget, helpstring("property Locate"),helpcontext(IDH_CogoModel_Locate)] HRESULT Locate([out, retval] ILocate2* *pVal);

      /// Interface for measring angles, distances, and area
      [propget, helpstring("property Measure"),helpcontext(IDH_CogoModel_Measure)] HRESULT Measure([out, retval] IMeasure2* *pVal);

      /// Interface for locating points by projection
      [propget, helpstring("property Project"),helpcontext(IDH_CogoModel_Project)] HRESULT Project([out, retval] IProject2* *pVal);

      /// Interface for creating points by dividing distances, lines, and curves
      [propget, helpstring("property Divide"),helpcontext(IDH_CogoModel_Divide)] HRESULT Divide([out, retval] IDivide2* *pVal);

      /// Interface for locating points tangent to circles
      [propget, helpstring("property Tangent"),helpcontext(IDH_CogoModel_Tangent)] HRESULT Tangent([out, retval] ITangent2* *pVal);
   };

   /// Interface defining a coordinate geometry model.
   ///
   /// Points, LineSegments, Vertical Curves, Horizontal Curves, Alignments, and Paths are stored and identified by a unique identifier.
   [
       object,
       uuid(B9E4933C-5E73-11D5-8C32-006097C68A9C),
       oleautomation,
      helpcontext(IDH_CogoModel),
       helpstring("ICogoModel Interface"),
       pointer_default(unique)
   ]
   interface ICogoModel : IUnknown
   {
      [] HRESULT StorePoint(IDType id, Float64 x, Float64 y);
      [] HRESULT StorePointEx(IDType id, IPoint2d* pPoint);
      [] HRESULT StorePoints(IDType firstID, IDType idInc, IPoint2dCollection* pPoints);
      [] HRESULT GetPointCount(IndexType* nPoints);
      [] HRESULT GetPointByID(IDType id, IPoint2d** ppPoint);
      [] HRESULT GetPointByIndex(IndexType idx,IDType* pID, IPoint2d** ppPoint);
      [] HRESULT ReplacePointByID(IDType id, Float64 x, Float64 y);
      [] HRESULT ReplacePointByIDEx(IDType id, IPoint2d* pPoint);
      [] HRESULT ReplacePointByIndex(IndexType idx, Float64 x, Float64 y);
      [] HRESULT ReplacePointByIndexEx(IndexType idx, IPoint2d* pPoint);
      [] HRESULT RemovePointByID(IDType id);
      [] HRESULT RemovePointByIndex(IndexType index);
      [] HRESULT ClearPoints();

      [] HRESULT StorePathSegment(IDType id, IDType startID, IDType endID);
      [] HRESULT GetPathSegmentByID(IDType id, IDType* pStartID,IDType* pEndID);
      [] HRESULT GetPathSegmentByIndex(IndexType idx, IDType* pID, IDType* pStartID, IDType* pEndID);
      [] HRESULT CreatePathSegmentByID(IDType id, IPathSegment** ppSegment);
      [] HRESULT CreatePathSegmentByIndex(IndexType idx, IPathSegment** ppSegment);
      [] HRESULT RemovePathSegmentByID(IDType id);
      [] HRESULT RemovePathSegmentByIndex(IndexType index);
      [] HRESULT ClearPathSegments();

      [] HRESULT StoreCompoundCurve(IDType id, IDType pbtID,IDType piID,IDType pftID,Float64 radius,Float64 lsEntry, TransitionCurveType lsEntryType,Float64 lsExit, TransitionCurveType lsExitType);
      [] HRESULT GetCompoundCurveCountByID(IDType id, IndexType* nCurves);
      [] HRESULT GetCompoundCurveCountByIndex(IndexType index, IDType* pID, IndexType* nCurves);
      [] HRESULT GetCompoundCurveByID(IDType id, IDType* pbtID,IDType* piID, IDType* pftID,Float64* pRadius,Float64* pLsEntry,TransitionCurveType* pLsEntryType,Float64* pLsExit,TransitionCurveType* pLsExitType);
      [] HRESULT GetCompoundCurveByIndex(IndexType idx, IDType* pbtID, IDType* piID, IDType* pftID, Float64* pRadius, Float64* pLsEntry, TransitionCurveType* pLsEntryType, Float64* pLsExit, TransitionCurveType* pLsExitType);
      [] HRESULT CreateCompoundCurveByID(IDType id, ICompoundCurve** ppCurve);
      [] HRESULT CreateCompoundCurveByIndex(IndexType idx, ICompoundCurve** ppCurve);
      [] HRESULT RemoveCompoundCurveByID(IDType id);
      [] HRESULT RemoveCompoundCurveByIndex(IndexType index);
      [] HRESULT ClearCompoundCurves();

      [] HRESULT StoreCircularCurve(IDType id, IDType pbtID, IDType piID, IDType pftID, Float64 radius);
      [] HRESULT GetCircularCurveByID(IDType id, IDType* pbtID, IDType* piID, IDType* pftID, Float64* pRadius);
      [] HRESULT GetCircularCurveByIndex(IndexType idx, IDType* pID, IDType* pbtID, IDType* piID, IDType* pftID, Float64* pRadius);
      [] HRESULT CreateCircularCurveByID(IDType id, ICircularCurve** ppCurve);
      [] HRESULT CreateCircularCurveByIndex(IndexType idx, ICircularCurve** ppCurve);
      [] HRESULT RemoveCircularCurveByID(IDType id);
      [] HRESULT RemoveCircularCurveByIndex(IndexType index);
      [] HRESULT ClearCircularCurves();

      [] HRESULT StoreTransitionCurve(IDType id, IDType startID, VARIANT varDirection, Float64 r1, Float64 r2, Float64 L, TransitionCurveType transitionType);
      [] HRESULT GetTransitionCurveByID(IDType id, IDType* startID, IDirection** ppDirection, Float64* r1, Float64* r2, Float64* L, TransitionCurveType* transitionType);
      [] HRESULT GetTransitionCurveByIndex(IndexType index, IDType* pID, IDType* startID, IDirection** ppDirection, Float64* r1, Float64* r2, Float64* L, TransitionCurveType* transitionType);
      [] HRESULT CreateTransitionCurveByID(IDType id, ITransitionCurve** ppCurve);
      [] HRESULT CreateTransitionCurveByIndex(IndexType index, ITransitionCurve** ppCurve);
      [] HRESULT RemoveTransitionCurveByID(IDType id);
      [] HRESULT RemoveTransitionCurveByIndex(IndexType index);
      [] HRESULT ClearTransitionCurvese();

      [] HRESULT StoreCubicSpline(IDType id, IIDArray* pIDs);
      [] HRESULT GetCubicSplineByID(IDType id, IIDArray** ppIDs);
      [] HRESULT GetCubicSplineByIndex(IndexType index, IDType* pID, IIDArray** ppIDs);
      [] HRESULT CreateCubicSplineByID(IDType id, ICubicSpline** ppCurve);
      [] HRESULT CreateCubicSplineByIndex(IndexType index, ICubicSpline** ppCurve);
      [] HRESULT RemoveCubicSplineByID(IDType id);
      [] HRESULT RemoveCubicSplineByIndex(IndexType index);
      [] HRESULT ClearCubicSplines();

      [] HRESULT StoreAlignment(IDType id);
      [] HRESULT GetAlignmentCount(IndexType* nAlignments);
      [] HRESULT AddPathElementToAlignmentByID(IDType alignemntID, PathElementType elementType, IDType elementID);
      [] HRESULT AddPathElementToAlignmentByIndex(IndexType alignemntIndex, PathElementType elementType, IDType elementID);
      [] HRESULT GetAlignmentPathElementCountByID(IDType alignmentID, IndexType* nElements);
      [] HRESULT GetAlignmentPathElementCountByIndex(IndexType alignentIndex, IndexType* nElements);
      [] HRESULT GetAlignmentPathElementByID(IDType alignmentID, IndexType elementIndex, PathElementType* pType, IDType* pElementID);
      [] HRESULT GetAlignmentPathElementByIndex(IndexType alignmentIndex, IndexType elementIndex, IDType* pID, PathElementType* pType, IDType* pElementID);
      [] HRESULT GetAlignmentID(IndexType alignmentIdx, IDType* pID);
      [] HRESULT CreateAlignmentByID(IDType id, IAlignment** ppAlignment);
      [] HRESULT CreateAlignmentByIndex(IndexType index, IAlignment** ppAlignment);
      [] HRESULT RemoveAlignmentByID(IDType id);
      [] HRESULT RemoveAlignmentByIndex(IndexType index);
      [] HRESULT ClearAlignments();

      [] HRESULT SetAlignmentReferenceStation(IDType aligmentID, VARIANT varStation);
      [] HRESULT RemoveAlignmentReferenceStation(IDType aligmentID);
      [] HRESULT GetAlignmentReferenceStation(IDType aligmentID, IStation** ppStation);

      [] HRESULT AddStationEquation(IDType alignmentID, Float64 back, Float64 ahead);
      [] HRESULT GetStationEquationCount(IDType alignmentID, IndexType* nEquations);
      [] HRESULT GetStationEquation(IDType alignmentID, IndexType equationIndex, Float64* pBack, Float64* pAhead);
      [] HRESULT ClearStationEquations();

      [] HRESULT StorePath(IDType id);
      [] HRESULT GetPathCount(IndexType* nPaths);
      [] HRESULT AddPathElementToPathByID(IDType pathID, PathElementType elementType, IDType elementID);
      [] HRESULT AddPathElementToPathByIndex(IndexType pathIndex, PathElementType elementType, IDType elementID);
      [] HRESULT GetPathElementCountByID(IDType id, IndexType* nElements);
      [] HRESULT GetPathElementCountByIndex(IndexType index, IndexType* nElements);
      [] HRESULT GetPathElementByID(IDType pathID, IndexType elementIndex, PathElementType* pType, IDType* pElementID);
      [] HRESULT GetPathElementByIndex(IndexType pathIndex, IndexType elementIndex, IDType* pID, PathElementType* pType, IDType* pElementID);
      [] HRESULT GetPathID(IndexType idx, IDType* pPathID);
      [] HRESULT CreatePathByID(IDType id, IPath** ppPath);
      [] HRESULT CreatePathByIndex(IndexType index, IPath** ppPath);
      [] HRESULT RemovePathByID(IDType id);
      [] HRESULT RemovePathByIndex(IndexType index);
      [] HRESULT ClearPaths();

      [] HRESULT StoreProfilePoint(IDType id, VARIANT varStation, Float64 elevation);
      [] HRESULT StoreProfilePointEx(IDType id, IProfilePoint* pPoint);
      [] HRESULT GetProfilePointCount(IndexType* nPoints);
      [] HRESULT GetProfilePointByID(IDType id, IProfilePoint** ppPoint);
      [] HRESULT GetProfilePointByIndex(IndexType index, IDType* pID,IProfilePoint** ppPoint);
      [] HRESULT RemoveProfilePointByID(IDType id);
      [] HRESULT RemoveProfilePointByIndex(IndexType index);
      [] HRESULT ClearProfilePoints();

      [] HRESULT StoreProfileSegment(IDType id, IDType startID, IDType endID);
      [] HRESULT GetProfileSegmentCount(IndexType* nSegments);
      [] HRESULT GetProfileSegmentByID(IDType id, IDType* pStartID, IDType* pEndID);
      [] HRESULT GetProfileSegmentByIndex(IndexType index, IDType* pID, IDType* pStartID, IDType* pEndID);
      [] HRESULT CreateProfileSegmentByID(IDType id, IProfileSegment** ppSegment);
      [] HRESULT CreateProfileSegmentByIndex(IndexType index, IProfileSegment** ppSegment);
      [] HRESULT RemoveProfileSegmentByID(IDType id);
      [] HRESULT RemoveProfileSegmentByIndex(IndexType index);
      [] HRESULT ClearProfileSegments();

      [] HRESULT StoreVerticalCurve(IDType id, IDType pbg, IDType pvi, IDType pfg, Float64 l1_or_g1, Float64 l2_or_g2);
      [] HRESULT GetVerticalCurveCount(IndexType* nCurves);
      [] HRESULT GetVerticalCurveByID(IDType id, IDType* pbg, IDType *pvi, IDType *pfg, Float64 *l1_or_g1, Float64 *l2_or_g2);
      [] HRESULT GetVerticalCurveByIndex(IndexType index, IDType* pID, IDType* pbg, IDType* pvi, IDType* pfg, Float64* l1_or_g1, Float64* l2_or_g2);
      [] HRESULT CreateVerticalCurveByID(IDType id, IVerticalCurve** ppVertCurve);
      [] HRESULT CreateVerticalCurveByIndex(IndexType index, IVerticalCurve** ppVertCurve);
      [] HRESULT RemoveVerticalCurveByID(IDType id);
      [] HRESULT RemoveVerticalCurveByIndex(IndexType index);
      [] HRESULT ClearVerticalCurves();

      [] HRESULT StoreProfile(IDType id);
      [] HRESULT GetProfileCount(IndexType* nProfiles);
      [] HRESULT AddProfileElementByID(IDType profileID, ProfileElementType elementType, IDType elementID);
      [] HRESULT AddProfileElementByIndex(IndexType profileIndex, ProfileElementType elementType, IDType elementID);
      [] HRESULT GetProfileElementCountByID(IDType id, IndexType* nElements);
      [] HRESULT GetProfileElementCountByIndex(IndexType index, IndexType* nElements);
      [] HRESULT GetProfileElementByID(IDType profileID, IndexType elementIndex, ProfileElementType* pType, IDType* pElementID);
      [] HRESULT GetProfileElementByIndex(IndexType profileIndex, IndexType elementIndex, ProfileElementType* pType, IDType* pElementID);
      [] HRESULT CreateProfileByID(IDType profileID, IProfile** ppProfile);
      [] HRESULT CreateProfileByIndex(IndexType profileIndex, IProfile** ppProfile);
      [] HRESULT RemoveProfileByID(IDType id);
      [] HRESULT RemoveProfileByIndex(IndexType index);
      [] HRESULT ClearProfiles();

      [] HRESULT StoreSurface(IDType surfaceID,IndexType nSegments,IndexType alignmentPointIdx,IndexType profilePointIdx);
      [] HRESULT GetSurfaceCount(IndexType* nSurfaces);
      [] HRESULT AddSurfaceTemplate(IDType surfaceID, VARIANT varStation);
      [] HRESULT CopySurfaceTemplateByID(IDType surfaceID, IndexType templateIdx, VARIANT varStation);
      [] HRESULT CopySurfaceTemplateByIndex(IndexType surfaceIndex, IndexType templateIdx, VARIANT varStation);
      [] HRESULT MoveSurfaceTemplateByID(IDType surfaceID, IndexType templateIdx, VARIANT varNewStation);
      [] HRESULT MoveSurfaceTemplateByIndex(IndexType surfaceIndex, IndexType templateIdx, VARIANT varNewStation);
      [] HRESULT GetSurfaceTemplateCountByID(IDType surfaceID, IndexType* nSurfaceTemplates);
      [] HRESULT GetSurfaceTemplateCountByIndex(IndexType surfaceIndex,IDType* pID, IndexType* nSurfaceTemplates);
      [] HRESULT GetSurfaceTemplateLocationByID(IDType surfaceID, IndexType templateIdx,IStation** ppStation);
      [] HRESULT GetSurfaceTemplateLocationByIndex(IndexType surfaceIndex, IndexType templateIdx, IStation** ppStation);
      [] HRESULT UpdateSurfaceTemplateSegmentByID(IDType surfaceID, IndexType templateIndex, IndexType segmentIndex, Float64 width, Float64 slope, TemplateSlopeType slopeType);
      [] HRESULT UpdateSurfaceTemplateSegmentByIndex(IndexType surfaceIndex, IndexType templateIndex, IndexType segmentIndex, Float64 width, Float64 slope, TemplateSlopeType slopeType);
      [] HRESULT RemoveSurfaceByID(IDType surfaceID);
      [] HRESULT RemoveSurfaceByIndex(IndexType surfaceIndex);
      [] HRESULT StoreSuperelevationByID(IDType surfaceID,VARIANT varBeginTransitionStation,VARIANT varBeginFullSuperStation,VARIANT varEndFullSuperStation,VARIANT varEndTransitionStation,Float64 rate,IndexType pivotPointIdx,
         SuperTransitionType beginTransitionType, Float64 beginL1, Float64 beginL2, SuperTransitionType endTransitionType, Float64 endL1, Float64 endL2);
      [] HRESULT StoreSuperelevationByIndex(IndexType surfaceIndex, VARIANT varBeginTransitionStation, VARIANT varBeginFullSuperStation, VARIANT varEndFullSuperStation, VARIANT varEndTransitionStation, Float64 rate, IndexType pivotPointIdx,
         SuperTransitionType beginTransitionType, Float64 beginL1, Float64 beginL2, SuperTransitionType endTransitionType, Float64 endL1, Float64 endL2);
      [] HRESULT StoreWideningByID(IDType surfaceID, VARIANT varBeginTransitionStation, VARIANT varBeginFullWidening, VARIANT varEndFullWidening, VARIANT varEndTransitionStation, Float64 widening, IndexType segment1, IndexType segment2);
      [] HRESULT StoreWideningByIndex(IndexType surfaceIndex, VARIANT varBeginTransitionStation, VARIANT varBeginFullWidening, VARIANT varEndFullWidening, VARIANT varEndTransitionStation, Float64 widening, IndexType segment1, IndexType segment2);
      [] HRESULT CreateSurfaceByID(IDType surfaceID, ISurface** ppSurface);
      [] HRESULT CreateSurfaceByIndex(IndexType surfaceIndex, ISurface** ppSurface);

      [] HRESULT AttachProfileToAlignment(IDType profileID, IDType alignmentID);
      [] HRESULT AttachSurfaceToProfile(IDType surfaceID, IDType profileID);

      /// Clears the entire COGO model
      [helpstring("method Clear"),helpcontext(IDH_CogoModel_Clear)] HRESULT Clear();

      /// Interface for computing intersections
      [propget, helpstring("property Intersect"),helpcontext(IDH_CogoModel_Intersect)] HRESULT Intersect([out, retval] IIntersect* *pVal);

      /// Interface for locating points
      [propget, helpstring("property Locate"),helpcontext(IDH_CogoModel_Locate)] HRESULT Locate([out, retval] ILocate* *pVal);

      /// Interface for measuring angles, distances, and area
      [propget, helpstring("property Measure"),helpcontext(IDH_CogoModel_Measure)] HRESULT Measure([out, retval] IMeasure* *pVal);

      /// Interface for locating points by projection
      [propget, helpstring("property Project"),helpcontext(IDH_CogoModel_Project)] HRESULT Project([out, retval] IProject* *pVal);

      /// Interface for creating points by dividing distances, lines, and curves
      [propget, helpstring("property Divide"),helpcontext(IDH_CogoModel_Divide)] HRESULT Divide([out, retval] IDivide* *pVal);

      /// Interface for locating points tangent to circles
      [propget, helpstring("property Tangent"),helpcontext(IDH_CogoModel_Tangent)] HRESULT Tangent([out, retval] ITangent* *pVal);

      /// Provides access to the underlying CogoEngine object
      [propget, helpstring("property Engine")] HRESULT Engine([out, retval]ICogoEngine** engine);
   };


   [
      object,
      uuid(04086070-2A58-4557-A320-649C615652FA),
      oleautomation,
      nonextensible,
      helpstring("IPierLine Interface"),
      pointer_default(unique)
   ]
   interface IPierLine : IUnknown
   {
      [propget, helpstring("property AlignmentID")] HRESULT AlignmentID([out, retval] IDType* ID);
      [propget, helpstring("property Station")] HRESULT Station([out, retval] IStation** pVal);
      [propget, helpstring("property Direction")] HRESULT Direction([out, retval] IDirection** pVal);
      [propget, helpstring("property Normal")] HRESULT Normal([out, retval] IDirection** pVal);
      [propget, helpstring("property Skew")] HRESULT Skew([out, retval] IAngle** pVal);
      [propget, helpstring("property ID")] HRESULT ID([out, retval] IDType* pVal);
      [propget, helpstring("property Index")] HRESULT Index([out, retval]IndexType* pVal);

      [propget, helpstring("property BearingOffset")] HRESULT BearingOffset([in]PierFaceType pierFace, [out, retval] Float64* brgOffset);
      [propput, helpstring("property BearingOffset")] HRESULT BearingOffset([in]PierFaceType pierFace, [in] Float64 brgOffset);
      [propget, helpstring("property BearingOffsetMeasurementType")] HRESULT BearingOffsetMeasurementType([in]PierFaceType pierFace, [out, retval] MeasurementType* measure);
      [propput, helpstring("property BearingOffsetMeasurementType")] HRESULT BearingOffsetMeasurementType([in]PierFaceType pierFace, [in] MeasurementType measure);
      [propget, helpstring("property EndDistance")] HRESULT EndDistance([in]PierFaceType pierFace, [out, retval] Float64* endDist);
      [propput, helpstring("property EndDistance")] HRESULT EndDistance([in]PierFaceType pierFace, [in] Float64 endDist);
      [propget, helpstring("property EndDistanceMeasurementType")] HRESULT EndDistanceMeasurementType([in]PierFaceType pierFace, [out, retval] MeasurementType* measure);
      [propput, helpstring("property EndDistanceMeasurementType")] HRESULT EndDistanceMeasurementType([in]PierFaceType pierFace, [in] MeasurementType measure);
      [propget, helpstring("property EndDistanceMeasurementLocation")] HRESULT EndDistanceMeasurementLocation([in]PierFaceType pierFace, [out, retval] MeasurementLocation* measure);
      [propput, helpstring("property EndDistanceMeasurementLocation")] HRESULT EndDistanceMeasurementLocation([in]PierFaceType pierFace, [in] MeasurementLocation measure);

      [propget, helpstring("property AlignmentPoint")] HRESULT AlignmentPoint([out, retval] IPoint2d** ppPoint);
      [propget, helpstring("property BridgePoint")] HRESULT BridgePoint([out, retval] IPoint2d** ppPoint);
      [propget, helpstring("property LeftPoint")] HRESULT LeftPoint([out, retval] IPoint2d** ppPoint);
      [propget, helpstring("property RightPoint")] HRESULT RightPoint([out, retval] IPoint2d** ppPoint);
      [propget, helpstring("property Centerline")] HRESULT Centerline([out, retval]ILine2d** ppLine);

      [helpstring("method GetBearingOffset")] HRESULT GetBearingOffset([in]PierFaceType pierFace, [in]IDirection* direction, [out, retval] Float64* brgOffset);
   };

   [
      object,
      uuid(EDD54A64-4F63-4DC0-B605-DAA4C63BDA64),
      helpstring("IGirderLine Interface"),
      pointer_default(unique)
   ]
   interface IGirderLine : IUnknown
   {
      [propget, helpstring("property ID")] HRESULT ID([out, retval] IDType* pVal);
      [propget, helpstring("property StartPier")] HRESULT StartPier([out, retval] IPierLine** pVal);
      [propget, helpstring("property EndPier")] HRESULT EndPier([out, retval] IPierLine** pVal);
      [propget, helpstring("property GirderLength")] HRESULT GirderLength([out, retval]Float64* pLength);
      [propget, helpstring("property SpanLength")] HRESULT SpanLength([out, retval]Float64* pLength);
      [propget, helpstring("property LayoutLength")] HRESULT LayoutLength([out, retval]Float64* pLength);
      [propget, helpstring("property PierPoint")] HRESULT PierPoint([in]EndType endType, [out, retval]IPoint2d** ppPoint);
      [propget, helpstring("property BearingPoint")] HRESULT BearingPoint([in]EndType endType, [out, retval]IPoint2d** ppPoint);
      [propget, helpstring("property EndPoint")] HRESULT EndPoint([in]EndType endType, [out, retval]IPoint2d** ppPoint);
      [helpstring("method GetEndPoints")] HRESULT GetEndPoints([out]IPoint2d** pntPier1, [out]IPoint2d** pntEnd1, [out]IPoint2d** pntBrg1, [out]IPoint2d** pntBrg2, [out]IPoint2d** pntEnd2, [out]IPoint2d** pntPier2);
      [propget, helpstring("property Path")] HRESULT Path([out, retval]IPath** pVal);
      [propget, helpstring("property Direction")] HRESULT Direction([out, retval]IDirection** ppDirection);
      [propget, helpstring("property BearingOffset")] HRESULT BearingOffset([in]EndType endType, [out, retval]Float64* pBrgOffset);
      [propget, helpstring("property EndDistance")] HRESULT EndDistance([in]EndType endType, [out, retval]Float64* pEndDist);
   };

   [
      object,
      uuid(24885559-FABB-4327-B30D-B2EE5C95C5C1),
      helpstring("IDiaphragmLine Interface"),
      pointer_default(unique)
   ]
   interface IDiaphragmLine : IUnknown
   {
      [propget, helpstring("property ID")] HRESULT ID([out, retval]IDType* pVal);
      [propget, helpstring("property Length")] HRESULT Length([in]IDType gdrLineID, [out, retval]Float64* pLength);
      [propget, helpstring("property Point")] HRESULT Point([in]IDType gdrLineID, [in]EndType endType, [out, retval]IPoint2d** ppPoint);
   };

   [
      object,
      uuid(8FC6DE2C-969D-4F74-BD77-9355C1C4BEB6),
      helpstring("IDeckBoundary Interface"),
      pointer_default(unique)
   ]
   interface IDeckBoundary : IUnknown
   {
      // Returns a collection of points that represents the perimeter of the deck. The perimeter will be approximated with
      // nMinPointsPerSide. Control points for the elements that make up the edge paths will be included in the perimeter
      [propget, helpstring("property Perimeter")] HRESULT Perimeter([in] IndexType nMinPointsPerSide, [out, retval] IPoint2dCollection** points);

      // Returns a collection of points that represents the perimeter of the deck between two piers. The perimeter will be approximated with
      // nMinPointsPerSide. Control points for the elements that make up the edge paths will be included in the perimeter
      [propget, helpstring("property PerimeterEx")] HRESULT PerimeterEx([in] IndexType nMinPointsPerSide, [in] IDType startPierID, [in]Float64 Xstart, [in] IDType endPierID, [in]Float64 Xend, [in]VARIANT_BOOL bParallelToPiers, [out, retval] IPoint2dCollection** points);

      // Returns the transverse deck edge points
      [propget, helpstring("property TransverseEdgePoints")] HRESULT TransverseEdgePoints([in] EndType endType, [out]IPoint2d** ppLeft, [out]IPoint2d** ppLeftBreak, [out]IPoint2d** ppRightBreak, [out]IPoint2d** ppRight);

      // Returns a deck edge path. If vbLayoutPath is VARIANT_TRUE, the path used to layout the deck is returned (this is basically a construction line)
      // otherwise the actual edge path is returned.
      [propget, helpstring("property EdgePath")] HRESULT EdgePath([in]SideType side, [in]VARIANT_BOOL vbLayoutPath, [out, retval]IPath** path);
   };

   [
      object,
      uuid(892B79C7-8CAA-4E0A-A4F4-1B6868F8D369),
      oleautomation,
      pointer_default(unique)
   ]
   interface IPierLineFactory : IUnknown
   {
   };

   [
      object,
      uuid(E0F10472-2F28-47EC-BC17-813353709C5D),
      oleautomation,
      pointer_default(unique)
   ]
   interface ISinglePierLineFactory : IPierLineFactory
   {
      [propput] HRESULT PierLineID([in]IDType id);
      [propget] HRESULT PierLineID([out, retval]IDType* pID);

      [propput] HRESULT AlignmentID([in]IDType id);
      [propget] HRESULT AlignmentID([out,retval]IDType* pID);

      [propput] HRESULT Station([in]VARIANT varStation);
      [propget] HRESULT Station([out, retval]IStation** ppStation);

      [propput] HRESULT Direction([in]BSTR direction);
      [propget] HRESULT Direction([out, retval]BSTR* direction);

      [propput] HRESULT Length([in]Float64 length);
      [propget] HRESULT Length([out, retval]Float64* pLength);

      [propput] HRESULT Offset([in]Float64 offset);
      [propget] HRESULT Offset([out, retval]Float64* pOffset);

      [propput] HRESULT BearingOffset([in]PierFaceType pierFace, [in]Float64 brgOffset);
      [propget] HRESULT BearingOffset([in]PierFaceType pierFace, [out, retval]Float64* pBrgOffset);

      [propput] HRESULT BearingOffsetMeasurementType([in]PierFaceType pierFace, [in]MeasurementType measure);
      [propget] HRESULT BearingOffsetMeasurementType([in]PierFaceType pierFace, [out, retval]MeasurementType* pMeasure);

      [propput] HRESULT EndDistance([in]PierFaceType pierFace, [in]Float64 endDist);
      [propget] HRESULT EndDistance([in]PierFaceType pierFace, [out, retval]Float64* pEndDist);

      [propput] HRESULT EndDistanceMeasurementType([in]PierFaceType pierFace, [in]MeasurementType measure);
      [propget] HRESULT EndDistanceMeasurementType([in]PierFaceType pierFace, [out, retval]MeasurementType* pMeasure);

      [propput] HRESULT EndDistanceMeasurementLocation([in]PierFaceType pierFace, [in]MeasurementLocation measure);
      [propget] HRESULT EndDistanceMeasurementLocation([in]PierFaceType pierFace, [out, retval]MeasurementLocation* pMeasure);
   };

   [
      object,
      uuid(A9A91ECA-A914-434B-AD13-21A5EC634B0C),
      oleautomation,
      pointer_default(unique)
   ]
   interface ILayoutLineFactory : IUnknown
   {
   };

   [
      object,
      uuid(368661E7-290B-4FA1-9C55-8C88934EC61E),
      oleautomation,
      pointer_default(unique)
   ]
   interface IAlignmentOffsetLayoutLineFactory : ILayoutLineFactory
   {
      [propput] HRESULT AlignmentID([in]IDType id);
      [propget] HRESULT AlignmentID([out, retval]IDType* pID);

      [propput] HRESULT LayoutLineID([in]IDType id);
      [propget] HRESULT LayoutLineID([out, retval]IDType* pID);

      [propput] HRESULT LayoutLineIDIncrement([in]IDType idInc);
      [propget] HRESULT LayoutLineIDIncrement([out, retval]IDType* pIDInc);

      [propput] HRESULT LayoutLineCount([in]IndexType nLayoutLines);
      [propget] HRESULT LayoutLineCount([out, retval]IndexType* pnLayoutLines);

      [propput] HRESULT Offset([in]Float64 offset);
      [propget] HRESULT Offset([out, retval]Float64* pOffset);

      [propput] HRESULT OffsetIncrement([in]Float64 offsetInc);
      [propget] HRESULT OffsetIncrement([out, retval]Float64* pOffsetInc);
   };


   [
      object,
      uuid(64CC0388-9A1C-41D3-8324-D3EA44DC6CFF),
      helpstring("ISimpleLayoutLineFactory Interface"),
      pointer_default(unique)
   ]
   interface ISimpleLayoutLineFactory : ILayoutLineFactory
   {
      [helpstring("method AddPath")] HRESULT AddPath([in]IDType ID, [in]IPath* path);
   };

   [
      object,
      uuid(B34A9D24-9551-490A-A3C2-3C7CF6803D4C),
      helpstring("IUniformSpacingLayoutLineFactory Interface"),
      pointer_default(unique)
   ]
   interface IUniformSpacingLayoutLineFactory : ILayoutLineFactory
   {
      [propget, helpstring("AlignmentID")] HRESULT AlignmentID([out, retval]IDType* ID);
      [propput, helpstring("AlignmentID")] HRESULT AlignmentID([in]IDType ID);
      [propget, helpstring("property StartPierID")] HRESULT StartPierID([out, retval] IDType* pVal);
      [propput, helpstring("property StartPierID")] HRESULT StartPierID([in] IDType newVal);
      [propget, helpstring("property EndPierID")] HRESULT EndPierID([out, retval] IDType* pVal);
      [propput, helpstring("property EndPierID")] HRESULT EndPierID([in] IDType newVal);
      [propget, helpstring("property PierIDInc")] HRESULT PierIDInc([out, retval] IDType* pVal);
      [propput, helpstring("property PierIDInc")] HRESULT PierIDInc([in] IDType newVal);
      [propget, helpstring("property StartSpacingOffset")] HRESULT StartSpacingOffset([out, retval] Float64* pVal);
      [propput, helpstring("property StartSpacingOffset")] HRESULT StartSpacingOffset([in] Float64 newVal);
      [propget, helpstring("property EndSpacingOffset")] HRESULT EndSpacingOffset([out, retval] Float64* pVal);
      [propput, helpstring("property EndSpacingOffset")] HRESULT EndSpacingOffset([in] Float64 newVal);
      [propget, helpstring("property StartSpacing")] HRESULT StartSpacing([out, retval] IDblArray** pVal);
      [propput, helpstring("property StartSpacing")] HRESULT StartSpacing([in] IDblArray* newVal);
      [propget, helpstring("property EndSpacing")] HRESULT EndSpacing([out, retval] IDblArray** pVal);
      [propput, helpstring("property EndSpacing")] HRESULT EndSpacing([in] IDblArray* newVal);
      [propput, helpstring("property LayoutLineID")] HRESULT LayoutLineID([in]IDType ID);
      [propget, helpstring("property LayoutLineID")] HRESULT LayoutLineID([out, retval]IDType* ID);
      [propput, helpstring("property LayoutLineIDInc")] HRESULT LayoutLineIDInc([in]IDType inc);
      [propget, helpstring("property LayoutLineIDInc")] HRESULT LayoutLineIDInc([out, retval]IDType* inc);
   };


   [
      object,
      uuid(F7A4B484-4C6B-4A36-B62C-FC216F09F033),
      helpstring("IGirderLineFactory"),
      pointer_default(unique)
   ]
   interface IGirderLineFactory : IUnknown
   {
   };

   [
      object,
      uuid(9BE02875-99F1-4529-B7F7-1235DF2FC010),
      helpstring("ISingleGirderLineFactory Interface"),
      pointer_default(unique)
   ]
   interface ISingleGirderLineFactory : IGirderLineFactory
   {
      [propget, helpstring("property GirderLineID")] HRESULT GirderLineID([out, retval] IDType* pVal);
      [propput, helpstring("property GirderLineID")] HRESULT GirderLineID([in] IDType newVal);
      [propget, helpstring("property LayoutLineID")] HRESULT LayoutLineID([out, retval] IDType* pVal);
      [propput, helpstring("property LayoutLineID")] HRESULT LayoutLineID([in] IDType newVal);
      [propget, helpstring("property Type")] HRESULT Type([out, retval] GirderLineType* pVal);
      [propput, helpstring("property Type")] HRESULT Type([in] GirderLineType newVal);
      [propget, helpstring("property StartPierID")] HRESULT StartPierID([out, retval] IDType* pVal);
      [propput, helpstring("property StartPierID")] HRESULT StartPierID([in] IDType newVal);
      [propget, helpstring("property EndPierID")] HRESULT EndPierID([out, retval] IDType* pVal);
      [propput, helpstring("property EndPierID")] HRESULT EndPierID([in] IDType newVal);
      [propget, helpstring("property StartMeasurementType")] HRESULT StartMeasurementType([out, retval]MeasurementType* pVal);
      [propput, helpstring("property StartMeasurementType")] HRESULT StartMeasurementType([in]MeasurementType newVal);
      [propget, helpstring("property StartMeasurementLocation")] HRESULT StartMeasurementLocation([out, retval]MeasurementLocation* pVal);
      [propput, helpstring("property StartMeasurementLocation")] HRESULT StartMeasurementLocation([in]MeasurementLocation newVal);
      [propget, helpstring("property EndMeasurementType")] HRESULT EndMeasurementType([out, retval]MeasurementType* pVal);
      [propput, helpstring("property EndMeasurementType")] HRESULT EndMeasurementType([in]MeasurementType newVal);
      [propget, helpstring("property EndMeasurementLocation")] HRESULT EndMeasurementLocation([out, retval]MeasurementLocation* pVal);
      [propput, helpstring("property EndMeasurementLocation")] HRESULT EndMeasurementLocation([in]MeasurementLocation newVal);
   };

   [
      object,
      uuid(4DCF9E5C-3035-4150-882E-7084796B93B5),
      helpstring("ISimpleGirderLineFactory Interface"),
      pointer_default(unique)
   ]
   interface ISimpleGirderLineFactory : IGirderLineFactory
   {
      [propget, helpstring("property GirderLineID")] HRESULT GirderLineID([out, retval] IDType* pVal);
      [propput, helpstring("property GirderLineID")] HRESULT GirderLineID([in] IDType newVal);
      [propget, helpstring("property GirderLineIDInc")] HRESULT GirderLineIDInc([out, retval] IDType* pVal);
      [propput, helpstring("property GirderLineIDInc")] HRESULT GirderLineIDInc([in] IDType newVal);
      [propget, helpstring("property LeftLayoutLineID")] HRESULT LeftLayoutLineID([out, retval] IDType* pVal);
      [propput, helpstring("property LeftLayoutLineID")] HRESULT LeftLayoutLineID([in] IDType newVal);
      [propget, helpstring("property RightLayoutLineID")] HRESULT RightLayoutLineID([out, retval] IDType* pVal);
      [propput, helpstring("property RightLayoutLineID")] HRESULT RightLayoutLineID([in] IDType newVal);
      [propget, helpstring("property LayoutLineIDInc")] HRESULT LayoutLineIDInc([out, retval] IDType* pVal);
      [propput, helpstring("property LayoutLineIDInc")] HRESULT LayoutLineIDInc([in] IDType newVal);
      [propget, helpstring("property Type")] HRESULT Type([out, retval] GirderLineType* pVal);
      [propput, helpstring("property Type")] HRESULT Type([in] GirderLineType newVal);

      // PierID where a GirderLines starts
      [propget, helpstring("property StartPierID")] HRESULT StartPierID([out, retval] IDType* pVal);
      [propput, helpstring("property StartPierID")] HRESULT StartPierID([in] IDType newVal);

      // PierID where the GirderLines end
      [propget, helpstring("property EndPierID")] HRESULT EndPierID([out, retval] IDType* pVal);
      [propput, helpstring("property EndPierID")] HRESULT EndPierID([in] IDType newVal);

      // PierID increment. Non-continuous girder lines go from StartPierID to StartPierID+PierIDInc
      // until the end pier is reached
      [propget, helpstring("property PierIDInc")] HRESULT PierIDInc([out, retval] IDType* pVal);
      [propput, helpstring("property PierIDInc")] HRESULT PierIDInc([in] IDType newVal);

      // Continuous = GirderLine is continuous from StartPier to EndPier (PierIDInc is ignored)
      [propget, helpstring("property Continuous")] HRESULT Continuous([out, retval] VARIANT_BOOL* pbContinuous);
      [propput, helpstring("property Continuous")] HRESULT Continuous([in] VARIANT_BOOL bContinuous);

      [propget, helpstring("property StartMeasurementType")] HRESULT StartMeasurementType([out, retval]MeasurementType* pVal);
      [propput, helpstring("property StartMeasurementType")] HRESULT StartMeasurementType([in]MeasurementType newVal);
      [propget, helpstring("property StartMeasurementLocation")] HRESULT StartMeasurementLocation([out, retval]MeasurementLocation* pVal);
      [propput, helpstring("property StartMeasurementLocation")] HRESULT StartMeasurementLocation([in]MeasurementLocation newVal);

      [propget, helpstring("property EndMeasurementType")] HRESULT EndMeasurementType([out, retval]MeasurementType* pVal);
      [propput, helpstring("property EndMeasurementType")] HRESULT EndMeasurementType([in]MeasurementType newVal);
      [propget, helpstring("property EndMeasurementLocation")] HRESULT EndMeasurementLocation([out, retval]MeasurementLocation* pVal);
      [propput, helpstring("property EndMeasurementLocation")] HRESULT EndMeasurementLocation([in]MeasurementLocation newVal);
   };


   [
      object,
      uuid(B3979762-E72A-401B-AC03-28E953A222C2),
      helpstring("IDiaphragmLineFactory"),
      pointer_default(unique)
   ]
   interface IDiaphragmLineFactory : IUnknown
   {
   };

   [
      object,
      uuid(56FB1927-B2C5-46AB-ABCC-DF68C619160C),
      helpstring("ISingleDiaphragmLineFactory"),
      pointer_default(unique)
   ]
   interface ISingleDiaphragmLineFactory : IDiaphragmLineFactory
   {
      [propput, helpstring("property AlignmentID")] HRESULT AlignmentID([in] IDType ID);
      [propget, helpstring("property AlignmentID")] HRESULT AlignmentID([out, retval] IDType* ID);
      [propput, helpstring("property Station")] HRESULT Station([in]VARIANT varStation);
      [propget, helpstring("property Station")] HRESULT Station([out, retval]IStation** ppStation);
      [propput, helpstring("property Orientation")] HRESULT Orientation([in] BSTR orientation);
      [propget, helpstring("property Orientation")] HRESULT Orientation([out, retval] BSTR* orientation);
      [propget, helpstring("property DiaphragmLineID")] HRESULT DiaphragmLineID([out, retval] IDType* pVal);
      [propput, helpstring("property DiaphragmLineID")] HRESULT DiaphragmLineID([in] IDType newVal);
      [propput, helpstring("property Staggered")] HRESULT Staggered([in] VARIANT_BOOL bStaggered);
      [propget, helpstring("property Staggered")] HRESULT Staggered([out, retval] VARIANT_BOOL* bStaggered);
      [propput, helpstring("property LeftGirderLineID")] HRESULT LeftGirderLineID([in] IDType ID);
      [propget, helpstring("property LeftGirderLineID")] HRESULT LeftGirderLineID([out, retval] IDType* ID);
      [propput, helpstring("property RightGirderLineID")] HRESULT RightGirderLineID([in] IDType ID);
      [propget, helpstring("property RightGirderLineID")] HRESULT RightGirderLineID([out, retval] IDType* ID);
   };

   [
      object,
      uuid(E479B523-613F-4383-B555-2E749CAFABE8),
      helpstring("IThroughPointDiaphragmLineFactory"),
      pointer_default(unique)
   ]
   interface IThroughPointDiaphragmLineFactory : IDiaphragmLineFactory
   {
      [propput, helpstring("property Point")] HRESULT Point([in] IPoint2d* point);
      [propget, helpstring("property Point")] HRESULT Point([out, retval] IPoint2d** point);
      [propput, helpstring("property Direction")] HRESULT Direction([in]VARIANT varDirection);
      [propget, helpstring("property Direction")] HRESULT Direction([out, retval]IDirection** direction);
      [propget, helpstring("property DiaphragmLineID")] HRESULT DiaphragmLineID([out, retval] IDType* pVal);
      [propput, helpstring("property DiaphragmLineID")] HRESULT DiaphragmLineID([in] IDType newVal);
      [propput, helpstring("property Staggered")] HRESULT Staggered([in] VARIANT_BOOL bStaggered);
      [propget, helpstring("property Staggered")] HRESULT Staggered([out, retval] VARIANT_BOOL* bStaggered);
      [propput, helpstring("property LeftGirderLineID")] HRESULT LeftGirderLineID([in] IDType ID);
      [propget, helpstring("property LeftGirderLineID")] HRESULT LeftGirderLineID([out, retval] IDType* ID);
      [propput, helpstring("property RightGirderLineID")] HRESULT RightGirderLineID([in] IDType ID);
      [propget, helpstring("property RightGirderLineID")] HRESULT RightGirderLineID([out, retval] IDType* ID);
   };

   [
      object,
      uuid(FD9086BA-9DEA-4AF0-BDF9-5E67E7E0A1D0),
      helpstring("IEqualSpacingDiaphragmLineFactory"),
      pointer_default(unique)
   ]
   interface IEqualSpacingDiaphragmLineFactory : IDiaphragmLineFactory
   {
      [propput, helpstring("property AlignmentID")] HRESULT AlignmentID([in] IDType ID);
      [propget, helpstring("property AlignmentID")] HRESULT AlignmentID([out, retval] IDType* ID);
      [] HRESULT SetStationRange([in]VARIANT varStartStation, [in]VARIANT varEndStation);
      [] HRESULT GetStationRange([out]IStation** ppStartStation, [out]IStation** ppEndStation);
      [propget, helpstring("property DiaphragmLineID")] HRESULT DiaphragmLineID([out, retval] IDType* pVal);
      [propput, helpstring("property DiaphragmLineID")] HRESULT DiaphragmLineID([in] IDType newVal);
      [propget, helpstring("property DiaphragmLineIDInc")] HRESULT DiaphragmLineIDInc([out, retval] IDType* pVal);
      [propput, helpstring("property DiaphragmLineIDInc")] HRESULT DiaphragmLineIDInc([in] IDType newVal);
      [propput, helpstring("property Divisor")] HRESULT Divisor([in] Uint16 divisor);
      [propget, helpstring("property Divisor")] HRESULT Divisor([out, retval] Uint16* divisor);
      [propput, helpstring("property Staggered")] HRESULT Staggered([in] VARIANT_BOOL bStaggered);
      [propget, helpstring("property Staggered")] HRESULT Staggered([out, retval] VARIANT_BOOL* bStaggered);
      [propput, helpstring("property LeftGirderLineID")] HRESULT LeftGirderLineID([in] IDType ID);
      [propget, helpstring("property LeftGirderLineID")] HRESULT LeftGirderLineID([out, retval] IDType* ID);
      [propput, helpstring("property RightGirderLineID")] HRESULT RightGirderLineID([in] IDType ID);
      [propget, helpstring("property RightGirderLineID")] HRESULT RightGirderLineID([out, retval] IDType* ID);
   };

   [
      object,
      uuid(F89D246A-8F7D-4A27-A27E-DD73BE332087),
      helpstring("IDeckBoundaryFactory Interface"),
      pointer_default(unique)
   ]
   interface IDeckBoundaryFactory : IUnknown
   {
   };

   [
      object,
      uuid(AA59EF93-7A3C-493A-BF37-B38B3644A653),
      helpstring("ISimpleDeckBoundaryFactory Interface"),
      pointer_default(unique)
   ]
   interface ISimpleDeckBoundaryFactory : IDeckBoundaryFactory
   {
      [propput, helpstring("property TransverseEdgeID")] HRESULT TransverseEdgeID([in]EndType end, [in] IDType ID);
      [propget, helpstring("property TransverseEdgeID")] HRESULT TransverseEdgeID([in]EndType end, [out, retval] IDType* ID);
      [propput, helpstring("property TransverseEdgeType")] HRESULT TransverseEdgeType([in]EndType end, [in] DeckBoundaryEdgeType edgeType);
      [propget, helpstring("property TransverseEdgeType")] HRESULT TransverseEdgeType([in]EndType end, [out, retval] DeckBoundaryEdgeType* edgeType);

      [propput, helpstring("property EdgeID")] HRESULT EdgeID([in]SideType side, [in] IDType ID);
      [propget, helpstring("property EdgeID")] HRESULT EdgeID([in]SideType side, [out, retval] IDType* ID);
      [propput, helpstring("property EdgeBreakID")] HRESULT EdgeBreakID([in]SideType side, [in] IDType ID);
      [propget, helpstring("property EdgeBreakID")] HRESULT EdgeBreakID([in]SideType side, [out, retval] IDType* ID);

      [propput, helpstring("property BreakEdge")] HRESULT BreakEdge([in] EndType end, [in]SideType side, [in] VARIANT_BOOL bBreak);
      [propget, helpstring("property BreakEdge")] HRESULT BreakEdge([in] EndType end, [in]SideType side, [out, retval] VARIANT_BOOL* bBreak);
   };

   [
      object,
      uuid(CF09FA44-1095-4F63-B3DB-C4BA8617A98E),
      oleautomation,
      nonextensible,
      helpstring("IBridgeGeometry Interface"),
      pointer_default(unique)
   ]
   interface IBridgeGeometry : IUnknown
   {
      [helpstring("property AddAlignment")] HRESULT AddAlignment([in]IDType ID, [in]IAlignment* pAligment);
      [helpstring("property Alignment")] HRESULT GetAlignment([in]IDType ID, [out, retval]IAlignment** pAlignment);
      [propput, helpstring("property BridgeAlignmentID")] HRESULT BridgeAlignmentID([in] IDType ID);
      [propget, helpstring("property BridgeAlignmentID")] HRESULT BridgeAlignmentID([out, retval] IDType* ID);
      [propget, helpstring("property BridgeAlignment")] HRESULT BridgeAlignment([out, retval] IAlignment** alignment);

      [propput, helpstring("property ProfileID")] HRESULT ProfileID([in] IDType profileID);
      [propget, helpstring("property ProfileID")] HRESULT ProfileID([out, retval] IDType* pProfileID);
      [propput, helpstring("property SurfaceID")] HRESULT SurfaceID([in] IDType surfaceID);
      [propget, helpstring("property SurfaceID")] HRESULT SurfaceID([out, retval] IDType* pSurfaceID);

      [propput, helpstring("property BridgeLineOffset")] HRESULT BridgeLineOffset([in]Float64 offset);
      [propget, helpstring("property BridgeLineOffset")] HRESULT BridgeLineOffset([out, retval]Float64* offset);
      [propget, helpstring("property BridgeLine")] HRESULT BridgeLine([out, retval]IPath** bridgeLine);

      [] HRESULT AddPierLineFactory(IPierLineFactory* pFactory);
      [helpstring("method GetPierLine")] HRESULT GetPierLine([in] IndexType idx, [out, retval]IPierLine** ppPier);
      [helpstring("method FindPierLine")] HRESULT FindPierLine([in] IDType ID, [out, retval]IPierLine** ppPier);
      [propget, helpstring("property PierLineCount")] HRESULT PierLineCount([out, retval]PierIndexType* pVal);
       
      [] HRESULT AddLayoutLineFactory(ILayoutLineFactory* pFactory);
      [helpstring("method GetLayoutLine")] HRESULT GetLayoutLine([in] IndexType idx, [out, retval]IPath** path);
      [helpstring("method FindLayoutLine")] HRESULT FindLayoutLine([in]IDType ID, [out, retval]IPath** path);
      [propget, helpstring("property LayoutLineCount")] HRESULT LayoutLineCount([out, retval]IndexType* pVal);

      [] HRESULT AddGirderLineFactory(IGirderLineFactory* pFactory);
      [helpstring("method GetGirderLine")] HRESULT GetGirderLine([in] IndexType idx, [out, retval]IGirderLine** ppGirderLine);
      [helpstring("method FindGirderLine")] HRESULT FindGirderLine([in]IDType ID, [out, retval]IGirderLine** ppGirderLine);
      [propget, helpstring("property GirderLineCount")] HRESULT GirderLineCount([out, retval]IndexType* pVal);

      [] HRESULT AddDiaphragmLineFactory(IDiaphragmLineFactory* pFactory);
      [helpstring("method GetDiaphragmLine")] HRESULT GetDiaphragmLine([in] IndexType idx, [out, retval]IDiaphragmLine** ppDiaphragmLine);
      [helpstring("method FindDiaphragmLine")] HRESULT FindDiaphragmLine([in] IDType ID, [out, retval]IDiaphragmLine** ppDiaphragmLine);
      [propget, helpstring("property DiaphragmLineCount")] HRESULT DiaphragmLineCount([out, retval]IndexType* pVal);

      [] HRESULT AddDeckBoundaryFactory(IDeckBoundaryFactory* pFactory);
      [propget, helpstring("property DeckBoundary")] HRESULT DeckBoundary([out, retval]IDeckBoundary** ppDeckBoundary);
   };


   /////////////////////////////////////////////////////////////

   /// An object that implements the IAngle interface
   [
        uuid(10F574FD-5735-11D3-898C-006097C68A9C),
      helpcontext(IDH_Angle),
        helpstring("Angle Class")
    ]
    coclass Angle
    {
        [default] interface IAngle;
    };

    /// An object that implements the IDirection interface
    [
        uuid(10F574FB-5735-11D3-898C-006097C68A9C),
      helpcontext(IDH_Direction),
        helpstring("Direction Class")
    ]
    coclass Direction
    {
        [default] interface IDirection;
    };

   /// A coordinate geometry model object.
   ///
   /// A CogoModel stores, creates, and manages coordinate geometry elements such as Points LineSegments, Paths, and Alignments
   ///
   /// Implements the ICogoModel interface.
   /// Also implements the IMeasure, ILocate, IIntersect, IProject, IDivide, and ITangent interfaces.
   [
       uuid(07E3C485-573F-11D3-8CDF-BAAC148B6002),
      helpcontext(IDH_CogoModel),
       helpstring("CogoModel Class")
   ]
   coclass CogoModel
   {
       [default] interface ICogoModel;
       interface IMeasure;
       interface ILocate;
       interface IIntersect;
     interface IProject;
     interface IDivide;
     interface ITangent;
   };

   /// A computation engine for performing coordinate geometry analysis
   ///
   /// Implements the ICogoEngine interface.
   /// Also implements the IMeasure2, ILocate2, IIntersect2, IProject2, IDivide2, and ITangent2 interfaces.
   [
      uuid(C7E7D393-7C90-4AF5-88DF-A761FA3BCE19),
      helpstring("CogoEngine Class")
   ]
   coclass CogoEngine
   {
      [default] interface ICogoEngine;
      interface IMeasure2;
      interface ILocate2;
      interface IIntersect2;
      interface IProject2;
      interface IDivide2;
      interface ITangent2;
   };

   /// A object defining a point on a vertical profile
   ///
   /// Implements the IProfilePoint interface
   [
       uuid(849FD333-4FC9-4093-93F6-FBEC311FF45A),
      helpcontext(IDH_ProfilePoint),
       helpstring("ProfilePoint Class")
   ]
   coclass ProfilePoint
   {
       [default] interface IProfilePoint;
   };

   /// A vertical curve object.
   ///
   /// Implements the IVerticalCurve interface
   [
       uuid(7581BC4E-4E7C-4761-B59E-2D75EA2E1120),
      helpcontext(IDH_VertCurve),
       helpstring("VertCurve Class")
   ]
   coclass VerticalCurve
   {
       [default] interface IVerticalCurve;
       interface IProfileElement;
   };

   /// A circular curve object.
   ///
   /// Implements the ICircularCurve interface
   [
       uuid(5A7E89C4-C238-4FE2-9300-0848F4F5AC42),
       //helpcontext(IDH_CompoundCurve),
       helpstring("CircularCurve Class")
   ]
   coclass CircularCurve
   {
       [default] interface ICircularCurve;
       interface IPathElement;
   };

   /// A compound curve object.
   ///
   /// Implements the ICompoundCurve interface
   [
       uuid(61454EB9-8040-4B74-9429-B09D1FF1E0BB),
      helpcontext(IDH_CompoundCurve),
       helpstring("CompoundCurve Class")
   ]
   coclass CompoundCurve
   {
       [default] interface ICompoundCurve;
       interface IPathElement;
   };

   /// Object defining a piecewise clamped cubic spline.
   ///
   /// A clamped cubic spline is a numerical approximation of a complex curve defined by a series of points on the curve and the tangent slopes at the start and end of the curve.
   /// \image html /CubicSpline/ClampedCubicSpline.png
   /// Implements the ICubicSpline interface
   [
       uuid(69706DA8-D10D-4932-A566-69DE35CAF30F),
      //helpcontext(IDH_CubicSpline),
       helpstring("CubicSpline Class")
   ]
   coclass CubicSpline
   {
       [default] interface ICubicSpline;
       interface IPathElement;
   };

   /// A Transition Curve object.
   ///
   /// Implements the ITransitionCurve interface
   [
      uuid(7B960DF1-3208-4DAF-94D8-066E4F991353),
      helpstring("TransitionCurve Class")
   ]
   coclass TransitionCurve
   {
      [default] interface ITransitionCurve;
      interface IPathElement;
   };

   /// An object that represents a linear element of a profile
   ///
   /// Implements the IProfileSegment interface
   [
      uuid(80AC919F-D882-4C24-9E6D-721D90925FEE),
      //helpcontext(IDH_ProfileElement),
      helpstring("ProfileSegment Class")
   ]
   coclass ProfileSegment
   {
      [default] interface IProfileSegment;
      interface IProfileElement;
   };

   /// An object that represents an alignment profile. A profile can be a roadway profile, profile of an underground utility, or other such items associated with an alignment.
   ///
   /// A Profile consists of ProfileElement objects, which are ProfilePoint and VertCurve objects. 
   /// ProfileElement objects are positioned end to end in the order they are defined. Straight lines are used to connect the ProfileElement objects together. 
   /// The tangents at the beginning and end of the profile are projected as straight lines.
   /// If a Profile does not contain any ProfileElement objects, it is assumed that the profile is at a constant elevation of 0.00.
   ///
   /// Implements the IProfile interface
   [
      uuid(7FD9C064-1A8C-4853-B1CC-24D9C877406F),
      helpcontext(IDH_Profile),
      helpstring("Profile Class")
   ]
   coclass Profile
   {
      [default] interface IProfile;
   };

   /// An object that represents a widening or narrowing in the roadway surface, such as adding a lane.
   ///
   /// A widening is applied as modifier to a Surface object.
   ///
   /// Implements the IWidening interface
   [
      uuid(3B817FBD-D099-49a2-8E43-E90F49A8B5B8),
      //helpcontext(IDH_Widening),
      helpstring("Widening Class")
   ]
   coclass Widening
   {
      [default] interface IWidening;
   };

   /// An object that represents a superelevation as would occur at a curve in the alignment.
   ///
   /// A superelevation is applied as modifier to a Surface object.
   ///
   /// Implements the ISuperelevation interface
   [
      uuid(9D3C25CB-61D1-466e-AE30-1FD5C460D50B),
      //helpcontext(IDH_Superelevation),
      helpstring("Superelevation Class")
   ]
   coclass Superelevation
   {
      [default] interface ISuperelevation;
   };

   /// An object the represents a segment in a SurfaceTemplate.
   ///
   /// Implements the ISurfaceTemplateSegment interface
   [
      uuid(B853F944-3791-4f03-AC3C-547C71B74743),
      //helpcontext(IDH_TemplateSegment),
      helpstring("SurfaceTemplateSegment Class")
   ]
   coclass SurfaceTemplateSegment
   {
      [default] interface ISurfaceTemplateSegment;
   };

   /// An object that represents a cross section template for a Surface. 
   ///
   /// A SurfaceTemplate differs from a SurfaceProfile in that it represents a cross section cut through a surface normal to the associated alignment.
   /// A SurfaceTemplate is defined by a sequence of TemplateSegment objects where a SurfaceProfile is defined by a sequence of SurfacePoint objects.
   ///
   /// Implements the ISurfaceTemplate interface
   [
      uuid(A479017E-BFE5-4e1e-B41D-E7BBF2534F52),
      //helpcontext(IDH_SurfaceTemplate),
      helpstring("SurfaceTemplate Class")
   ]
   coclass SurfaceTemplate
   {
      [default] interface ISurfaceTemplate;
   };

   /// An object that represents the surface, such as a roadway surface, associated with a Profile.
   ///
   /// A Surface is defined by collection of SurfaceTemplate objects and modified by Superelevation and Widening objects.
   ///
   /// Implements the ISurface interface
   [
      uuid(B8A4A5A2-A456-4161-9276-669D92B9FC5C),
      //helpcontext(IDH_Surface),
      helpstring("Surface Class")
   ]
   coclass Surface
   {
      [default] interface ISurface;
   };

   /// An object that represents a roadway, highway or other construction alignment.
   ///
   /// An alignment consists of PathElement objects, which are: Point2d objects, LineSegment2d objects, CubicSpline objects, and CompoundCurve objects. 
   /// PathElement objects are positioned end to end in the order they are defined. Straight lines are used to connect the PathElement objects together. 
   /// The tangents at the beginning and end of the path are projected as straight lines.
   /// If an Alignment does not contain any PathElement objects, it is assumed that it begins at Station 0+00, point N 0.00, E 0.00, and is a straight line bearing N 90 E.
   ///
   /// Implements the IAlignment interface
   [
      uuid(B46F91AB-53C2-4ECC-8E7F-55AFA0F67C2F),
      helpcontext(IDH_Alignment),
      helpstring("Alignment Class")
   ]
   coclass Alignment
   {
      [default] interface IAlignment;
   };

   /// An object that represents a linear segment of a path
   ///
   /// Implements the IPathSegment interface
   [
      uuid(B21FFF37-F9A2-4DA0-8226-C5C3604E8262),
      helpstring("PathSegment Class")
   ]
   coclass PathSegment
   {
      [default] interface IPathSegment;
   };

   /// An object that represents a geometric path in plan view. 
   ///
   /// A path consists of PathElement objects, which are: Point2d objects, LineSegment2d objects, CubicSpline objects, and CompoundCurve objects. 
   /// PathElement objects are positioned end to end in the order they are defined. Straight lines are used to connect the PathElement objects together. 
   /// The tangents at the beginning and end of the path are projected as straight lines.
   /// If a Path does not contain any PathElement objects, it is assumed that the path begins at N 0.00, E 0.00, and is a straight line bearing N 90 E.
   ///
   /// Implements the IPath interface
   [
      uuid(4A138368-CF5F-4a12-BC2D-224FC85E8B8D),
      helpcontext(IDH_Path),
      helpstring("Path Class")
   ]
   coclass Path
   {
      [default] interface IPath;
      interface IPathElement;
   };

   /// An object that converts angular measure values into formatted text strings.
   ///
   /// Implements the IAngleDisplayUnitFormatter interface.
   [
      uuid(0E8ADC7B-54A5-45FC-AA79-56BBE528FA47),
      helpcontext(IDH_AngleDisplayUnitFormatter),
      helpstring("AngleDisplayUnitFormatter Class")
   ]
   coclass AngleDisplayUnitFormatter
   {
      [default] interface IAngleDisplayUnitFormatter;
      [default, source] interface IDisplayUnitFormatterEvents;
   };

   /// An object that converts angular measure values representing a direction into formatted text strings.
   ///
   /// Implements the IDirectionDisplayUnitFormatter interface.
   [
      uuid(50A4E50C-B7A8-4177-AB25-83D4E783B7A3),
      helpcontext(IDH_DirectionDisplayUnitFormatter),
      helpstring("DirectionDisplayUnitFormatter Class")
   ]
   coclass DirectionDisplayUnitFormatter
   {
      [default] interface IDirectionDisplayUnitFormatter;
      [default, source] interface IDisplayUnitFormatterEvents;
   };

   /// An object the represents a station along an alignment.
   ///
   /// Implements the IStation interface
   [
      uuid(4C22AA8F-6739-49DD-B6DF-FDCD352FF969),
      helpstring("Station Class")
   ]
   coclass Station
   {
      [default] interface IStation;
   };

   /// An non-creatable object the represents a station equation. StationEquation objects must be created in a StationEquationCollection.
   ///
   /// Implements the IStationEquation interface.
   [
      uuid(ABC35194-EDA2-4fa3-AC6B-B58A5F0C2385),
      noncreatable,
      helpstring("StationEquation Class")
   ]
   coclass StationEquation
   {
      [default] interface IStationEquation;
   };

   /// An object that represents a point in a SurfaceProfile.
   ///
   /// Implements the ISurfacePoint interface.
   [
      uuid(D83C292A-4677-46ef-BEF2-CF9444A5D8E5),
      helpstring("SurfacePoint Class")
   ]
   coclass SurfacePoint
   {
      [default] interface ISurfacePoint;
   };

   /// An object that represents a cross section template for a Surface. 
   ///
   /// A SurfaceProfile differs from a SurfaceTemplate in that it represents a cross section cut through a surface at an arbitrary orientation.
   /// A SurfaceProfile is defined by a sequence of SurfacePoint objects where a SurfaceTemplate is defined by a sequence of TemplateSegments.
   ///
   /// Implements the ISurfaceProfile interface
   [
      uuid(1B216215-3EEC-407e-BBEC-52BB0C0FBCBD),
      helpstring("SurfaceProfile Class")
   ]
   coclass SurfaceProfile
   {
      [default] interface ISurfaceProfile;
   };

   [
      uuid(9865B17B-5E4C-430B-9020-A5D5EC999858),
      noncreatable,
      hidden,
      helpstring("PierLine Class")
   ]
   coclass PierLine
   {
      [default] interface IPierLine;
   };
   [
      uuid(189665C5-3B81-405B-B011-B78FF2036467),
      noncreatable,
      helpstring("GirderLine Class")
   ]
   coclass GirderLine
   {
      [default] interface IGirderLine;
   };
   [
      uuid(3F5A914A-73B6-43F6-A12B-D545B6B829CE),
      noncreatable,
      helpstring("DiaphragmLine Class")
   ]
   coclass DiaphragmLine
   {
      [default] interface IDiaphragmLine;
   };
   [
      uuid(E66BB224-9C23-47FE-836A-A59945BB46DE),
      noncreatable,
      helpstring("DeckBoundary Class")
   ]
   coclass DeckBoundary
   {
      [default] interface IDeckBoundary;
   };
   
   [
      uuid(ED614FA3-5E15-4428-9B56-2C0C060ABB5B),
      helpstring("SinglePierLineFactory Class")
   ]
   coclass SinglePierLineFactory
   {
      [default] interface ISinglePierLineFactory;
   };

   [
      uuid(6B593F0D-688B-48B2-BC03-5399D1BDAA1B),
      helpstring("AlignmentOffsetLayoutLineFactory Class")
   ]
   coclass AlignmentOffsetLayoutLineFactory
   {
      [default] interface IAlignmentOffsetLayoutLineFactory;
   };
   [
      uuid(71E25E05-E16B-415C-9812-9A2F1EFD9A4B),
      helpstring("SimpleLayoutLineFactory Class")
   ]
   coclass SimpleLayoutLineFactory
   {
      [default] interface ISimpleLayoutLineFactory;
   };
   [
      uuid(4FA7EC00-ADFB-4F50-A9E6-0A3142090639),
      helpstring("UniformSpacingLayoutLineFactory Class")
   ]
   coclass UniformSpacingLayoutLineFactory
   {
      [default] interface IUniformSpacingLayoutLineFactory;
   };
   [
      uuid(FF6273A8-1037-4CCE-B494-F43459E65800),
      helpstring("SingleGirderLineFactory Class")
   ]
   coclass SingleGirderLineFactory
   {
      [default] interface ISingleGirderLineFactory;
   };
   [
      uuid(055CA73B-DD1F-4BC0-A6E5-C13729C16243),
      helpstring("SimpleGirderLineFactory Class")
   ]
   coclass SimpleGirderLineFactory
   {
      [default] interface ISimpleGirderLineFactory;
   };
   [
      uuid(FF0B7F56-329E-4DB3-BF9C-E076555C1EEE),
      helpstring("EqualSpaceDiaphragmLineFactory Class")
   ]
   coclass EqualSpacingDiaphragmLineFactory
   {
      [default] interface IEqualSpacingDiaphragmLineFactory;
   };
   [
      uuid(17FE1E15-7E72-4F4E-AC48-37E1497D0806),
      helpstring("SingleDiaphramgLineFactory Class")
   ]
   coclass SingleDiaphragmLineFactory
   {
      [default] interface ISingleDiaphragmLineFactory;
   };
   [
      uuid(F95676E6-9741-49C0-A3A4-15D9627BDCD8),
      helpstring("ThroughPointDiaphramgLineFactory Class")
   ]
   coclass ThroughPointDiaphragmLineFactory
   {
      [default] interface IThroughPointDiaphragmLineFactory;
   };
   [
      uuid(132789EE-9C31-4D4D-8129-AD733BFA215B),
      helpstring("SimpleDeckBoundaryFactory Class")
   ]
   coclass SimpleDeckBoundaryFactory
   {
      [default] interface ISimpleDeckBoundaryFactory;
   };
   [
      uuid(24D75303-8425-4590-913E-FF2908F65BD1),
      helpstring("BridgeGeometry Class")
   ]
   coclass BridgeGeometry
   {
      [default] interface IBridgeGeometry;
   }; 
};
