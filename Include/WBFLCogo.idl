///////////////////////////////////////////////////////////////////////
// COGO - Coordinate Geometry
// Copyright © 1999-2021  Washington State Department of Transportation
//                        Bridge and Structures Office
//
// This library is a part of the Washington Bridge Foundation Libraries
// and was developed as part of the Alternate Route Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the Alternate Route Library Open Source License as 
// published by the Washington State Department of Transportation,
// Bridge and Structures Office.
//
// This program is distributed in the hope that it will be useful,
// but is distributed AS IS, WITHOUT ANY WARRANTY; without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
// PURPOSE.  See the Alternate Route Library Open Source License for more details.
//
// You should have received a copy of the Alternate Route Library Open Source License
// along with this program; if not, write to the Washington State
// Department of Transportation, Bridge and Structures Office,
// P.O. Box 47340, Olympia, WA 98503, USA or e-mail
// Bridge_Support@wsdot.wa.gov
///////////////////////////////////////////////////////////////////////

// COGO.idl : IDL source for COGO.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (COGO.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";
import "WBFLTypes.idl";
import "WBFLTools.idl";
import "WBFLGeometry.idl";
import "WBFLUnitServer.idl";

#include "COGO.hh"
#include "UnitServer.hh"

cpp_quote("#include <WBFLUnitServer.h>")

typedef IDType CogoObjectID;

cpp_quote("#define COGO_ORIGINAL_SURFACE_ID 0")
cpp_quote("#define COGO_FINISHED_SURFACE_ID 1")

cpp_quote("#define COGO_E_POINTNOTFOUND                MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,512)")
cpp_quote("#define COGO_E_POINTALREADYDEFINED          MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,513)")
cpp_quote("#define COGO_E_BADDIRECTIONSTRING           MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,514)")
cpp_quote("#define COGO_E_BADAZIMUTH                   MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,515)")
cpp_quote("#define COGO_E_BADDIRECTION                 MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,516)")
cpp_quote("#define COGO_E_BADANGLE                     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,517)")
cpp_quote("#define COGO_E_BADANGLESTRING               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,518)")
cpp_quote("#define COGO_E_ANGLE                        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,519)")
cpp_quote("#define COGO_E_AREA                         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,520)")
cpp_quote("#define COGO_E_THREEPNTSREQD                MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,521)")
cpp_quote("#define COGO_E_RADIUS                       MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,522)")
cpp_quote("#define COGO_E_LINESEGMENTNOTFOUND          MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,523)")
cpp_quote("#define COGO_E_LINESEGMENTALREADYDEFINED    MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,524)")
cpp_quote("#define COGO_E_PROFILEPOINTNOTFOUND         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,525)")
cpp_quote("#define COGO_E_PROFILEPOINTALREADYDEFINED   MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,526)")
cpp_quote("#define COGO_E_VERTCURVEPOINTS              MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,527)")
cpp_quote("#define COGO_E_VERTCURVENOTFOUND            MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,528)")
cpp_quote("#define COGO_E_VERTCURVEALREADYDEFINED      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,529)")
cpp_quote("#define COGO_E_HORZCURVENOTFOUND            MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,530)")
cpp_quote("#define COGO_E_HORZCURVEALREADYDEFINED      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,531)")
cpp_quote("#define COGO_E_PROFILEELEMENTTYPE           MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,532)")
cpp_quote("#define COGO_E_PATHELEMENTTYPE              MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,533)")
cpp_quote("#define COGO_E_PATHNOTFOUND                 MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,534)")
cpp_quote("#define COGO_E_PATHALREADYDEFINED           MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,535)")
cpp_quote("#define COGO_E_BADFORMATTAG                 MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,536)")
cpp_quote("#define COGO_E_COINCIDENTPOINTS             MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,537)")
cpp_quote("#define COGO_E_BADSTATIONSTRING             MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,538)")
cpp_quote("#define COGO_E_SPIRALSOVERLAP               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,539)")
cpp_quote("#define COGO_E_POINTEVENTS                  MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,540)")
cpp_quote("#define COGO_E_CUBICSPLINEPOINTS            MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,541)")
cpp_quote("#define COGO_E_POINTINCIRCLE                MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,542)")
cpp_quote("#define COGO_E_NOINTERSECTION               MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,543)")
cpp_quote("#define COGO_E_ALIGNMENTNOTFOUND            MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,544)")
cpp_quote("#define COGO_E_ALIGNMENTALREADYDEFINED      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,545)")
cpp_quote("#define COGO_E_STATIONEQUATIONBACK          MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,546)")
cpp_quote("#define COGO_E_STATIONEQUATIONAHEAD         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,547)")
cpp_quote("#define COGO_E_STATIONRANGEERROR            MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,548)")
cpp_quote("#define COGO_E_SUPERTRANSITIONERROR         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,549)")
cpp_quote("#define COGO_E_SURFACELAYOUTERROR           MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,550)")
cpp_quote("#define COGO_E_SURFACEDEFINITIONERROR       MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,551)")
cpp_quote("#define COGO_E_SURFACESLOPEMISMATCHERROR    MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,552)")
cpp_quote("#define COGO_E_INVALIDRIDGEPOINTINDEX       MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,553)")

interface IProfile;
interface IPath;
interface IAlignment;
interface ISurface;

/// Coordinate Geometry and Roadway Geometrics Modeling Library
[
    uuid(1128D28F-55F7-11D5-8C29-006097C68A9C),
    version(1.0),
	helpcontext(IDH_WBFLCogo),
    helpstring("WBFLCOGO Library")
]
library WBFLCogo
{
   importlib("stdole32.tlb");
   importlib("stdole2.tlb");

    /// Constant describing the general North-South direction of a bearing
    typedef [public,helpstring("Indicates general north/south direction of a bearing"),helpcontext(IDH_NSDirectionType),uuid(AA76DB72-59E7-11d5-8C2D-006097C68A9C)] 
    enum NSDirectionType
    {
       nsNorth = 1, ///< Bearing is in a northerly direction
       nsSouth = 2  ///< Bearing is in a southerly direction
    } NSDirectionType;

    /// Constant describing the general East-West direction of a bearing
    typedef [public,helpstring("Indicates general east/west direction of a bearing"),helpcontext(IDH_EWDirectionType),uuid(AA76DB73-59E7-11d5-8C2D-006097C68A9C)] 
    enum EWDirectionType
    {
       ewEast = 1, ///< Bearing is in an easterly direction
       ewWest = 2  ///< Bearing is in a westerly direction
    } EWDirectionType;

    /// Constant identifying an entry or exit spiral
    typedef [public,helpstring("Indicates the entry or exit spiral of a horizontal curve"),helpcontext(IDH_SpiralType),uuid(66EB558D-4360-47d3-B3C0-0BC65E302333)] 
    enum SpiralType
    {
       spEntry = 1, ///< A spiral transitioning between the back tangent and the beginning of a horizontal curve
       spExit  = 2  ///< A spiral transitioning between the end of a horizontal curve and the forward tangent
    } SpiralType;

    /// Constant describing the direction of a horizontal curve, as viewed ahead on station
    typedef [public,helpstring("Indicates the direction of a horizontal curve"),helpcontext(IDH_CurveDirectionType),uuid(1620A21B-1D7E-437e-B7C8-FF71E6F44BED)] 
    enum CurveDirectionType
    {
       cdLeft  = 1, ///< Curve turns to the left (counter-clockwise)
       cdRight = 2  ///< Curve turns to the right (clockwise)
    } CurveDirectionType;

    /// Constant identifying the typ eof object associated with a ProfileElement objecct
    typedef [public,helpstring("Indicates a profile element type"),helpcontext(IDH_ProfileElementType),uuid(667D49B0-8BE7-43e6-8CE6-5245309C128C)] 
    enum ProfileElementType
    {
       pePoint     = 1, ///< Associated object is a ProfilePoint
       peVertCurve = 2  ///< Associated object is a VertCurve
    } ProfileElementType;

    /// Constant identifying the type of object associated with a PathElement object
    typedef [public,helpstring("Indicates an alignment element type"),helpcontext(IDH_PathElementType),uuid(A5FC1519-B488-4943-94FC-ACBA59BCB733)] 
    enum PathElementType
    {
       petPoint       = 1, ///< Associated object is a WBFLGeometry::Point2d
       petLineSegment = 2, ///< Associated object is a WBFLGeometry::LineSegment2d
	   petHorzCurve   = 3, ///< Associated object is a HorzCurve
	   petCubicSpline = 4 ///< Associated object is a CubicSpline
    } PathElementType;

    /// Constant identifying the direction of the angle formed by a circular curve tangent line and the line connecting the centers of circles. See documentation for ITangent interface for usage.
    typedef [public,helpstring("Indicates the direction of the angle formed by a circular tangent line and the line connecting the centers of the circles"),helpcontext(IDH_TangentSignType),uuid(ED58941C-11B9-484e-A9D6-D07ADB1FA0A3)] 
    enum TangentSignType
    {
       tsCW       =  1, ///< Clockwise angle
       tsCCW      = -1, ///< Counter-clockwise angle
    } TangentSignType;

    /// Constant describing the method by which the degree of curve is computed
    typedef [public,helpstring("Indicates the method for computing the degree of curvature"),helpcontext(IDH_DegreeCurvatureType),uuid(26428AC0-AEE2-4bdb-8CC9-8C13F531A4B7)] 
    enum DegreeCurvatureType
    {
       dcChord    =  1, ///< Computed by the length of chord method
       dcArc      =  2, ///< Computed by the length of arc method
       dcRailroad =  1, ///< Same as dcChord
       dcHighway  =  2, ///< Same as dcArc
    } DegreeCurvatureType;

    /// Constant describing how an offset is measured
    typedef [public,helpstring("Indicates how an offset is measured")/*,helpcontext(IDH_TangentSignType)*/,uuid(50A94F9E-EACB-4b60-936F-23E5F4F24C86)] 
    enum OffsetMeasureType
    {
       omtAlongDirection =  1, ///< Offset is measured along a line projecting from an object
       omtNormal         =  2, ///< Offset is measured normal to object
    } OffsetMeasureType;

    /// Constant defining the type of superelevation transition
    typedef [public,helpstring("Defines superelevation transition type"),uuid(9CF798F5-D551-4b7f-A5BB-FAF9C3AEDA8B)]
    enum SuperTransitionType
    {
       stLinear,    ///< Superelevation transition is linear
       stParabolic  ///< Superelevation transition is parabolic
    } SuperTransitionType;

    /// Constant defining how a template segment slope is measured
    typedef [public,helpstring("Defines how a template segment slope is measured"),uuid(E565E720-42ED-47b5-A00C-6435E6E8195A)]
    enum TemplateSlopeType
    {
       tsHorizontal,      ///< measured as rise over 1
       tsFixedHorizontal, ///< measured as rise over 1 and is not changed by superelevations
       tsFixedVertical    ///< measured as 1 over run and is not changed by superelevations
    } TemplateSlopeType;

    /// Interface for objects that represents an angle. 
    /// Counter-clockwise angles (Left) angles have positive values
    [
        object,
        uuid(2C98A246-55F7-11D5-8C29-006097C68A9C),
        oleautomation,
		helpcontext(IDH_Angle),
        helpstring("IAngle Interface"),
        pointer_default(unique)
    ]
    interface IAngle : IUnknown
    {
       /// The value of the angle in radians.
        [propget, helpstring("property Value"),helpcontext(IDH_Angle_Value)] HRESULT Value([out, retval] Float64 *pVal);
        [propput, helpstring("property Value"),helpcontext(IDH_Angle_Value)] HRESULT Value([in] Float64 newVal);
        
        /// Returns the degree portion of the angle in DMS format
        [propget, helpstring("property Degree"),helpcontext(IDH_Angle_Degree)] HRESULT Degree([out, retval] long *pVal);

        /// Returns the minute portion of the angle in DMS format
        [propget, helpstring("property Minute"),helpcontext(IDH_Angle_Minute)] HRESULT Minute([out, retval] long *pVal);

        /// Returns the second portion of the angle in DMS format
        [propget, helpstring("property Second"),helpcontext(IDH_Angle_Second)] HRESULT Second([out, retval] Float64 *pVal);

        /// Normalizes the angle by causing the value to be between 0 and \f$2\pi\f$ radians
        [helpstring("method Normalize"),helpcontext(IDH_Angle_Normalize)] HRESULT Normalize();

        /// Sets the value of the angle from DMS values
        [helpstring("method FromDMS"),helpcontext(IDH_Angle_FromDMS)] HRESULT FromDMS([in] long deg,[in] long min,[in] Float64 sec);

        /// Sets the value of the angle from a text string. The format of the text string is described in \ref WBFL_COGO_Angles_Directions_Stations
        [helpstring("method FromString"),helpcontext(IDH_Angle_FromString)] HRESULT FromString([in] BSTR bstrAngle);

        /// Sets the value of the angle using a VARIANT. The VARIANT can contain the angle as a value or a string. The format of the text string is described in \ref WBFL_COGO_Angles_Directions_Stations
        [helpstring("method FromVariant")] HRESULT FromVariant([in] VARIANT varAngle);

        ///	Creates a new Angle that is equal to this Angle plus a increment
        /// The increment angle can be specified using an Angle object, numeric value, or string.
        [helpstring("method Increment"),helpcontext(IDH_Angle_Increment)] HRESULT Increment(
           [in] VARIANT varAngle, ///< the increment angle
           [out,retval] IAngle* *pVal ///< the new angle
        );

        /// Increments this Angle by a specified angle
        /// The increment angle can be specified using an Angle object, numeric value, or string. The resulting angle is not normalized.
        [helpstring("method IncrementBy"),helpcontext(IDH_Angle_IncrementBy)] HRESULT IncrementBy([in] VARIANT varAngle);

        /// Creates a copy of this object
        [helpstring("method Clone"),helpcontext(IDH_Angle_Clone)] HRESULT Clone([out,retval] IAngle* *clone);

        /// Returns a reference to a IStructuredStorage2 interface
        [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
    };

    /// Interface for objects that represents a direction. A direction can be a bearing or an azimuth.
    [
        object,
        uuid(2C98A251-55F7-11D5-8C29-006097C68A9C),
        oleautomation,
		helpcontext(IDH_Direction),
        helpstring("IDirection Interface"),
        pointer_default(unique)
    ]
    interface IDirection : IUnknown
    {
        /// Returns the direction value as an azimuth
        [propget, helpstring("property Azimuth"),helpcontext(IDH_Direction_Azimuth)] HRESULT Azimuth([out, retval] Float64 *pVal);

        /// Value of the direction as a bearing
        [propget, helpstring("property Value"),helpcontext(IDH_Direction_Value)] HRESULT Value([out, retval] Float64 *pVal);
        [propput, helpstring("property Value"),helpcontext(IDH_Direction_Value)] HRESULT Value([in] Float64 newVal);

        /// North-South direction
        [propget, helpstring("property NSDirection"),helpcontext(IDH_Direction_NSDirection)] HRESULT NSDirection([out, retval] NSDirectionType *pVal);
        [propput, helpstring("property NSDirection"),helpcontext(IDH_Direction_NSDirection)] HRESULT NSDirection([in] NSDirectionType newVal);

        /// East-West direction
        [propget, helpstring("property EWDirection"),helpcontext(IDH_Direction_EWDirection)] HRESULT EWDirection([out, retval] EWDirectionType *pVal);
        [propput, helpstring("property EWDirection"),helpcontext(IDH_Direction_EWDirection)] HRESULT EWDirection([in] EWDirectionType newVal);

        /// Degree portion of the direction (DMS format)
        [propget, helpstring("property Degree"),helpcontext(IDH_Direction_Degree)] HRESULT Degree([out, retval] long *pVal);
        [propput, helpstring("property Degree"),helpcontext(IDH_Direction_Degree)] HRESULT Degree([in] long newVal);

        /// Minute portion of the direction (DMS format)
        [propget, helpstring("property Minute"),helpcontext(IDH_Direction_Minute)] HRESULT Minute([out, retval] long *pVal);
        [propput, helpstring("property Minute"),helpcontext(IDH_Direction_Minute)] HRESULT Minute([in] long newVal);

        /// Second portion of the direction (DMS format)
        [propget, helpstring("property Second"),helpcontext(IDH_Direction_Second)] HRESULT Second([out, retval] Float64 *pVal);
        [propput, helpstring("property Second"),helpcontext(IDH_Direction_Second)] HRESULT Second([in] Float64 newVal);

        /// Creates a new direction that is equal to this direction plus an angular increment
        [helpstring("method Increment"),helpcontext(IDH_Direction_Increment)] HRESULT Increment(
           [in] VARIANT varAngle, ///< The angular increment in one of the formats described in \ref WBFL_COGO_Angles_Directions_Stations
           [out,retval] IDirection* *pVal ///< The new direction object
        );

        /// Increments this direction by a specified angle
        [helpstring("method IncrementBy"),helpcontext(IDH_Direction_IncrementBy)] HRESULT IncrementBy(
           [in] VARIANT varAngle ///< The angular increment in one of the formats described in \ref WBFL_COGO_Angles_Directions_Stations
        );

        /// Sets the value of this direction from a text string. The format of the text string is described in \ref WBFL_COGO_Angles_Directions_Stations
        [helpstring("method FromString"),helpcontext(IDH_Direction_FromString)] HRESULT FromString(
           [in] BSTR bstrDir ///< Direction as a text string as described in \ref WBFL_COGO_Angles_Directions_Stations
        );

        /// Sets the value of this direction from DMS values
        [helpstring("method FromDMS"),helpcontext(IDH_Direction_FromDMS)] HRESULT FromDMS(
           [in] NSDirectionType ns, ///< North-South direction
           [in] long Degree, ///< degree portion of angle
           [in] long Minute,  ///< minute portion of angle
           [in] Float64 Second,  ///< second portion of angle
           [in] EWDirectionType ew ///< East-West direction
        );

        /// Sets the value of this direction with a floating point azimuth value
        [helpstring("method FromAzimuth"),helpcontext(IDH_Direction_FromAzimuth)] HRESULT FromAzimuth(
           [in] Float64 azimuth ///< azimuth as a decimal value
        );

        /// Sets the value of this direction with an azimuth in DMS format
        [helpstring("method FromAzimuth"),helpcontext(IDH_Direction_FromAzimuth)] HRESULT FromAzimuthEx(
           [in] long Degree,  ///< degree portion of azimuth
           [in] long Minute,  ///< minute portion of azimuth
           [in] Float64 Second ///< second portion of azimuth
        );

        /// Sets the value of this direction using a VARIANT. The VARIANT can contain the direction as a value or a string. The format of the text string is described in \ref WBFL_COGO_Angles_Directions_Stations
        [helpstring("method FromVariant")] HRESULT FromVariant(
           [in] VARIANT varDirection ///< direction value
        );

        /// Returns the angle between this direction object an another direction object
        /// \image html AngleBetween.jpg
		  [helpstring("method AngleBetween"),helpcontext(IDH_Direction_AngleBetween)] HRESULT AngleBetween(
           [in] IDirection* dir, ///< the direction with which this angle is to be computed
           [out,retval]IAngle** pVal ///< Angle between the two directions
        );

        /// Creates a cloen of this object
        [helpstring("method Clone"),helpcontext(IDH_Direction_Clone)] HRESULT Clone([out,retval] IDirection* *clone);

        /// Compares this and another direction. Returns S_OK if they are equal, otherwise returns S_FALSE
        [helpstring("method IsEqual")] HRESULT IsEqual(IDirection* pDirection);

        /// Returns a reference to a IStructuredStorage2 interface
        [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
    };

    /// Extends the IDisplayUnitFormatter interface to format angles
	[
		object,
		uuid(739D2AB4-A3E9-4BCC-AC06-75E8293C08B7),
		oleautomation,
		helpcontext(IDH_AngleDisplayUnitFormatter),
		helpstring("IAngleDisplayUnitFormatter Interface"),
		pointer_default(unique)
	]
	interface IAngleDisplayUnitFormatter : IDisplayUnitFormatter
	{
      /// Specifies whether the condensed angle format should be used.
      ///
      /// When the minutes and seconds part of an angle are zero, such as "45 00 00 L", the zeros are omitted when condensed formatting is used resulting in "45 L"
		[propget, helpstring("property CondensedFormat"),helpcontext(IDH_AngleDisplayUnitFormatter_CondensedFormat)] HRESULT CondensedFormat([out, retval] VARIANT_BOOL *pVal);
		[propput, helpstring("property CondensedFormat"),helpcontext(IDH_AngleDisplayUnitFormatter_CondensedFormat)] HRESULT CondensedFormat([in] VARIANT_BOOL newVal);

      /// Specifies if the angle is formatted as a signed angle or a directional angle.
      ///
      /// The degrees portion of a signed angle is preceeded with a minus sign (-) if its value is less than zero. Otherwise, the formatted angle will be adorned with L or R. 
      /// Example: value = -45, signed format: -45° 00' 00", not signed format 45° 00' 00" R
		[propget, helpstring("property Signed"),helpcontext(IDH_AngleDisplayUnitFormatter_Signed)] HRESULT Signed([out, retval] VARIANT_BOOL *pVal);
		[propput, helpstring("property Signed"),helpcontext(IDH_AngleDisplayUnitFormatter_Signed)] HRESULT Signed([in] VARIANT_BOOL newVal);
   };

   /// Extends the IDisplayUnitFormatter interface to format directions
   [
		object,
		uuid(FFA2F69D-8B5B-40ED-9802-35BEA09551B7),
		oleautomation,
		helpcontext(IDH_DirectionDisplayUnitFormatter),
		helpstring("IDirectionDisplayUnitFormatter Interface"),
		pointer_default(unique)
	]
	interface IDirectionDisplayUnitFormatter : IDisplayUnitFormatter
	{
      /// Specifies whether the condensed direction format should be used.
      ///
      /// When the minutes and seconds part of a direction are zero, such as "N 45 00 00 E", the zeros are omitted when condensed formatting is used resulting in "N 45 E"
      [propget, helpstring("property CondensedFormat"),helpcontext(IDH_DirectionDisplayUnitFormatter_CondensedFormat)] HRESULT CondensedFormat([out, retval] VARIANT_BOOL *pVal);
		[propput, helpstring("property CondensedFormat"),helpcontext(IDH_DirectionDisplayUnitFormatter_CondensedFormat)] HRESULT CondensedFormat([in] VARIANT_BOOL newVal);

      /// Specifies if the direction is formatted as a bearing or an azimuth.
		[propget, helpstring("property BearingFormat"),helpcontext(IDH_DirectionDisplayUnitFormatter_BearingFormat)] HRESULT BearingFormat([out, retval] VARIANT_BOOL *pVal);
		[propput, helpstring("property BearingFormat"),helpcontext(IDH_DirectionDisplayUnitFormatter_BearingFormat)] HRESULT BearingFormat([in] VARIANT_BOOL newVal);
   };

   /// Callback interface for IPoint2d events
    [
       object,
       oleautomation,
       uuid(74B1E8A0-5EAC-11d5-8C32-006097C68A9C),
	   helpcontext(IDH_Point),
       helpstring("IPointEvents Interface"),
       pointer_default(unique)
    ]
    interface IPointEvents : IUnknown
    {
       /// Called after a point changes.
       [helpstring("event OnPointChanged"),helpcontext(IDH_Point_OnPointChanged)] HRESULT OnPointChanged(IPoint2d* point);
    };

    /// Interface used to enumerate values in a container
    [
       object,
       uuid(5C3C09D6-5E7F-11d5-8C32-006097C68A9C),
       helpstring("IEnumIDs Interface"),
       oleautomation,
       hidden,restricted,
       pointer_default(unique)
    ]
    interface IEnumIDs : IUnknown
    {
       /// Clone the enumerator
       [helpstring("Clone")]  HRESULT Clone([out] IEnumIDs** ppenum);

       /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
       /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
       [helpstring("Next")]
       HRESULT Next(
          [in] ULONG celt, ///< Number of elements being requested
          [out] CogoObjectID* rgelt, ///< Array of size celt (or larger) of elements of interest
          [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
       );

       /// Resets the enumeration sequence to the beginning.
       [helpstring("Reset")] HRESULT Reset();
       
       /// Skips over the next specified number of elements in the enumeration sequence.
       [helpstring("Skip")]
       HRESULT Skip(
          [in] ULONG celt ///< Number of elements to skip
       );
    };

    /// Interface for defining a collection of objects implementing the IPoint2d interface.
    [
        object,
        uuid(5559C9A5-5C16-11D5-8C31-006097C68A9C),
        oleautomation,
		helpcontext(IDH_PointCollection),
        helpstring("IPointCollection Interface"),
        pointer_default(unique)
    ]
    interface IPointCollection : IUnknown
    {
       /// Gets an item from the collection using its identifier.
       [propget, helpstring("property Item"),helpcontext(IDH_PointCollection_Item)] HRESULT Item([in] CogoObjectID id, [out, retval] IPoint2d* *pVal);

        /// Replaces an item in the collection
        [propputref, helpstring("property Item"),helpcontext(IDH_PointCollection_Item)] HRESULT Item([in] CogoObjectID id, [in] IPoint2d* newVal);

        /// Returns the number of items in the collection.
        [propget, helpstring("property Count"),helpcontext(IDH_PointCollection_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

        /// Adds a point to the collection. The new point object is created with the IPoint2dFactory object associated with this collection.
        [helpstring("method Add"),helpcontext(IDH_PointCollection_Add)] HRESULT Add(
           [in] CogoObjectID id, ///< Unique identifier for the point
           [in] Float64 x, ///< X coordinate
           [in] Float64 y, ///< Y coordinate
           [out,retval] IPoint2d* *point ///< The new point object
        );

        /// Adds a point to the collection.
        [helpstring("method AddEx"),helpcontext(IDH_PointCollection_AddEx)] 
        HRESULT AddEx(
           [in] CogoObjectID id, ///< Unique identifier for the point
           [in] IPoint2d* point ///< The point
        );

        /// Removes a point from the collection
        [helpstring("method Remove"),helpcontext(IDH_PointCollection_Remove)] 
        HRESULT Remove(
           [in] CogoObjectID id ///< The point identifier
        );

        /// Removes all items from the collection
        [helpstring("method Clear"),helpcontext(IDH_PointCollection_Clear)] HRESULT Clear();

        /// Searches the collection for a point and returns its identifier
        [helpstring("method FindID"),helpcontext(IDH_PointCollection_FindID)] 
        HRESULT FindID(
           [in] IPoint2d* point, ///< The point
           [out,retval]CogoObjectID* ID ///< Identifier of the point
        );

        /// Returns the ID at a specific location in the collection
        [helpstring("method ID"), helpcontext(IDH_PointCollection_ID)] HRESULT ID([in] CollectionIndexType index, [out, retval] CogoObjectID* ID);

         /// A factory object used to create new Point2d objects
		   [propget, helpstring("method Factory"),helpcontext(IDH_PointCollection_Factory)] HRESULT Factory([out,retval]IPoint2dFactory** factory);
		   [propputref, helpstring("method Factory"),helpcontext(IDH_PointCollection_Factory)] HRESULT Factory([in]IPoint2dFactory* factory);

         /// Clones the collection making a copy of all the contained objects
         [helpstring("method Clone"), helpcontext(IDH_PointCollection_Clone)] HRESULT Clone([out, retval]IPointCollection* *clone);

         /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
         [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

         /// Returns an IEnumIDs interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
         [propget, restricted, helpstring("property _EnumIDs"), helpcontext(IDH_PointCollection__EnumIDs)] HRESULT _EnumIDs([out, retval] IEnumIDs** ppenum);

         /// Returns an IEnumPoint2d interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
         [propget,restricted,helpstring("property _EnumPoints"),helpcontext(IDH_PointCollection__EnumPoints)] HRESULT _EnumPoints([out,retval] IEnumPoint2d** ppenum);

         /// The StructuredStorage property.
         [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
    };

    /// Callback interface for IPointCollection events
    [
        object,
        uuid(74B1E8A1-5EAC-11d5-8C32-006097C68A9C),
        oleautomation,
		helpcontext(IDH_PointCollection),
        helpstring("IPointCollection Interface"),
        pointer_default(unique)
    ]
    interface IPointCollectionEvents : IUnknown
    {
       /// Called after a point is changed
        [helpstring("event OnPointChanged"),helpcontext(IDH_PointCollection_OnPointChanged)] 
        HRESULT OnPointChanged(
           [in] CogoObjectID id, ///< Point ID
           [in] IPoint2d* point ///< The point
        );

        /// Called after a point is added
        [helpstring("event OnPointAdded"),helpcontext(IDH_PointCollection_OnPointAdded)] 
        HRESULT OnPointAdded(
           [in] CogoObjectID id, ///< Point ID
           [in] IPoint2d* point ///< The point
        );

        /// Called after a point is removed
        [helpstring("event OnPointRemoved"),helpcontext(IDH_PointCollection_OnPointRemoved)] 
        HRESULT OnPointRemoved(
           [in] CogoObjectID id ///< Point ID
        );

        /// Called when the collection is cleared
        [helpstring("event OnPointsCleared"),helpcontext(IDH_PointCollection_OnPointsCleared)] HRESULT OnPointsCleared();
    };

    /// Interface for horizontal curve objects.
    ///
    /// A horizontal curve is defined by a point on the back tangent, the intersection point of the back and forward tangents, 
    /// a point on the forward tangent, and the radius. Entry and/or exit clothoid spirals can be added to the curve by 
    /// defining their length. Input values are denoted in red in the figure below. 
    /// \image html /HorzCurve/HorzCurve.jpg
   [
       object,
       uuid(7E56BBC9-AC81-4B6D-8366-319DEE51A0D8),
       oleautomation,
	   helpcontext(IDH_HorzCurve),
       helpstring("IHorzCurve Interface"),
       pointer_default(unique)
   ]
   interface IHorzCurve : IUnknown
   {
      /// Point on back tangent
       [propget, helpstring("property PBT"), helpcontext(IDH_HorzCurve_PBT)] HRESULT PBT([out, retval] IPoint2d* *pVal);
       [propputref, helpstring("property PBT"), helpcontext(IDH_HorzCurve_PBT)] HRESULT PBT([in] IPoint2d* newVal);

       /// Point of intersection
       [propget, helpstring("property PI"), helpcontext(IDH_HorzCurve_PI)] HRESULT PI([out, retval] IPoint2d* *pVal);
       [propputref, helpstring("property PI"), helpcontext(IDH_HorzCurve_PI)] HRESULT PI([in] IPoint2d* newVal);

       /// Point on forward tangent
       [propget, helpstring("property PFT"), helpcontext(IDH_HorzCurve_PFT)] HRESULT PFT([out, retval] IPoint2d* *pVal);
       [propputref, helpstring("property PFT"), helpcontext(IDH_HorzCurve_PFT)] HRESULT PFT([in] IPoint2d* newVal);

       /// Circular curve radius
       [propget, helpstring("property Radius"), helpcontext(IDH_HorzCurve_Radius)] HRESULT Radius([out, retval] Float64 *pVal);
       [propput, helpstring("property Radius"), helpcontext(IDH_HorzCurve_Radius)] HRESULT Radius([in] Float64 newVal);

       /// Length of transition spiral
       [propget, helpstring("property SpiralLength"), helpcontext(IDH_HorzCurve_SpiralLength)] HRESULT SpiralLength([in] SpiralType spType,[out, retval] Float64 *pVal);
       [propput, helpstring("property SpiralLength"), helpcontext(IDH_HorzCurve_SpiralLength)] HRESULT SpiralLength([in] SpiralType spType,[in] Float64 newVal);

       /// Returns the spiral curve angle
       [propget, helpstring("property SpiralAngle"), helpcontext(IDH_HorzCurve_SpiralAngle)] HRESULT SpiralAngle([in] SpiralType spType,[out, retval] IAngle* *pVal);

       /// Returns the distance along the tangent from TS (or ST) to a perpendicular offset to the end of the spiral.
       /// \image html /HorzCurve/Spiral.jpg
	   [propget, helpstring("property X"), helpcontext(IDH_HorzCurve_X)] HRESULT X([in]SpiralType spType,[out,retval]Float64* x);

      /// Returns the offset from the tangent to the spiral at its maximum degree of curvature measured along a perpendicular from the tangent to SC (or CS).
      /// \image html /HorzCurve/Spiral.jpg
      [propget, helpstring("property Y"), helpcontext(IDH_HorzCurve_Y)] HRESULT Y([in]SpiralType spType,[out,retval]Float64* y);

      /// Returns the offset distance that the entire circular curve is radially set in from the tangents to allow for spiral connections.
      /// \image html /HorzCurve/Spiral.jpg
      [propget, helpstring("property Q"), helpcontext(IDH_HorzCurve_Q)] HRESULT Q([in]SpiralType spType,[out,retval]Float64* q);

      /// Returns the distance T
      /// \image html /HorzCurve/Spiral.jpg
      [propget, helpstring("property T"), helpcontext(IDH_HorzCurve_T)] HRESULT T([in]SpiralType spType,[out,retval]Float64* t);

      /// Returns the back tangent bearing
	   [propget, helpstring("property BkTangentBrg"), helpcontext(IDH_HorzCurve_BkTangentBrg)] HRESULT BkTangentBrg([out,retval]IDirection* *brg);

      /// Returns the forward tangent bearing
	   [propget, helpstring("property FwdTangentBrg"), helpcontext(IDH_HorzCurve_FwdTangentBrg)] HRESULT FwdTangentBrg([out,retval]IDirection* *brg);

      /// Returns the back tangent length
	   [propget, helpstring("property BkTangentLength"), helpcontext(IDH_HorzCurve_BkTangentLength)] HRESULT BkTangentLength([out,retval]Float64* t);

      /// Returns the forward tangent length.
      [propget, helpstring("property FwdTangentLength"), helpcontext(IDH_HorzCurve_FwdTangentLength)] HRESULT FwdTangentLength([out,retval]Float64* t);
      
      /// Returns the total angle of the curve.
      [propget, helpstring("property CurveAngle"), helpcontext(IDH_HorzCurve_CurveAngle)] HRESULT CurveAngle([out, retval] IAngle* *pVal);

      /// Returns the tangent to spiral point
      [propget, helpstring("property TS"), helpcontext(IDH_HorzCurve_TS)] HRESULT TS([out, retval] IPoint2d* *pVal);

      /// Returns the spiral to tangent point
       [propget, helpstring("property ST"), helpcontext(IDH_HorzCurve_ST)] HRESULT ST([out, retval] IPoint2d* *pVal);

       /// Returns the spiral to circular curve point
       [propget, helpstring("property SC"), helpcontext(IDH_HorzCurve_SC)] HRESULT SC([out, retval] IPoint2d* *pVal);

       /// returns the circular curve to spiral point
       [propget, helpstring("property CS"), helpcontext(IDH_HorzCurve_CS)] HRESULT CS([out, retval] IPoint2d* *pVal);

       /// Returns the chord length of the circular curve
       /// \image html /HorzCurve/CircularCurve.jpg
	   [propget, helpstring("property Chord"), helpcontext(IDH_HorzCurve_Chord)] HRESULT Chord([out,retval]Float64* chord);

      /// Returns the internal angle of the circular curve
       [propget, helpstring("property CircularCurveAngle"), helpcontext(IDH_HorzCurve_CircularCurveAngle)] HRESULT CircularCurveAngle([out, retval] IAngle* *pVal);

       /// Returns the length of the circular curve tangent
       /// \image html /HorzCurve/CircularCurve.jpg
       [propget, helpstring("property Tangent"), helpcontext(IDH_HorzCurve_Tangent)] HRESULT Tangent([out,retval]Float64* tangent);

       /// Returns the length of the circular curve mid-ordinate
       /// \image html /HorzCurve/CircularCurve.jpg
       [propget, helpstring("property MidOrdinate"), helpcontext(IDH_HorzCurve_MidOrdinate)] HRESULT MidOrdinate([out,retval]Float64* mo);

       /// Returns the length of the circular curve external
       /// \image html /HorzCurve/CircularCurve.jpg
       [propget, helpstring("property External"), helpcontext(IDH_HorzCurve_External)] HRESULT External([out,retval]Float64* external);
	   
       /// Returns the deviation angle of the spiral
       /// \image html /HorzCurve/Spiral.jpg
       [propget, helpstring("property DE"), helpcontext(IDH_HorzCurve_DE)] HRESULT DE([in]SpiralType spType,[out,retval]IAngle* *pDE);
       
       /// Returns the long tangent of the spiral
       /// \image html /HorzCurve/Spiral.jpg
       [propget, helpstring("property LongTangent"), helpcontext(IDH_HorzCurve_LongTangent)] HRESULT LongTangent([in]SpiralType spType,[out,retval]Float64* u);

       /// Returns the short tangent of the spiral
       /// \image html /HorzCurve/Spiral.jpg
       [propget, helpstring("property ShortTangent"), helpcontext(IDH_HorzCurve_ShortTangent)] HRESULT ShortTangent([in]SpiralType spType,[out,retval]Float64* v);

       /// Returns the center point of the curve. The center point of the curve is taken to be the intersection of lines perpendicular to the back and forward tangents at TS and ST.
       [propget, helpstring("property CC"), helpcontext(IDH_HorzCurve_CC)] HRESULT CC([out, retval] IPoint2d* *pVal);

       /// Returns the intersection point of the circular curve tangents
       [propget, helpstring("property PCI"), helpcontext(IDH_HorzCurve_PCI)] HRESULT PCI([out, retval] IPoint2d* *pVal);

       /// Returns the intersection point of the spiral tangents
	   [propget, helpstring("property SPI"), helpcontext(IDH_HorzCurve_SPI)] HRESULT SPI([in]SpiralType spType,[out,retval]IPoint2d** pSPI);

      /// Returns the back tangent of the circular curve
	   [propget, helpstring("property CurveBkTangentBrg"), helpcontext(IDH_HorzCurve_CurveBkTangentBrg)] HRESULT CurveBkTangentBrg([out,retval]IDirection* *brg);

      /// Returns the foward tangent of the circular curve
      [propget, helpstring("property CurveFwdTangentBrg"), helpcontext(IDH_HorzCurve_CurveFwdTangentBrg)] HRESULT CurveFwdTangentBrg([out,retval]IDirection* *brg);

      /// Returns the center point of the circular curve. The center point of the curve is taken to be the intersection of lines perpendicular to the back and forward tangents of the circular curve at SC and CS.
       [propget, helpstring("property CCC"), helpcontext(IDH_HorzCurve_CCC)] HRESULT CCC([out, retval] IPoint2d* *pVal);
       
       /// Returns the deflection angle of the spiral
       /// \image html /HorzCurve/Spiral.jpg
       [propget, helpstring("property DF"), helpcontext(IDH_HorzCurve_DF)] HRESULT DF([in]SpiralType spType,[out,retval] IAngle** pDF);

       /// Returns the difference between DE and DF
       /// \image html /HorzCurve/Spiral.jpg
       [propget, helpstring("property DH"), helpcontext(IDH_HorzCurve_DH)] HRESULT DH([in]SpiralType spType,[out,retval] IAngle** pDH);

       /// Returns the chord length of the spiral
   	   [propget, helpstring("property SpiralChord"), helpcontext(IDH_HorzCurve_SpiralChord)] HRESULT SpiralChord([in]SpiralType spType,[out,retval] Float64* cs);

         /// Returns the direction if the cirved. The direction is as viewed looking ahead on station.
   	   [propget, helpstring("property Direction"), helpcontext(IDH_HorzCurve_Direction)] HRESULT Direction([out,retval] CurveDirectionType* dir);

         /// Returns the length of the circular curve
	   [propget, helpstring("property CurveLength"), helpcontext(IDH_HorzCurve_CurveLength)] HRESULT CurveLength([out,retval] Float64* pVal);

      /// Returns the total length of the horizontal curve
	   [propget, helpstring("property TotalLength"), helpcontext(IDH_HorzCurve_TotalLength)] HRESULT TotalLength([out,retval] Float64* pVal);

      /// Returns the degree of curvature of the circular curve.
      ///
      /// The degree of curvature can be computed by either the arc or chord method.
      ///
      /// Arc Method: \f[ dc = \frac{\Delta}{R} \f]
      /// Chord Method: \f[ dc = 2\sin^{-1}\frac{\Delta}{2R} \f]
	   [propget, helpstring("property DegreeCurvature"), helpcontext(IDH_HorzCurve_DegreeCurvature)] HRESULT DegreeCurvature([in] Float64 D,[in] DegreeCurvatureType dcMethod,[out,retval] IAngle** pDC);

      /// Computes the bearing of a line at a specified distance from TS. If the specified distance is less than zero or if it is greater than the curve length, the direction will be the bearing of the back or forward tangent, respectively.
	   [helpstring("method Bearing"), helpcontext(IDH_HorzCurve_Bearing)] HRESULT Bearing([in] Float64 distance,[out,retval]IDirection* *pVal);

      /// Computes the normal of a line at a specified distance from TS. If the specified distance is less than zero or if it is greater than the curve length, the direction will be normal to the back or forward tangent, respectively.
	   [helpstring("method Normal"), helpcontext(IDH_HorzCurve_Normal)] HRESULT Normal([in] Float64 distance,[out,retval]IDirection* *pVal);

      /// Locates a point on the curve at a specified distance from TS. If the specified distance is less than zero or if it is greater than the curve length, the point will be located on the back or forward tangent, respectively.
	   [helpstring("method PointOnCurve"), helpcontext(IDH_HorzCurve_PointOnCurve)] HRESULT PointOnCurve([in] Float64 distance,[out,retval]IPoint2d* *pVal);

      /// Projects a point onto the curve such that a line perpendicular to the curve passes through the point. If the projected point falls before the TS point, or after the ST point, then it will be a point on the back or forward tangent, respectively.
      [helpstring("method ProjectPoint"), helpcontext(IDH_HorzCurve_ProjectPoint)] HRESULT ProjectPoint([in] IPoint2d* point,[out,retval] IPoint2d* *pNewPoint);

      /// Computes the distance along the curve from TS to the intersection of a point projected onto the curve and the curve.
      [helpstring("method DistanceFromStart"), helpcontext(IDH_HorzCurve_DistanceFromStart)] HRESULT DistanceFromStart([in] IPoint2d* point,[out,retval] Float64* dist);

      /// Determines the points where a line intersects the curve. The point objects are Nothing if there aren't intersection points.
	  [helpstring("method Intersect"), helpcontext(IDH_HorzCurve_Intersect)] HRESULT Intersect(
        [in]ILine2d* line, ///< A line that intersects the curve
        [in]VARIANT_BOOL bProjectBack, ///< VARIANT_TRUE to project the back tangent
        [in]VARIANT_BOOL bProjectAhead, ///< VARIANT_TRUE to project the ahead tangent
        [out] IPoint2d** p1, ///< Intersection point nearest the start of the curve. *p1 is nullptr if intersection points where not found.
        [out] IPoint2d** p2 ///< Interection point nearest the end of the curve. *p2 is nullptr if intersection points where not found.
     );

     /// Offsets the curve from its present location
     [helpstring("method Offset"), helpcontext(IDH_HorzCurve_Offset)] HRESULT Offset
     (
        [in]Float64 dx, ///< Distance to offset the curve in the X (East-West) direction.
        [in]Float64 dy ///< Distnace to offset the curve in the Y (North-South) direction.
     );

     /// A factory for creating point objects
	   [propget, helpstring("property PointFactory"), helpcontext(IDH_HorzCurve_PointFactory)] HRESULT PointFactory([out,retval] IPoint2dFactory* *factory);
	   [propputref, helpstring("property PointFactory"), helpcontext(IDH_HorzCurve_PointFactory)] HRESULT PointFactory([in] IPoint2dFactory *factory);

      /// Creates a clone of this object
      [helpstring("method Clone"), helpcontext(IDH_HorzCurve_Clone)] HRESULT Clone([out,retval] IHorzCurve* *clone);

      /// Returns a reference to an IStructuredStorage2 interface
        [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for horizontal curve events.
   [
       object,
       uuid(4726E8C7-5B74-4cda-844B-4F7B1B5AB1ED),
       oleautomation,
	   helpcontext(IDH_HorzCurve),
       helpstring("IHorzCurveEvents Interface"),
       pointer_default(unique)
   ]
   interface IHorzCurveEvents : IUnknown
   {
      /// Called after a horizontal curve is changed.
       [helpstring("event OnHorzCurveChanged"), helpcontext(IDH_HorzCurve_OnHorzCurveChanged)] HRESULT OnHorzCurveChanged([in] IHorzCurve* hc);
   };

	/// Interface for objects that enumerate a collection of ILineSegment2d objects
	[
	   object,
	   uuid(B5850388-0046-4491-BE25-9EC1E6B66344),
	   helpstring("IEnumLineSegments Interface"),
	   //helpcontext(IDH_IEnumLineSegments),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumLineSegments : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumLineSegments** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt,  ///< Number of elements being requested
         [out] ILineSegment2d** rgelt,  ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for objects representing a collection of ILineSegment2d objects
   [
       object,
       uuid(43D1CADC-0D31-4C0D-868F-F890B3C09AD2),
       oleautomation,
	   helpcontext(IDH_LineSegmentCollection),
       helpstring("ILineSegmentCollection Interface"),
       pointer_default(unique)
   ]
   interface ILineSegmentCollection : IUnknown
   {
      /// Gets an item from the collection using its identifier.
      [propget, helpstring("property Item"),helpcontext(IDH_LineSegmentCollection_Item)] HRESULT Item([in] CogoObjectID id, [out, retval] ILineSegment2d* *pVal);

      /// Replaces an item in the collection
      [propputref, helpstring("property Item"),helpcontext(IDH_LineSegmentCollection_Item)] HRESULT Item([in] CogoObjectID id, [in] ILineSegment2d* newVal);

      /// Returns the number of items in the collection.
      [propget, helpstring("property Count"),helpcontext(IDH_LineSegmentCollection_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a line segment to the collection. The new line segments object is created with the ILineSegment2dFactory object associated with this collection.
       [helpstring("method Add"),helpcontext(IDH_LineSegmentCollection_Add)] HRESULT Add(
          [in] CogoObjectID id, ///< Unique identifier for the line segment
          [in] IPoint2d* start, ///< Point at start of line segment
          [in] IPoint2d* end, ///< Point at end of line segment
          [out,retval]ILineSegment2d* *ls ///< The new line segment object
       );

       /// Adds a line segment object to the collection.
       [helpstring("method AddEx"),helpcontext(IDH_LineSegmentCollection_AddEx)] HRESULT AddEx(
          [in] CogoObjectID id, ///< Unique identifier for the line segment
          [in] ILineSegment2d* newVal ///< The line segment
       );

       /// Removes a line segment from the collection
       [helpstring("method Remove"),helpcontext(IDH_LineSegmentCollection_Remove)] 
       HRESULT Remove(
          [in] CogoObjectID id ///< The line segment identifier
       );

       /// Removes all items from the collection
       [helpstring("method Clear"),helpcontext(IDH_LineSegmentCollection_Clear)] HRESULT Clear();

       /// Searches the collection for a line segment and returns its identifier
       [helpstring("method FindID"),helpcontext(IDH_LineSegmentCollection_FindID)] 
       HRESULT FindID(
          [in] ILineSegment2d* ls, ///< The line segment
          [out,retval]CogoObjectID* ID ///< Identifier of the lie segment
       );
     
     /// A factory object used to create new LineSegment2d objects
     [propget, helpstring("property Factory"),helpcontext(IDH_LineSegmentCollection_Factory)] HRESULT Factory([out,retval] ILineSegment2dFactory** factory);
	   [propputref, helpstring("property Factory"),helpcontext(IDH_LineSegmentCollection_Factory)] HRESULT Factory([in] ILineSegment2dFactory* factory);

      /// Returns the ID at a specific location in the collection
      [helpstring("method ID"),helpcontext(IDH_LineSegmentCollection_ID)] HRESULT ID([in] CollectionIndexType index,[out,retval] CogoObjectID* ID);

      /// Clones the collection making a copy of all the contained objects
      [helpstring("method Clone"), helpcontext(IDH_LineSegmentCollection_Clone)] HRESULT Clone([out, retval] ILineSegmentCollection* *clone);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")]  HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumIDs interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumIDs"), helpcontext(IDH_LineSegmentCollection__EnumIDs)] HRESULT _EnumIDs([out, retval] IEnumIDs** ppenum);

      /// Returns an IEnumLineSegment2d interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget,restricted,helpstring("property _EnumLineSegments"),helpcontext(IDH_LineSegmentCollection__EnumLineSegments)] HRESULT _EnumLineSegments([out,retval] IEnumLineSegments** ppenum);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };


   /// Callback interface for ILineSegmentCollection events
   [
       object,
       uuid(99FA2E81-A3FB-4b10-A9A6-FB1F4F6CDE75),
       oleautomation,
	   helpcontext(IDH_LineSegmentCollection),
       helpstring("ILineSegmentCollectionEvents Interface"),
       pointer_default(unique)
   ]
   interface ILineSegmentCollectionEvents : IUnknown
   {
      /// Called after a line segment is changed
       [helpstring("event OnLineSegmentChanged"),helpcontext(IDH_LineSegmentCollection_OnLineSegmentChanged)] 
       HRESULT OnLineSegmentChanged(
          [in] CogoObjectID id, ///< Line Segment ID
          [in] ILineSegment2d* lineSeg ///< The line segment
       );

       /// Called after a line segment is added
       [helpstring("event OnLineSegmentAdded"),helpcontext(IDH_LineSegmentCollection_OnLineSegmentAdded)] 
       HRESULT OnLineSegmentAdded(
          [in] CogoObjectID id, ///< Line Segment ID
          [in] ILineSegment2d* lineSeg ///< The line segment
       );

       /// Called after a line segment is removed
       [helpstring("event OnLineSegmentRemoved"),helpcontext(IDH_LineSegmentCollection_OnLineSegmentRemoved)] 
       HRESULT OnLineSegmentRemoved(
          [in] CogoObjectID id ///< Line Segment ID
       );

       /// Called when the collection is cleared
       [helpstring("event OnLineSegmentsCleared"),helpcontext(IDH_LineSegmentCollection_OnLineSegmentsCleared)] HRESULT OnLineSegmentsCleared();
   };

   /// Interface for objects that represent a Station.
	[
		object,
		uuid(337799AD-766C-4FB7-A238-9A4C61FFBE29),
		oleautomation,
      helpcontext(IDH_Station),
		helpstring("IStation Interface"),
		pointer_default(unique)
	]
	interface IStation : IUnknown
	{
      /// Initializes the station object using a variant.
      ///
      /// The variant can be:
      /// * an IUnknown or IDispatch pointer for an object implementing the IStation interface.
      /// * a floating point value
      /// * a string such as 5+01.25. The string is first intrepreted as being in US format, then SI format.
      [helpstring("method FromVariant")] HRESULT FromVariant([in] VARIANT varStation);

      /// The station zone index property.
      ///
      /// This property relates this station to a zone in a StationEquation object. A value of INVALID_INDEX means the station is not related to a StationEquation.
		[propget, helpstring("property StationZoneIndex"), helpcontext(IDH_Station_StationZoneIndex)] HRESULT StationZoneIndex([out, retval] ZoneIndexType *pVal);
		[propput, helpstring("property StationZoneIndex"), helpcontext(IDH_Station_StationZoneIndex)] HRESULT StationZoneIndex([in] ZoneIndexType newVal);

      /// Value of the station
		[propget, helpstring("property Value"), helpcontext(IDH_Station_Value)] HRESULT Value([out, retval] Float64 *pVal);
		[propput, helpstring("property Value"), helpcontext(IDH_Station_Value)] HRESULT Value([in] Float64 newVal);

      /// Offsets the station
      [helpstring("method Offset")] HRESULT Offset([in]Float64 offset);

      /// Gets the station zone and value.
      [helpstring("method GetStation")] HRESULT GetStation([out]ZoneIndexType* pZoneIdx,[out]Float64* pStation);

      /// Sets the station zone and value.
      [helpstring("method SetStation")] HRESULT SetStation([in]ZoneIndexType zoneIdx,[in]Float64 station);

      /// Returns the station value normalized to the start of an alignment.
      [propget,helpstring("property NormalizedValue")] HRESULT NormalizedValue([in]IAlignment* pAlignment,[out,retval]Float64* pValue);

      /// Initializes the station object with a string
      [helpstring("method FromString"), helpcontext(IDH_Station_FromString)] HRESULT FromString([in] BSTR station,[in] UnitModeType unitMode);

      /// Returns a string reprsentation of the station.
      [helpstring("method AsString"), helpcontext(IDH_Station_AsString)] HRESULT AsString(
         [in] UnitModeType unitMode, ///< Unit format for the station. A unit conversion is not performed.
         [in] VARIANT_BOOL vbIncludeStationZone,  ///< Indicates if the station zone should be appended to the string. e.g. 5+01.23,2 The trailing ,2 indicates station zone 2
         [out,retval] BSTR* station ///< The string
      );

      /// Creates a copy of the object
      [helpstring("method Clone"), helpcontext(IDH_Station_Clone)] HRESULT Clone([out,retval] IStation* *clone);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for station events
	[
		object,
		uuid(6FA473B2-94F8-4b46-9E28-1E05C17BFE79),
		oleautomation,
      helpcontext(IDH_Station),
		helpstring("IStationEvents Interface"),
		pointer_default(unique)
	]
	interface IStationEvents : IUnknown
   {
      /// Called after a station is changed
       [helpstring("event OnStationChanged"),helpcontext(IDH_Station_OnStationChanged)] 
       HRESULT OnStationChanged(
          [in]ZoneIndexType zoneIdx, ///< The station zone
          [in]Float64 station ///< The station
       );
   };

   /// Interface for objects that define a station equation. StationEquation objects must be created in a StationEquationCollection.
   ///
   /// A station equation is used when the stationing along an alignment is discontinuous. Station equations resolve overlapping or gaps in stationing.
   /// This might occur when an alignment is re-routed making it longer or shorter than the original. 
   /// A station equation is used to define the stationing back and ahead of the point where the original and new stationing no longer match.
   /// Stationing zones are the ranges of stationing between station equations. 
   /// Station objects are defined with respect to the zone where they are located. 
   [
      object,
      uuid(F3EE95F1-C4B9-4c9b-9B44-17DC06F7444A),
      oleautomation,
      helpcontext(IDH_StationEquation),
      helpstring("IStationEquation Interface"),
      pointer_default(unique)
   ]
   interface IStationEquation : IUnknown
   {
      /// Gets the back and ahead stations at the equation point.
      [helpstring("method GetEquation"),helpcontext(IDH_StationEquation_GetEquation)] HRESULT GetEquation([out]Float64* pBackStation,[out]Float64* pAheadStation);

      /// Returns the back station.
      [propget,helpstring("property Back"),helpcontext(IDH_StationEquation_Back)] HRESULT Back([out,retval]Float64* pBack);

      /// Returns the ahead station.
      [propget,helpstring("property Ahead"),helpcontext(IDH_StationEquation_Ahead)] HRESULT Ahead([out,retval]Float64* pAhead);

      /// Returns the station at this equation point, normalized to the start of the associated alignment
      [propget,helpstring("property NormalizedValue"),helpcontext(IDH_StationEquation_NormalizedValue)] HRESULT NormalizedValue([out,retval]Float64* pNormalizedValue);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Interface used to enumerate values in a container 
	[
	   object,
	   uuid(90A4A76D-EE9D-46c3-8FC6-17786B062164),
	   helpstring("IEnumStationEquations Interface"),
	   //helpcontext(IDH_IEnumProfilePoints),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumStationEquations : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumStationEquations** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt,  ///< Number of elements being requested
         [out] IStationEquation** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// Interface for defining collection of objects that implement the IStationEquation interface.
   [
       object,
       uuid(DA2874E5-2A2E-439f-B35A-708863DA91E6),
       oleautomation,
	   helpcontext(IDH_StationEquationCollection),
       helpstring("IStationEquationCollection Interface"),
       pointer_default(unique)
   ]
   interface IStationEquationCollection : IUnknown
   {
      /// Returns the alignment object associated with the station equations
      [propget,helpstring("property Alignment")] HRESULT Alignment([out,retval]IAlignment** ppAlignment);

      /// Gets an item from the collection
      [propget, helpstring("property Item"),helpcontext(IDH_StationEquationCollection_Item)] HRESULT Item([in] CollectionIndexType idx, [out, retval] IStationEquation* *pVal);

      /// Returns the number of items in the collection.
      [propget, helpstring("property Count"),helpcontext(IDH_StationEquationCollection_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Creates a new StationEquation in the collection.
       [helpstring("method Add"),helpcontext(IDH_StationEquationCollection_Add)] 
       HRESULT Add(
          [in] Float64 back, ///< The back station
          [in] Float64 ahead, ///< The ahead station
          [out,retval]IStationEquation* *pp ///< The new station object
       );

       /// Removes a StationEquation from the collection
       [helpstring("method Remove"),helpcontext(IDH_StationEquationCollection_Remove)] HRESULT Remove([in] CollectionIndexType idx);

       /// Removes all items from the collection.
       [helpstring("method Clear"),helpcontext(IDH_StationEquationCollection_Clear)] HRESULT Clear();

       /// Returns the distance between two stations.
     [helpstring("method Distance")] HRESULT Distance([in]VARIANT varStation1,[in]VARIANT varStation2,[out,retval]Float64* pDist);

     /// Creates a new station that is offset from the specified value. The new station is defined relative to its preceeding station equation.
     [helpstring("method Increment")] HRESULT Increment([in]VARIANT varStation,[in] Float64 value,[out,retval]IStation** station);

     /// Moves a station by a specified offset. The resulting station is defined relative to its preceeding station equation.
     [helpstring("method IncrementBy")] HRESULT IncrementBy([in]IStation* station,[in] Float64 value);

     /// Converts a station relative to a station equation to a station normalized to the associated alignment.
     [helpstring("method ConvertToNormalizedStation")] HRESULT ConvertToNormalizedStation([in] VARIANT varStation,[out,retval] Float64* station);

     /// Converts a station relative to a station equation to a station normalized to the associated alignment.
     [helpstring("method ConvertToNormalizedStationEx")] HRESULT ConvertToNormalizedStationEx([in] VARIANT varStation,[out,retval] IStation** station);

     /// Converts a station that is normalized to the associated alignment to a station relative to a station equation.
     [helpstring("method ConvertFromNormalizedStation")] HRESULT ConvertFromNormalizedStation([in] Float64 normalizedStation,[out,retval] IStation** station);

     /// Converts a station that is normalized to the associated alignment to a station relative to a station equation.
     [helpstring("method ConvertFromNormalizedStationEx")] HRESULT ConvertFromNormalizedStationEx([in] VARIANT varStation,[out,retval] IStation** station);


     /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
     [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

     /// Returns an IEnumStationEquations interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
     [propget, restricted, helpstring("property _EnumStationEquations"), helpcontext(IDH_StationEquationCollection__EnumStationEquations)] HRESULT _EnumStationEquations([out, retval] IEnumStationEquations** ppenum);
     
     /// The StructuredStorage property.
     [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interfaoce for IStationEquationCollection events
   [
       object,
       uuid(459B10C5-0C87-4db8-9C2C-2AC15DD03A90),
       oleautomation,
	   helpcontext(IDH_StationEquationCollection),
       helpstring("IStationEquationCollectionEvents Interface"),
       pointer_default(unique)
   ]
   interface IStationEquationCollectionEvents : IUnknown
   {
      /// Called after a station equation is added to the collection
       [helpstring("event OnEquationAdded"),helpcontext(IDH_StationEquationCollection_OnEquationAdded)] 
       HRESULT OnEquationAdded(
          [in] CollectionIndexType idx, ///< Index in the collection
          [in] IStationEquation* pp ///< The new station equation
       );
       
       /// Called after a station equation is removed from the collection.
       [helpstring("event OnEquationRemoved"),helpcontext(IDH_StationEquationCollection_OnEquationRemoved)] 
       HRESULT OnEquationRemoved(
          [in] CollectionIndexType idx ///< Index of the station equation before removal
       );
       
       /// Called when the collection is cleared.
       [helpstring("event OnEquationsCleared"),helpcontext(IDH_StationEquationCollection_OnEquationsCleared)] HRESULT OnEquationsCleared();
  };

   /// Interface for objects that represent a point in a vertical profile.
   ///
   /// A profile point is defined by its station and elevation.
   [
       object,
       uuid(2D5F25CA-875B-484F-B4D0-AB02B0522EC2),
       oleautomation,
	   helpcontext(IDH_ProfilePoint),
       helpstring("IProfilePoint Interface"),
       pointer_default(unique)
   ]
   interface IProfilePoint : IUnknown
   {
      /// The associated Profile
       [propget, helpstring("property Profile"), helpcontext(IDH_ProfilePoint_Profile)] HRESULT Profile([out, retval] IProfile* *pVal);
       [propputref, helpstring("property Profile"), helpcontext(IDH_ProfilePoint_Profile)] HRESULT Profile([in] IProfile* newVal);

       /// The station
       [propget, helpstring("property Station"),helpcontext(IDH_ProfilePoint_Station)] HRESULT Station([out, retval] IStation* *station);
       [propput, helpstring("property Station"),helpcontext(IDH_ProfilePoint_Station)] HRESULT Station([in] VARIANT varStation);

       /// The elevation.
       [propget, helpstring("property Elevation"),helpcontext(IDH_ProfilePoint_Elevation)] HRESULT Elevation([out, retval] Float64 *pVal);
       [propput, helpstring("property Elevation"),helpcontext(IDH_ProfilePoint_Elevation)] HRESULT Elevation([in] Float64 newVal);

       /// Creates a clone
       [helpstring("method Clone"),helpcontext(IDH_ProfilePoint_Clone)] HRESULT Clone([out,retval] IProfilePoint* *clone);

       /// The StructuredStorage property.
        [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for ProfilePoint events
   [
       object,
       uuid(E4FDF7A1-F29D-4e44-812F-8401A67E5B09),
       oleautomation,
	   helpcontext(IDH_ProfilePoint),
       helpstring("IProfilePointEvents Interface"),
       pointer_default(unique)
   ]
   interface IProfilePointEvents : IUnknown
   {
      /// Called after a ProfilePoint is changed
     [helpstring("event OnProfilePointChanged"),helpcontext(IDH_ProfilePoint_OnProfilePointChanged)] 
     HRESULT OnProfilePointChanged(
        [in]IProfilePoint* pp ///< The ProfilePoint
     );
   };


   /// Interface used to enumerate values in a container
   [
	   object,
	   uuid(E669818B-B0E6-4fda-9255-49FDAF56114E),
	   helpstring("IEnumProfilePoints Interface"),
	   //helpcontext(IDH_IEnumProfilePoints),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumProfilePoints : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumProfilePoints** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt,  ///< Number of elements being requested
         [out] IProfilePoint** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// Interface for objects that create ProfilePoint objects
	[
		object,
		uuid(FAC877F3-A85A-4490-AC53-5F7BB80A1A6A),
		oleautomation,
		helpcontext(IDH_ProfilePointFactory),
		helpstring("IProfilePointFactory Interface"),
		pointer_default(unique)
	]
	interface IProfilePointFactory : IUnknown
	{
      /// The Profile object that will be associated with new ProfilePoint
       [propget, helpstring("property Profile"), helpcontext(IDH_ProfilePointFactory_Profile)] HRESULT Profile([out, retval] IProfile* *pVal);
       [propputref, helpstring("property Profile"), helpcontext(IDH_ProfilePointFactory_Profile)] HRESULT Profile([in] IProfile* newVal);

       /// Returns a new ProfilePoint. The caller must set the station and elevation.
		[helpstring("method CreateProfilePoint"), helpcontext(IDH_ProfilePointFactory_CreateProfilePoint)] HRESULT CreateProfilePoint([out,retval]IProfilePoint* *pVal);
      
      /// The StructuredStorage property
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Interface for defining a collection of objects implementing the IProfilePoint interface.
   [
       object,
       uuid(11B1FEE8-8CC2-42BC-B9DE-940EE6B16BA1),
       oleautomation,
	   helpcontext(IDH_ProfilePointCollection),
       helpstring("IProfilePointCollection Interface"),
       pointer_default(unique)
   ]
   interface IProfilePointCollection : IUnknown
   {
      /// Gets an item from the collection using its identifier.
      [propget, helpstring("property Item"),helpcontext(IDH_ProfilePointCollection_Item)] HRESULT Item([in] CogoObjectID id, [out, retval] IProfilePoint* *pVal);
      
      /// Replaces an item in the collection
      [propputref, helpstring("property Item"),helpcontext(IDH_ProfilePointCollection_Item)] HRESULT Item([in] CogoObjectID id, [in] IProfilePoint* newVal);

      /// Returns the number of items in the collection.
      [propget, helpstring("property Count"),helpcontext(IDH_ProfilePointCollection_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a profile point to the collection. The new profile point object is created with the IProfilePointFactory object associated with this collection.
      [helpstring("method Add"),helpcontext(IDH_ProfilePointCollection_Add)] HRESULT Add(
         [in] CogoObjectID id, ///< Unique identifier for the profile point
         [in] VARIANT varStation, ///< Station
         [in] Float64 elevation, ///< Elevation
         [out,retval]IProfilePoint* *pp ///< The new profile point object
      );

      /// Adds a profile point to the collection.
      [helpstring("method AddEx"),helpcontext(IDH_ProfilePointCollection_AddEx)] 
      HRESULT AddEx(
         [in] CogoObjectID id, ///< Unique identifier for the profile point
         [in] IProfilePoint* newVal ///< The profile point
      );

      /// Removes a point from the collection
      [helpstring("method Remove"),helpcontext(IDH_ProfilePointCollection_Remove)] 
      HRESULT Remove(
         [in] CogoObjectID id /// The profile point identifier
      );

      /// Removes all items from the collection
      [helpstring("method Clear"),helpcontext(IDH_ProfilePointCollection_Clear)] HRESULT Clear();

      /// Searches the collection for a profile point and returns its identifier
      [helpstring("method FindID"),helpcontext(IDH_ProfilePointCollection_FindID)] 
      HRESULT FindID(
         [in] IProfilePoint* pp, ///< The profile point
         [out,retval]CogoObjectID* ID ///< The profile point identifier
      );

      /// Returns the ID at a specific location in the collection
      [helpstring("method ID"),helpcontext(IDH_ProfilePointCollection_ID)] HRESULT ID([in] CollectionIndexType index,[out,retval] CogoObjectID* ID);

      /// A factory object used to create new ProfilePointobjects
      [propget,helpstring("property Factory"),helpcontext(IDH_ProfilePointCollection_Factory)] HRESULT Factory([out,retval]IProfilePointFactory* *factory);
		[propputref,helpstring("property Factory"),helpcontext(IDH_ProfilePointCollection_Factory)] HRESULT Factory([in]IProfilePointFactory* factory);

      /// Clones the collection making a copy of all the contained objects
      [helpstring("method Clone"),helpcontext(IDH_ProfilePointCollection_Clone)] HRESULT Clone([out,retval] IProfilePointCollection* *clone);

     /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
     [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);
     
     /// Returns an IEnumIDs interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
     [propget, restricted, helpstring("property _EnumIDs"), helpcontext(IDH_ProfilePointCollection__EnumIDs)] HRESULT _EnumIDs([out, retval] IEnumIDs** ppenum);

     /// Returns an IEnumProfilePoints interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
     [propget, restricted, helpstring("property _EnumProfilePoints"), helpcontext(IDH_ProfilePointCollection__EnumProfilePoints)] HRESULT _EnumProfilePoints([out, retval] IEnumProfilePoints** ppenum);

     /// The StructuredStorage property.
     [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for IProfilePointCollection events
   [
       object,
       uuid(D871C5DE-78F4-487a-9EDD-6F465BF74043),
       oleautomation,
	   helpcontext(IDH_ProfilePointCollection),
       helpstring("IProfilePointCollectionEvents Interface"),
       pointer_default(unique)
   ]
   interface IProfilePointCollectionEvents : IUnknown
   {
      /// Called after a profile point is changed
       [helpstring("event OnProfilePointChanged"),helpcontext(IDH_ProfilePointCollection_OnPointChanged)] 
       HRESULT OnProfilePointChanged(
          [in] CogoObjectID id, ///< Profile point ID
          [in] IProfilePoint* pp ///< The profile point
       );

       /// Called after a profile point is added
       [helpstring("event OnProfilePointAdded"),helpcontext(IDH_ProfilePointCollection_OnPointAdded)] 
       HRESULT OnProfilePointAdded(
          [in] CogoObjectID id, ///< ID of the profile point
          [in] IProfilePoint* pp ///< The profile point
       );

       /// Called after the profile point is removed
       [helpstring("event OnProfilePointRemoved"),helpcontext(IDH_ProfilePointCollection_OnPointRemoved)] 
       HRESULT OnProfilePointRemoved(
          [in] CogoObjectID id ///< The profile point identifier
       );

       /// Called when the collection is cleared
       [helpstring("event OnProfilePointsCleared"),helpcontext(IDH_ProfilePointCollection_OnPointsCleared)] HRESULT OnProfilePointsCleared();
  };

   /// Interface for objects that represent a parabolic vertical curve.
   ///
   /// \image html /VertCurve/VertCurve.png
   /// * PBG = Point on Back Grade
   /// * PFG = Point on Forward Grade
   /// * PVI = Point of Vertical Intersection
   /// * BVC = Begin Vertical Curve
   /// * EVC = End Vertical Curve
   /// * E = Vertical distance from curve to tangent lines
   /// * H = Vertical distance from curve to PVI
   /// * g1 = Entry Grade
   /// * g2 = Exit Grade
   /// * L1 = Entry length
   /// * L2 = Exit Length
   [
       object,
       uuid(E003ECBB-BE61-4CB1-AB4B-819D98B3C45C),
       oleautomation,
	   helpcontext(IDH_VertCurve),
       helpstring("IVertCurve Interface"),
       pointer_default(unique)
   ]
   interface IVertCurve : IUnknown
   {
      /// Property that indicates how the vertical curve is defined.
      ///
      /// If VARIANT_TRUE, PBG, PFG, EntryGrade, and ExitGrade define the curve and L1, L2, and PVI are computed. PBG and PFG are assumed to be
      /// at the same location as the BVC and EVC points. Otherwise, the curve is defined by L1, L2, PBG, PFG, and PVI and BVC, EVC, EntryGrade, and ExitGrade are computed.
      ///
      /// This property is VARIANT_FALSE by default.
      [propget, helpstring("property ComputeFromGradePoints")] HRESULT ComputeFromGradePoints([out,retval]VARIANT_BOOL* pvbCompute);
      [propput, helpstring("property ComputeFromGradePoints")] HRESULT ComputeFromGradePoints([in]VARIANT_BOOL vbCompute);

      /// The associated Profile object
       [propget, helpstring("property Profile"), helpcontext(IDH_VertCurve_Profile)] HRESULT Profile([out, retval] IProfile* *pVal);
       [propputref, helpstring("property Profile"), helpcontext(IDH_VertCurve_Profile)] HRESULT Profile([in] IProfile* newVal);

       /// The point on back grade
       [propget, helpstring("property PBG"), helpcontext(IDH_VertCurve_PBG)] HRESULT PBG([out, retval] IProfilePoint* *pVal);
       [propputref, helpstring("property PBG"), helpcontext(IDH_VertCurve_PBG)] HRESULT PBG([in] IProfilePoint* newVal);

       /// The point of vertical intersection
       [propget, helpstring("property PVI"), helpcontext(IDH_VertCurve_PVI)] HRESULT PVI([out, retval] IProfilePoint* *pVal);
       [propputref, helpstring("property PVI"), helpcontext(IDH_VertCurve_PVI)] HRESULT PVI([in] IProfilePoint* newVal);

       /// The point on forward grade
       [propget, helpstring("property PFG"), helpcontext(IDH_VertCurve_PFG)] HRESULT PFG([out, retval] IProfilePoint* *pVal);
       [propputref, helpstring("property PFG"), helpcontext(IDH_VertCurve_PFG)] HRESULT PFG([in] IProfilePoint* newVal);

       /// The length of the entry half of the curve or the full length of a symmetric curve if L2 is zero
	   [propget, helpstring("property L1"), helpcontext(IDH_VertCurve_L1)] HRESULT L1([out,retval] Float64* pVal);
	   [propput, helpstring("property L1"), helpcontext(IDH_VertCurve_L1)] HRESULT L1([in] Float64 newVal);

      /// The length of the exit half of the curve. When zero, L1 is the full length of a symmetric curve.
	   [propget, helpstring("property L2"), helpcontext(IDH_VertCurve_L2)] HRESULT L2([out,retval] Float64* pVal);
	   [propput, helpstring("property L2"), helpcontext(IDH_VertCurve_L2)] HRESULT L2([in] Float64 newVal);

      /// The begin vertical curve point
       [propget, helpstring("property BVC"), helpcontext(IDH_VertCurve_BVC)] HRESULT BVC([out, retval] IProfilePoint* *pVal);

       /// The end vertical curve point
       [propget, helpstring("property EVC"), helpcontext(IDH_VertCurve_EVC)] HRESULT EVC([out, retval] IProfilePoint* *pVal);

       /// The total length of the vertical curve
       [propget, helpstring("property Length"), helpcontext(IDH_VertCurve_Length)] HRESULT Length([out, retval] Float64 *pVal);
       
       /// Profile grade entering the curve
       [propput, helpstring("property EntryGrade"), helpcontext(IDH_VertCurve_EntryGrade)] HRESULT EntryGrade([in] Float64 pVal);
       [propget, helpstring("property EntryGrade"), helpcontext(IDH_VertCurve_EntryGrade)] HRESULT EntryGrade([out, retval] Float64 *pVal);

       /// Profile grade exiting the curve
       [propput, helpstring("property ExitGrade"), helpcontext(IDH_VertCurve_ExitGrade)] HRESULT ExitGrade([in] Float64 pVal);
       [propget, helpstring("property ExitGrade"), helpcontext(IDH_VertCurve_ExitGrade)] HRESULT ExitGrade([out, retval] Float64 *pVal);

       /// The lowest point in the vertical curve. The lowest point can occur at the start or end of the curve.
       [propget, helpstring("property LowPoint"), helpcontext(IDH_VertCurve_LowPoint)] HRESULT LowPoint([out, retval] IProfilePoint* *pVal);

       /// The highest point in the vertical curve. The highest point can occur at the start or end of the curve.
       [propget, helpstring("property HighPoint"), helpcontext(IDH_VertCurve_HighPoint)] HRESULT HighPoint([out, retval] IProfilePoint* *pVal);

       /// Computes the profile elevation at the specified station
       [helpstring("method Elevation"), helpcontext(IDH_VertCurve_Elevation)] HRESULT Elevation([in] VARIANT varStation,[out,retval] Float64* elev);

       /// Computes the profile grade at the specified station
       [helpstring("method Grade"), helpcontext(IDH_VertCurve_Grade)] HRESULT Grade([in] VARIANT varStation,[out,retval]Float64* grade);

       /// Factory for creating ProfilePoint objects
	   [propget, helpstring("method ProfilePointFactory"), helpcontext(IDH_VertCurve_ProfilePointFactory)] HRESULT ProfilePointFactory([out,retval]IProfilePointFactory* *factory);
	   [propputref, helpstring("method ProfilePointFactory"), helpcontext(IDH_VertCurve_ProfilePointFactory)] HRESULT ProfilePointFactory([in]IProfilePointFactory* factory);

      /// Creates a copy of the curve
      [helpstring("method Clone"), helpcontext(IDH_VertCurve_Clone)] HRESULT Clone([out,retval] IVertCurve* *clone);

      /// Algebraic difference in gradients
      ///
      /// \f$ A = g_2 - g_1 \f$
	  [propget, helpstring("property A"), helpcontext(IDH_VertCurve_A)] HRESULT A([out,retval]Float64* a);

     /// Vertical curve constant. This is the second derivative of the curve equation and represents the rate of change of the profile grade.
     /// 
     /// \f$ K = \frac{A}{2L} \f$
	  [propget, helpstring("property K"), helpcontext(IDH_VertCurve_K)] HRESULT K([out,retval]Float64* k);

     /// Vertical distance from the curve to the VPI. 
     ///
     /// \f$ H = \frac{L_1 L_2 A}{2(L_1 + L_2)} \f$
	  [propget, helpstring("property H"), helpcontext(IDH_VertCurve_H)] HRESULT H([out,retval]Float64* h);

     /// Vertical distance at any point on the curve to the tangent grade. 
     ///
     /// \f$ t < L_1, E = H \left(\frac{t}{L_1} \right)^2 \f$, otherwise \f$ E = H \left( \frac{L-t}{L_2} \right)^2 \f$
     [propget, helpstring("property E"), helpcontext(IDH_VertCurve_E)] HRESULT E([in]Float64 t,[out,retval]Float64* e);

     /// The StructuredStorage property
        [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for VertCurve events
   [
       object,
       uuid(AD7A94E4-D030-42a0-8E6F-9CFEC582904C),
       oleautomation,
	   helpcontext(IDH_VertCurve),
       helpstring("IVertCurveEvents Interface"),
       pointer_default(unique)
   ]
   interface IVertCurveEvents : IUnknown
   {
      /// Called after a VertCurve is changed
     [helpstring("event OnVertCurveChanged"),helpcontext(IDH_VertCurve_OnVertCurveChanged)] 
     HRESULT OnVertCurveChanged(
        [in]IVertCurve* vc ///< The vertical curve
     );
  };

   /// Interface for objects that enumerate a collection of IVertCurve objects
   [
      object,
	  uuid(57A68B13-5FEA-4b47-8211-6E58B0FF7B4E),
	  helpstring("IEnumVertCurves Interface"),
	  oleautomation,
      hidden,restricted,
	  pointer_default(unique)
   ]
   interface IEnumVertCurves : IUnknown
   {
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out]IEnumVertCurves** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
      HRESULT Next(
         [in]ULONG celt, ///< Number of elements being requested
         [out]IVertCurve** rgelt,  ///< Array of size celt (or larger) of elements of interest
         [out]ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();

      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
      HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
   };

   /// Interface for objects that create VertCurve objects
   [
		object,
		uuid(3B173FA0-A475-4120-9FEB-2C1CE5FE2013),
		oleautomation,
		helpcontext(IDH_VertCurveFactory),
		helpstring("IVertCurveFactory Interface"),
		pointer_default(unique)
	]
	interface IVertCurveFactory : IUnknown
	{
      /// Creates a new VertCurve object. The caller must define the curve parameters.
		[helpstring("method CreateVertCurve"), helpcontext(IDH_VertCurveFactory_CreateVertCurve)] HRESULT CreateVertCurve([out,retval] IVertCurve* *pVal);

      /// The StructuredStorage property
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Interface for defining a collection of objects implementing the IVertCurve interface.
   [
       object,
       uuid(A6B519EB-8B34-4F34-842C-FA1912132199),
       oleautomation,
	   helpcontext(IDH_VertCurveCollection),
       helpstring("IVertCurveCollection Interface"),
       pointer_default(unique)
   ]
   interface IVertCurveCollection : IUnknown
   {
      /// Gets an item from the collection using its identifier.
      [propget, helpstring("property Item"), helpcontext(IDH_VertCurveCollection_Item)] HRESULT Item([in] CogoObjectID id, [out, retval] IVertCurve* *pVal);
      
      /// Replaces an item in the collection
      [propputref, helpstring("property Item"), helpcontext(IDH_VertCurveCollection_Item)] HRESULT Item([in] CogoObjectID id, [in] IVertCurve* newVal);

      /// Returns the number of items in the collection.
      [propget, helpstring("property Count"), helpcontext(IDH_VertCurveCollection_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a vertical curve to the collection. The new vertical curve object is created with the IVertCurveFactory object associated with this collection.
      [helpstring("method Add"), helpcontext(IDH_VertCurveCollection_Add)] HRESULT Add(
         [in] CogoObjectID id, ///< Unique identifier for the vertical curve
         [in] IProfilePoint* pbg, ///< A point on the back grade
         [in] IProfilePoint* pvi,  ///< The point of vertical intersection
         [in] IProfilePoint* pfg, ///< A point on the forward grade
         [in]Float64 l1, ///< The length of the entry half of the curve or the full length of a symmetric curve when l2 is zero
         [in] Float64 l2, ///< The length of the exit half of the curve. If zero, l1 is the full length of a symmetric curve.
         [out,retval]IVertCurve* *vc ///< The new vertical curve
      );

      /// Adds a vertical curve to the collection.
      [helpstring("method AddEx"), helpcontext(IDH_VertCurveCollection_AddEx)] HRESULT AddEx(
         [in] CogoObjectID id, ///< Unique identifier for the vertical curve
         [in] IVertCurve* newVal ///< A vertical curve object
      );

      /// Removes a vertical curve from the collection
      [helpstring("method Remove"), helpcontext(IDH_VertCurveCollection_Remove)] HRESULT Remove([in] CogoObjectID id);

      /// Removes all items from the collection
      [helpstring("method Clear"), helpcontext(IDH_VertCurveCollection_Clear)] HRESULT Clear();

      /// Searches the collection for a vertical curve and returns its identifier
      [helpstring("method FindID"), helpcontext(IDH_VertCurveCollection_FindID)] HRESULT FindID([in] IVertCurve* vc,[out,retval]CogoObjectID* ID);
      
      /// Returns the ID at a specific location in the collection
      [helpstring("method ID"), helpcontext(IDH_VertCurveCollection_ID)] HRESULT ID([in] CollectionIndexType index,[out,retval] CogoObjectID* ID);

      /// A factory object used to create new VertCurve objects
      [propputref,helpstring("property Factory"), helpcontext(IDH_VertCurveCollection_Factory)] HRESULT Factory([in]IVertCurveFactory* factory);
	   [propget,helpstring("property Factory"), helpcontext(IDH_VertCurveCollection_Factory)] HRESULT Factory([out,retval]IVertCurveFactory* *factory);

      /// Clones the collection making a copy of all the contained objects
      [helpstring("method Clone"), helpcontext(IDH_VertCurveCollection_Clone)] HRESULT Clone([out,retval] IVertCurveCollection* *clone);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumIDs interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumIDs"), helpcontext(IDH_VertCurveCollection__EnumIDs)] HRESULT _EnumIDs([out, retval] IEnumIDs** ppenum);

      /// Returns an IEnumVertCurves interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumVertCurves"), helpcontext(IDH_VertCurveCollection__EnumVertCurves)] HRESULT _EnumVertCurves([out, retval] IEnumVertCurves** ppenum);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for IVertCurveCollection events
   [
       object,
       uuid(EBD26472-9710-4c00-B1D4-88F5AE075B8D),
       oleautomation,
	   helpcontext(IDH_VertCurveCollection),
       helpstring("IVertCurveCollection Interface"),
       pointer_default(unique)
   ]
   interface IVertCurveCollectionEvents : IUnknown
   {
      /// Called after a vertical curve is changed
      [helpstring("event OnVertCurveChanged"), helpcontext(IDH_VertCurveCollection_OnVertCurveChanged)] 
      HRESULT OnVertCurveChanged(
         [in] CogoObjectID id, ///< Vertical curve ID
         [in] IVertCurve* vc ///< The vertical curve
      );

      /// Called after a vertical curve is added
      [helpstring("event OnVertCurveAdded"), helpcontext(IDH_VertCurveCollection_OnVertCurveAdded)] 
      HRESULT OnVertCurveAdded(
         [in] CogoObjectID id, ///< Vertical curve ID
         [in] IVertCurve* vc ///< The vertical curve
      );

      /// Called after a vertical curve is removed
      [helpstring("event OnVertCurveRemoved"), helpcontext(IDH_VertCurveCollection_OnVertCurveRemoved)] 
      HRESULT OnVertCurveRemoved(
         [in] CogoObjectID id ///< Vertical curve ID
      );

      /// Called when the collection is cleared
      [helpstring("event OnVertCurvesCleared"), helpcontext(IDH_VertCurveCollection_OnVertCurvesCleared)] HRESULT OnVertCurvesCleared();
   };
	
   /// Interface for objects that enumerate a collection of IHorzCurve objects
   [
	   object,
	   uuid(2317EF09-E0F5-49fe-B6BC-14A21A59EBAC),
	   helpstring("IEnumHorzCurves Interface"),
	   //helpcontext(IDH_IEnumHorzCurves),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumHorzCurves : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumHorzCurves** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt,   ///< Number of elements being requested
         [out] IHorzCurve** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for objects that create HorzCurve objects
   [
		object,
		uuid(6C9AFFCA-DC58-4EA5-8FE6-A249CFED06BA),
		oleautomation,
		helpcontext(IDH_HorzCurveFactory),
		helpstring("IHorzCurveFactory Interface"),
		pointer_default(unique)
	]
	interface IHorzCurveFactory : IUnknown
	{
      /// Returns a new HorzCurve object. The caller must define the curve parameters.
      [helpstring("method CreateHorzCurve"), helpcontext(IDH_HorzCurveFactory_CreateHorzCurve)] HRESULT CreateHorzCurve([out,retval] IHorzCurve* *pVal);

      /// The StructuredStorage property
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Interface for defining a collection of objects implementing the IHorzCurve interface.
   [
		object,
		uuid(2436697B-4DE1-40A1-B087-89AA074F1C2C),
		oleautomation,
		helpcontext(IDH_HorzCurveCollection),
		helpstring("IHorzCurveCollection Interface"),
		pointer_default(unique)
	]
	interface IHorzCurveCollection : IUnknown
	{
      /// Gets an item from the collection using its identifier.
      [propget, helpstring("property Item"), helpcontext(IDH_HorzCurveCollection_Item)] HRESULT Item([in] CogoObjectID id, [out, retval] IHorzCurve* *pVal);

      /// Replaces an item in the collection
      [propputref, helpstring("property Item"), helpcontext(IDH_HorzCurveCollection_Item)] HRESULT Item([in] CogoObjectID id, [in] IHorzCurve* newVal);

      /// Returns the number of items in the collection.
      [propget, helpstring("property Count"), helpcontext(IDH_HorzCurveCollection_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a horizontal curve to the collection. The new horizontal curve object is created with the IHorzCurveFactory object associated with this collection.
      [helpstring("method Add"), helpcontext(IDH_HorzCurveCollection_Add)] HRESULT Add(
         [in] CogoObjectID id, ///< Unique identifier for the horizontal curve
         [in] IPoint2d* pbt,///< A point on the back tangent
         [in] IPoint2d* pi, ///< The point of intersection
         [in] IPoint2d* pft, ///< A point on the forward tangent
         [in] Float64 radius, ///< The radius of the circular curve
         [in] Float64 Ls1, ///< The entry spiral length
         [in] Float64 Ls2, ///< The exit spiral length
         [out,retval]IHorzCurve** hc ///< The new horizontal curve
      );

      /// Adds a horizontal curve to the collection.
      [helpstring("method AddEx"), helpcontext(IDH_HorzCurveCollection_AddEx)] HRESULT AddEx(
         [in] CogoObjectID id, ///< Unique identifier for the horizontal curve
         [in] IHorzCurve* newVal ///< A horizontal curve object
      );

      /// Removes a vertical curve from the collection
      [helpstring("method Remove"), helpcontext(IDH_HorzCurveCollection_Remove)] HRESULT Remove([in] CogoObjectID id);

      /// Removes all items from the collection
      [helpstring("method Clear"), helpcontext(IDH_HorzCurveCollection_Clear)] HRESULT Clear();

      /// Searches the collection for a horizontal curve and returns its identifier
      [helpstring("method FindID"), helpcontext(IDH_HorzCurveCollection_FindID)] HRESULT FindID([in] IHorzCurve* hc,[out,retval]CogoObjectID* ID);

      /// Returns the ID at a specific location in the collection
      [helpstring("method ID"), helpcontext(IDH_HorzCurveCollection_ID)] HRESULT ID([in] CollectionIndexType index, [out, retval] CogoObjectID* ID);

      /// A factory object used to create new HorzCurve objects
      [propget, helpstring("method Factory"), helpcontext(IDH_HorzCurveCollection_Factory)] HRESULT Factory([out,retval]IHorzCurveFactory** factory);
		[propputref, helpstring("method Factory"), helpcontext(IDH_HorzCurveCollection_Factory)] HRESULT Factory([in]IHorzCurveFactory* factory);

      /// Clones the collection making a copy of all the contained objects
      [helpstring("method Clone"), helpcontext(IDH_HorzCurveCollection_Clone)] HRESULT Clone([out,retval] IHorzCurveCollection* *clone);

        /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
        [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

        /// Returns an IEnumIDs interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
        [propget, restricted, helpstring("property _EnumIDs"), helpcontext(IDH_HorzCurveCollection__EnumIDs)] HRESULT _EnumIDs([out, retval] IEnumIDs** ppenum);

        /// Returns an IEnumHorzCurves interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
        [propget, restricted, helpstring("property _EnumHorzCurves"), helpcontext(IDH_HorzCurveCollection__EnumHorzCurves)] HRESULT _EnumHorzCurves([out, retval] IEnumHorzCurves** ppenum);

        /// The StructuredStorage property.
        [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for IHorzCurveCollection events
   [
		object,
		uuid(7322B2AD-A63B-4348-854C-ED1130B7EB49),
		oleautomation,
		helpcontext(IDH_HorzCurveCollection),
		helpstring("IHorzCurveCollectionEvents Interface"),
		pointer_default(unique)
	]
	interface IHorzCurveCollectionEvents : IUnknown
   {
      /// Called after a horizontal curve is changed
      [helpstring("event OnHorzCurveChanged"), helpcontext(IDH_HorzCurveCollection_OnHorzCurveChanged)] 
      HRESULT OnHorzCurveChanged(
         [in] CogoObjectID id, ///< Horizontal curve ID
         [in] IHorzCurve* hc ///< The horizontal curve
      );

      /// Called after a horizontal curve is added
      [helpstring("event OnHorzCurveAdded"), helpcontext(IDH_HorzCurveCollection_OnHorzCurveAdded)] 
      HRESULT OnHorzCurveAdded(
         [in] CogoObjectID id, ///< Horizontal curve ID
         [in] IHorzCurve* hc ///< The horizontal curve
      );

      /// Called after a horizontal curve is removed
      [helpstring("event OnHorzCurveRemoved"), helpcontext(IDH_HorzCurveCollection_OnHorzCurveRemoved)] 
      HRESULT OnHorzCurveRemoved(
         [in] CogoObjectID id ///< Horizontal curve ID
      );

      /// Called when the collection is cleared
      [helpstring("event OnHorzCurvesCleared"), helpcontext(IDH_HorzCurveCollection_OnHorzCurvesCleared)] HRESULT OnHorzCurvesCleared();
   };

   /// Interface for objects that represent a cubic spline.
   ///
   /// A cublic spline consists of at least two end points and the tangent directions at the end points. Additional points between the end points can be included. 
   /// A clamped cubic spline is modeled with a series of piecewise cubic segments.
   [
		object,
		uuid(EA2DD8A2-5B17-4b36-AE3D-38CB7CB059E5),
		oleautomation,
		//helpcontext(IDH_CubicSpline),
		helpstring("ICubicSpline Interface"),
		pointer_default(unique)
   ]
   interface ICubicSpline : IUnknown
   {
      /// Adds a collection of points to the spline
      [helpstring("method AddPoints")] HRESULT AddPoints([in]IPoint2dCollection* points);

      /// Adds an individual point to the spline. The point object is created with the associated Point2dFactory object.
	  [helpstring("method AddPoint")] HRESULT AddPoint([in]Float64 x,[in]Float64 y);

     /// Adds a Point2d object to the spline.
	  [helpstring("method AddPointEx")] HRESULT AddPointEx([in]IPoint2d* point);

     /// Returns the number of points
	  [propget,helpstring("property PointCount")] HRESULT PointCount([out,retval]CollectionIndexType* nPoints);

     /// Returns a point at the specified index.
	  [propget,helpstring("property Point")] HRESULT Point([in]CollectionIndexType idx,[out,retval]IPoint2d** point);

     /// Returns a collection containing all spline points.
	  [propget,helpstring("property Points")] HRESULT Points([out,retval]IPoint2dCollection** ppPoints);

     /// Returns the start point
	  [propget,helpstring("property StartPoint")] HRESULT StartPoint([out,retval]IPoint2d** point);

     /// Returns the end point
	  [propget,helpstring("property EndPoint")] HRESULT EndPoint([out,retval]IPoint2d** point);

     /// Removes all points from the spline.
	  [helpstring("method Clear")] HRESULT Clear();

     /// Direction of a line tangent to the spline at the start point
	  [propput, helpstring("property StartDirection")] HRESULT StartDirection([in] VARIANT varDirection);
	  [propget, helpstring("property StartDirection")] HRESULT StartDirection([out,retval]IDirection** dir);

     /// Direction of a line tangent to the spline at the end point
	  [propput, helpstring("property EndDirection")] HRESULT EndDirection([in] VARIANT varDirection);
	  [propget, helpstring("property EndDirection")] HRESULT EndDirection([out,retval]IDirection** dir);

     /// Computes the bearing of a line tangent to the spline at a specified distance along the spline from the start point
      [helpstring("method Bearing")] HRESULT Bearing([in] Float64 distance,[out,retval]IDirection* *pVal);

      /// Computes the bearing of a line tangent to the spline at a specified point.
	  [helpstring("method BearingAtPoint")] HRESULT BearingAtPoint([in]CollectionIndexType idx,[out,retval]IDirection** pDir);

     /// Computes the bearing of a line normal to the spline at a specified distance along the spline from the start point
	  [helpstring("method Normal")] HRESULT Normal([in] Float64 distance,[out,retval]IDirection* *pVal);

     /// Computes the bearing of a line normal to the spline at a specified point.
	  [helpstring("method NormalAtPoint")] HRESULT NormalAtPoint([in]CollectionIndexType idx,[out,retval]IDirection** pDir);

     /// Determines the coordinate of a point on the spline at a specified distance from the start point.
	  [helpstring("method PointOnSpline")] HRESULT PointOnSpline([in] Float64 distance,[out,retval]IPoint2d* *pVal);

     /// Projects a point onto the spline such that a line perpendicular to the spline passes through the point
      [helpstring("method ProjectPoint")] HRESULT ProjectPoint(
         [in] IPoint2d* point, ///< The point to be projected onto the spline
         [out,retval] IPoint2d* *pNewPoint ///< The point on the spline
      );

      /// Computes the distance along the spline from the start point to the intersection of a point projected onto the spline and the spline
      [helpstring("method DistanceFromStart")] HRESULT DistanceFromStart(
         [in] IPoint2d* point, ///< The point to be projected onto the spline
         [out,retval] Float64* dist ///< The distance from the start of the spline
      );

      /// Computes the distance along the spline from the start point to a specified point
      [helpstring("method DistanceFromStartAtPoint")] HRESULT DistanceFromStartAtPoint([in] CollectionIndexType idx,[out,retval] Float64* dist);

      /// Determines the points where a line intersects the spline
	  [helpstring("method Intersect")] HRESULT Intersect(
        [in]ILine2d* line, ///< The line to intersect with the spline
        [in]VARIANT_BOOL bProjectBack, ///< If VARIANT_TRUE, the back tangent is projected and intersected with line
        [in]VARIANT_BOOL bProjectAhead, ///< If VARIANT_TRUE, the ahead tangent is projected and intersected with line
        [out,retval]IPoint2dCollection** points ///< A collection of intersection points
     );

     /// Returns the length of the spline
	  [propget,helpstring("property Length")] HRESULT Length([out,retval]Float64* pLength);

     /// A factory object used to create new Point2d objects
     [propget, helpstring("property PointFactory")] HRESULT PointFactory([out,retval] IPoint2dFactory* *factory);
      [propputref, helpstring("property PointFactory")] HRESULT PointFactory([in] IPoint2dFactory *factory);

      /// Creates a copy of the spline. Copies all the spline points and start and end tangents
      [helpstring("method Clone")] HRESULT Clone([out,retval] ICubicSpline* *clone);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for ICubicSpline events
   [
       object,
       uuid(7A853591-F2A0-4b22-AB22-4ECE47D28F7A),
       oleautomation,
	   //helpcontext(IDH_CubicSpline),
       helpstring("ICubicSplineEvents Interface"),
       pointer_default(unique)
   ]
   interface ICubicSplineEvents : IUnknown
   {
      /// Called after the spline is changed
       [helpstring("event OnSplineChanged")/*, helpcontext(IDH_CubicSpline_OnSplineChanged)*/] HRESULT OnSplineChanged([in] ICubicSpline* spline);
   };

   /// Interface for objects that represent a Surface widening modification
   ///
   /// A widening can be applied to one or two segments of the SurfaceTemplate. This is to facilite symmetric widening with a single Widening object.
   [
      object,
      uuid(5FA0BC50-322E-4b8c-84AB-5315122966AE),
      oleautomation,
      //helpcontext(IDH_Widening),
      helpstring("IWidening Interface"),
      pointer_default(unique)
   ]
   interface IWidening : IUnknown
   {
      /// Initialize the object
      [helpstring("method Init")] HRESULT Init(
         [in]ISurface* pSurface, ///< Surface that is modified by this widening
         [in] VARIANT varBeginStation, ///< Station where the entry widening transition begins
         [in] VARIANT varBeginFullStation,  ///< Station where the full widening begins
         [in] VARIANT varEndFullStation, ///< Station where the fill widening ends
         [in] VARIANT varEndStation, ///< Station where the exit widening transition ends
         [in] Float64 widening, ///< The width of the widening. Positive values widen the surface and negative values make it more narrow.
         [in] SegmentIndexType templateSegmentIdx1, ///< Index of a TemplateSegment to widen
         [in] SegmentIndexType templateSegmentIdx2 ///< Index of a TemplateSegment to widen. Use INVALID_INDEX if the widening is applied to only one TemplateSegment.
      );

      /// The associated Surface
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Station where the entry widening transition begins
      [propput,helpstring("property BeginTransition")] HRESULT BeginTransition([in]VARIANT varStation);
      [propget,helpstring("property BeginTransition")] HRESULT BeginTransition([out,retval]IStation** station);

      /// Station where the full widening begins
      [propput,helpstring("property BeginFullWidening")] HRESULT BeginFullWidening([in]VARIANT varStation);
      [propget,helpstring("property BeginFullWidening")] HRESULT BeginFullWidening([out,retval]IStation** station);

      /// Station where the full widening ends
      [propput,helpstring("property EndFullWidening")] HRESULT EndFullWidening([in]VARIANT varStation);
      [propget,helpstring("property EndFullWidening")] HRESULT EndFullWidening([out,retval]IStation** station);

      /// Station where the exit widening transition ends
      [propput,helpstring("property EndTransition")] HRESULT EndTransition([in]VARIANT varStation);
      [propget,helpstring("property EndTransition")] HRESULT EndTransition([out,retval]IStation** station);

      /// The width of the widening. Positive values widen the surface and negative values make it more narrow.
      [propput,helpstring("property Widening")] HRESULT Widening([in]Float64 value);
      [propget,helpstring("property Widening")] HRESULT Widening([out,retval]Float64* value);

      /// Index of the TemplateSegment to be widened.
      ///
      /// @param pntIdx 0 or 1 to indicate which of the two widenings the segment index applies
      /// @param templateSegmentIdx Index of the TemplateSegment to widen
      [propput,helpstring("property Segment")] HRESULT Segment([in]IndexType pntIdx,[in]IndexType templateSegmentIdx);
      [propget,helpstring("property Segment")] HRESULT Segment([in]IndexType pntIdx,[out,retval]IndexType* templateSegmentIdx);

      /// Computes the widening for the specified TemplateSegment at a station.
      [helpstring("method GetWidening")] HRESULT GetWidening(
         [in]VARIANT varStation, ///< The station where the widening is to be computed
         [in]IndexType templateSegmentIdx, ///< Index of the TemplateSegment for which the widening is to be computed
         [out,retval]Float64* pWidening ///< The computed widening. If the specified TemplateSegment is not widened the computed widening is zero.
      );

      /// Creates a copy of this widening.
      [helpstring("method Clone")] HRESULT Clone([out,retval]IWidening** ppClone);

      /// The StructuredStorage property
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for IWidening events
   [
      object,
      uuid(4C081EEC-CB28-465c-AA42-93B92458E8F4),
      oleautomation,
      //helpcontext(IDH_Widening),
      helpstring("IWideningEvents Interface"),
      pointer_default(unique)
   ]
   interface IWideningEvents : IUnknown
   {
      /// Called after the widening has changed
      [helpstring("event OnWideningChanged")] HRESULT OnWideningChanged([in]IWidening* pWidening);
   };

   /// Interface for objects that enumerate a collection of IWidening objects
   [
	   object,
	   uuid(F580E4A7-C6CE-4482-8C00-5639CFDC26CF),
	   helpstring("IEnumWidenings Interface"),
	   //helpcontext(IDH_IEnumWidenings),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumWidenings : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumWidenings** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IWidening** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for objects representing a collection of IWidening objects
   [
		object,
		uuid(D7723EA4-F8F0-4749-AF6F-CD4A1BD53546),
		oleautomation,
		//helpcontext(IDH_WideningCollection),
		helpstring("IWideningCollection Interface"),
		pointer_default(unique)
	]
	interface IWideningCollection : IUnknown
	{
      /// The associated Surface
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Gets an item from the collection at the specified index.
      [propget, helpstring("property Item")/*, helpcontext(IDH_WideningCollection_Item)*/] HRESULT Item([in] CollectionIndexType idx,[out, retval] IWidening* *pVal);
      
      /// Replaces an item in the collection
      [propputref, helpstring("property Item")/*, helpcontext(IDH_WideningCollection_Item)*/] HRESULT Item([in] CollectionIndexType idx,[in] IWidening* pVal);
      
      /// Returns the number of items in the collection.
      [propget, helpstring("property Count")/*, helpcontext(IDH_WideningCollection_Count)*/] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a Widening object to the collection.
		[helpstring("method Add")/*, helpcontext(IDH_WideningCollection_Add)*/] HRESULT Add(
         [in] VARIANT varBeginStation, ///< Station where the entry widening transition begins
         [in] VARIANT varBeginFullStation,  ///< Station where the full widening begins
         [in] VARIANT varEndFullStation, ///< Station where the fill widening ends
         [in] VARIANT varEndStation, ///< Station where the exit widening transition ends
         [in] Float64 widening, ///< The width of the widening. Positive values widen the surface and negative values make it more narrow.
         [in] SegmentIndexType templateSegmentIdx1, ///< Index of a TemplateSegment to widen
         [in] SegmentIndexType, ///< Index of a TemplateSegment to widen. Use INVALID_INDEX if the widening is applied to only one TemplateSegment.
         [out,retval]IWidening* *pWidening ///< The new Widening object
      );
      
      /// Adds a Widening object to the collection.
		[helpstring("method AddEx")/*, helpcontext(IDH_WideningCollection_AddEx)*/] HRESULT AddEx([in] IWidening* csect);

      /// Removes a Widening object from the collection
		[helpstring("method Remove")/*, helpcontext(IDH_WideningCollection_Remove)*/] HRESULT Remove([in] CollectionIndexType idx);

      /// Removes all items from the collection
      [helpstring("method Clear")/*, helpcontext(IDH_WideningCollection_Clear)*/] HRESULT Clear();

      /// Finds the Widening object at a station.
      [helpstring("method GetWidening")] HRESULT GetWidening([in]VARIANT varStation, [out, retval]IWidening** widening);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumWidenings interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumWidenings")/*, helpcontext(IDH_WideningCollection__EnumWidenings)*/] HRESULT _EnumWidenings([out, retval] IEnumWidenings** retval);

      /// Clones the collection making a copy of all the contained objects
      [helpstring("method Clone")/*,helpcontext(IDH_WideningCollection_Clone)*/] HRESULT Clone([out,retval] IWideningCollection* *clone);
      
      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for IWideningCollection events
   [
		object,
		uuid(D3C1C368-EDBF-4302-8FC0-65B2150E1C57),
		oleautomation,
		//helpcontext(IDH_WideningCollection),
		helpstring("IWideningCollectionEvents Interface"),
		pointer_default(unique)
	]
	interface IWideningCollectionEvents : IUnknown
   {
      /// Called after a Widening is changed
       [helpstring("event OnWideningChanged")/*, helpcontext(IDH_CrossSectionCollection_OnCrossSectionChanged)*/] HRESULT OnWideningChanged([in] IWidening* pWidening);

       /// Called after a Widening is added
       [helpstring("event OnWideningAdded")/*, helpcontext(IDH_CrossSectionCollection_OnPointAdded)*/] HRESULT OnWideningAdded([in] IWidening* pWidening);

       /// Called after a Widening is removed
       [helpstring("event OnWideningRemoved")/*, helpcontext(IDH_CrossSectionCollection_OnPointRemoved)*/] HRESULT OnWideningRemoved();

       /// Called after the collection is cleared
       [helpstring("event OnWideningsCleared")/*, helpcontext(IDH_CrossSectionCollection_OnPointsCleared)*/] HRESULT OnWideningsCleared();
   };

   /// Interface for objects that represent a Surface superelevation modification
   ///
   /// A superelevation is defined by its limits, transitions, rate, and pivot point.
   /// Superelvation transitions can be linear or parabolic.
   [
      object,
      uuid(C261362D-E01F-49c5-95ED-E8A8FBC68FB9),
      oleautomation,
      //helpcontext(IDH_Superelevation),
      helpstring("ISuperelevation Interface"),
      pointer_default(unique)
   ]
   interface ISuperelevation : IUnknown
   {
      /// Initialize the object
      [helpstring("method Init")] HRESULT Init(
         [in]ISurface* pSurface, ///< Surface that is modified by this superelevation
         [in] VARIANT varBeginStation, ///< Station where the entry superelevation transition begins
         [in] VARIANT varBeginFullStation,  ///< Station where the full superelevation begins
         [in] VARIANT varEndFullStation, ///< Station where the full superelevation ends
         [in] VARIANT varEndStation, ///< Station where the exit superelevation transition ends
         [in] Float64 rate, ///< The superelevation rate (cross slope). Positive values indicates the roadway slopes upwards from left to right.
         [in]IndexType pivotPointIdx, ///< Ridge point index that the superelevation pivot occurs about.
         [in]SuperTransitionType beginType, ///< Entry transition type
         [in]Float64 beginL1, ///< If the entry transition is parabolic, this is the length of the parabola at the beginning of the transition
         [in]Float64 beginL2, ///< If the entry transition is parabolic, this is the length of the parabola at the beginning of full superelevation
         [in]SuperTransitionType endType, ///< Exit transition type
         [in]Float64 endL1, ///< If the exit transition is parabolic, this is the length of the parabola at the end of full superelevation
         [in]Float64 endL2 ///< If the exit transition is parabolic, this is the length of the parabola at the end of the transition
      );

      /// The associated Surface
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);
      
      /// Station where the entry superelevation transition begins 
      [propput, helpstring("property BeginTransition")] HRESULT BeginTransition([in] VARIANT varBeginTransition);
      [propget, helpstring("property BeginTransition")] HRESULT BeginTransition([out,retval] IStation** ppBeginTransition);

      /// Station where the full superelevation begins
      [propput, helpstring("property BeginFullSuper")] HRESULT BeginFullSuper([in] VARIANT varBeginFullSuper);
      [propget, helpstring("property BeginFullSuper")] HRESULT BeginFullSuper([out,retval] IStation** ppBeginFullSuper);

      /// Station where the full superelevation ends
      [propput, helpstring("property EndFullSuper")] HRESULT EndFullSuper([in] VARIANT varEndFullSuper);
      [propget, helpstring("property EndFullSuper")] HRESULT EndFullSuper([out,retval] IStation** ppEndFullSuper);

      /// Station where the exit superelevation transition ends
      [propput, helpstring("property EndTransition")] HRESULT EndTransition([in] VARIANT varEndTransition);
      [propget, helpstring("property EndTransition")] HRESULT EndTransition([out,retval] IStation** ppEndTransition);

      /// The superelevation rate (cross slope). Positive values indicates the roadway slopes upwards from left to right.
      [propput, helpstring("property Rate")] HRESULT Rate([in]Float64 rate);
      [propget, helpstring("property Rate")] HRESULT Rate([out,retval]Float64* rate);

      /// Ridge point index that the superelevation pivot occurs about.
      [propput, helpstring("property PivotPoint")] HRESULT PivotPoint([in]IndexType pivotPointIdx);
      [propget, helpstring("property PivotPoint")] HRESULT PivotPoint([out,retval]IndexType* pivotPointIdx);

      /// Entry transition type
      [propput, helpstring("property BeginTransitionType")] HRESULT BeginTransitionType([in]SuperTransitionType type);
      [propget, helpstring("property BeginTransitionType")] HRESULT BeginTransitionType([out,retval]SuperTransitionType* type);

      /// Entry transition parameters for parabolic transitions
      /// @param L1 Length of the parabola at the beginning of the transition
      /// @param L2 Length of the parabola at the beginning of full superelevation
      [helpstring("method SetBeginTransitionParameters")] HRESULT SetBeginTransitionParameters([in]Float64 L1,[in]Float64 L2);
      [helpstring("method GetBeginTransitionParameters")] HRESULT GetBeginTransitionParameters([out]Float64* L1,[out]Float64* L2);

      /// Exit transition type
      [propput, helpstring("property EndTransitionType")] HRESULT EndTransitionType([in]SuperTransitionType type);
      [propget, helpstring("property EndTransitionType")] HRESULT EndTransitionType([out,retval]SuperTransitionType* type);

      /// Exit transition parameters for parabolic transitions
      /// @param L1 Length of the parabola at the end of full superelevation
      /// @param L2 Length of the parabola at the end of the transition
      [helpstring("method SetEndTransitionParameters")] HRESULT SetEndTransitionParameters([in]Float64 L1,[in]Float64 L2);
      [helpstring("method GetEndTransitionParameters")] HRESULT GetEndTransitionParameters([out]Float64* L1,[out]Float64* L2);

      /// Computes the slope at the specified station
      [helpstring("method GetSlope")] HRESULT GetSlope(
         [in]VARIANT varStation, ///< The station where the slope is computed
         [in]Float64 templateSlope, ///< The basic slope of the template before superelevation transitions are applied.
         [out,retval]Float64* pSlope ///< The roadway cross slope
      );
      [helpstring("method Clone")] HRESULT Clone([out,retval] ISuperelevation* *clone);
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for ISuperelevation events
   [
      object,
      uuid(B8D6C861-BFCA-4dc7-B65B-C7EE2ED6371F),
      oleautomation,
      //helpcontext(IDH_Superelevation),
      helpstring("ISuperelevationEvents Interface"),
      pointer_default(unique)
   ]
   interface ISuperelevationEvents : IUnknown
   {
      /// Called after a Superelevation is changed
      [helpstring("event OnSuperelevationChanged")] HRESULT OnSuperelevationChanged([in]ISuperelevation* pSuperelevation);
   };

   /// Interface for objects that enumerate a collection of ISuperelevation objects
   [
	   object,
	   uuid(FD9B1B87-7F5D-4654-80A3-F86E05DCDDE8),
	   helpstring("IEnumSuperelevations Interface"),
	   //helpcontext(IDH_IEnumSuperelevations),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumSuperelevations : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumSuperelevations** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt,  ///< Number of elements being requested
         [out] ISuperelevation** rgelt,  ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for objects representing a collection of ISuperelevation objects
   [
		object,
		uuid(6A398C05-0903-42a7-9C50-34CD958E036E),
		oleautomation,
		//helpcontext(IDH_SuperelevationCollection),
		helpstring("ISuperelevationCollection Interface"),
		pointer_default(unique)
	]
	interface ISuperelevationCollection : IUnknown
	{
      /// The associated Surface
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Gets an item from the collection at the specified index.
      [propget, helpstring("property Item")/*, helpcontext(IDH_SuperelevationCollection_Item)*/] HRESULT Item([in] CollectionIndexType idx,[out, retval] ISuperelevation* *pVal);
      
      /// Replaces an item in the collection
      [propputref, helpstring("property Item")/*, helpcontext(IDH_SuperelevationCollection_Item)*/] HRESULT Item([in] CollectionIndexType idx,[in] ISuperelevation* pVal);
      
      /// Returns the number of items in the collection.
      [propget, helpstring("property Count")/*, helpcontext(IDH_SuperelevationCollection_Count)*/] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a Superelevation object to the collection.
      [helpstring("method Add")/*, helpcontext(IDH_SuperelevationCollection_Add)*/] HRESULT Add(
         [in] VARIANT varBeginStation, ///< Station where the entry superelevation transition begins
         [in] VARIANT varBeginFullStation,  ///< Station where the full superelevation begins
         [in] VARIANT varEndFullStation, ///< Station where the full superelevation ends
         [in] VARIANT varEndStation, ///< Station where the exit superelevation transition ends
         [in] Float64 rate, ///< The superelevation rate (cross slope). Positive values indicates the roadway slopes upwards from left to right.
         [in]IndexType pivotPointIdx, ///< Ridge point index that the superelevation pivot occurs about.
         [in]SuperTransitionType beginType, ///< Entry transition type
         [in]Float64 beginL1, ///< If the entry transition is parabolic, this is the length of the parabola at the beginning of the transition
         [in]Float64 beginL2, ///< If the entry transition is parabolic, this is the length of the parabola at the beginning of full superelevation
         [in]SuperTransitionType endType, ///< Exit transition type
         [in]Float64 endL1, ///< If the exit transition is parabolic, this is the length of the parabola at the end of full superelevation
         [in]Float64 endL2, ///< If the exit transition is parabolic, this is the length of the parabola at the end of the transition
         [out,retval]ISuperelevation* *pSuperelevation ///< A new Superelevation object
      );

      /// Adds a Superelevation object to the collection.
      [helpstring("method AddEx")/*, helpcontext(IDH_SuperelevationCollection_AddEx)*/] HRESULT AddEx([in] ISuperelevation* pVal);

      /// Removes a Superelevation object from the collection
      [helpstring("method Remove")/*, helpcontext(IDH_SuperelevationCollection_Remove)*/] HRESULT Remove([in] CollectionIndexType idx);

      /// Removes all items from the collection
      [helpstring("method Clear")/*, helpcontext(IDH_SuperelevationCollection_Clear)*/] HRESULT Clear();

      /// Finds the Superelevation object at a station.
     [helpstring("method GetSuperelevation")] HRESULT GetSuperelevation([in]VARIANT varStation,[out,retval]ISuperelevation** superelevation);

     /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
     [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

     /// Returns an IEnumSuperelevations interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
     [propget, restricted, helpstring("property _EnumSuperelevations")/*, helpcontext(IDH_SuperelevationCollection__EnumSuperelevations)*/] HRESULT _EnumSuperelevations([out, retval] IEnumSuperelevations** retval);
     
     /// Clones the collection making a copy of all the contained objects
     [helpstring("method Clone")/*,helpcontext(IDH_SuperelevationCollection_Clone)*/] HRESULT Clone([out,retval] ISuperelevationCollection* *clone);

     /// The StructuredStorage property.
     [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for ISuperelevationCollection events
   [
		object,
		uuid(6E02AF30-D533-4bc3-9341-B901CF331FB1),
		oleautomation,
		//helpcontext(IDH_SuperelevationCollection),
		helpstring("ISuperelevationCollectionEvents Interface"),
		pointer_default(unique)
	]
	interface ISuperelevationCollectionEvents : IUnknown
   {
      /// Called after a Superelevation is changed
       [helpstring("event OnSuperelevationChanged")] HRESULT OnSuperelevationChanged([in] ISuperelevation* pSuperelevation);

       /// Called after a Superelevation is added
       [helpstring("event OnSuperelevationAdded")] HRESULT OnSuperelevationAdded([in] ISuperelevation* pSuperelevation);

       /// Called after a Superelevation is removed
       [helpstring("event OnSuperelevationRemoved")] HRESULT OnSuperelevationRemoved();

       /// Called after the collection is cleared
       [helpstring("event OnSuperelevationsCleared")] HRESULT OnSuperelevationsCleared();
   };

   /// Interface defining a SurfaceTemplate segment.
   [
      object,
      uuid(B3D0955A-0174-4085-A6F7-C71ACAC612D7),
      oleautomation,
      //helpcontext(IDH_TemplateSegment),
      helpstring("ITemplateSegment Interface"),
      pointer_default(unique)
   ]
   interface ITemplateSegment : IUnknown
   {
      /// Initializes the segment
      [helpstring("method Init")] HRESULT Init(
         [in]Float64 width, ///< Width of the segment
         [in]Float64 slope, ///< Slope of the segment
         [in]TemplateSlopeType slopeType ///< Type of slope used to define the segment
      );

      /// Width of the segment
      [propput, helpstring("property Width")] HRESULT Width([in]Float64 width);
      [propget, helpstring("property Width")] HRESULT Width([out,retval]Float64* width);

      /// Slope of the segment
      [propput, helpstring("property Slope")] HRESULT Slope([in]Float64 slope);
      [propget, helpstring("property Slope")] HRESULT Slope([out,retval]Float64* slope);

      /// Type of slope used to define the segment
      [propput, helpstring("property SlopeType")] HRESULT SlopeType([in]TemplateSlopeType type);
      [propget, helpstring("property SlopeType")] HRESULT SlopeType([out,retval]TemplateSlopeType* type);

      /// Creates a copy of template
      [helpstring("method Clone")] HRESULT Clone([out,retval] ITemplateSegment* *clone);

      /// The StructuredStorage object
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for ITemplateSegment events
   [
      object,
      uuid(65775E88-FC55-4387-9752-5F45686DC55B),
      oleautomation,
      //helpcontext(IDH_TemplateSegment),
      helpstring("ITemplateSegmentEvents Interface"),
      pointer_default(unique)
   ]
   interface ITemplateSegmentEvents : IUnknown
   {
      /// Called after a template segment has changed
      [helpstring("event OnTemplateSegmentChanged")] HRESULT OnTemplateSegmentChanged([in]ITemplateSegment* pSegment);
   };

   /// Interface defining a surface template.
   ///
   /// A surface template defines the cross section of a surface. The template consists of a sequence of straight line segments, defined left to right looking in the forward direction (ahead on station).
   /// The end points of the segments are known as ridge points.
   [
      object,
      uuid(D2286685-D34F-4a59-B7C7-9B531D1C9713),
      oleautomation,
      //helpcontext(IDH_SurfaceTemplate),
      helpstring("ISurfaceTemplate Interface"),
      pointer_default(unique)
   ]
   interface ISurfaceTemplate : IUnknown
   {
      /// The associated Surface object
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Station where this SurfaceTemplate is applied
      [propput,helpstring("property Station")] HRESULT Station([in]VARIANT varStation);
      [propget,helpstring("property Station")] HRESULT Station([out,retval]IStation** station);

      /// Adds a segment to the template. A new SegmentTemplate object is created.
      [helpstring("method AddSegment")] HRESULT AddSegment(
         [in]Float64 width, ///< Width of the segment
         [in]Float64 slope,///< Slope of the segment
         [in]TemplateSlopeType slopeType ///< Type of slope used to define the segment
      );

      /// Adds a segment to the template
      [helpstring("method AddSegmentEx")] HRESULT AddSegmentEx([in]ITemplateSegment* segment);

      /// Removes a segment from the template
      [helpstring("method RemoveSegment")] HRESULT RemoveSegment([in]CollectionIndexType idx);

      /// Returns the number of segments in the template.
      ///
      /// > NOTE: All SurfaceTemplates associated with a Surface must have the same number of Segments.
      [propget,helpstring("property Count")] HRESULT Count([out,retval]CollectionIndexType* count);

      /// Gets a SurfaceTemplate
      [propget,helpstring("property Item")] HRESULT Item([in]CollectionIndexType idx,[out,retval]ITemplateSegment** segment);

      /// Computes the change in elevation between two ridge points.
      [helpstring("method GetRidgePointElevationChange")] 
      HRESULT GetRidgePointElevationChange(
         [in]CollectionIndexType ridgePointIdx1, ///< The first ridge point
         [in]CollectionIndexType ridgePointIdx2, ///< The second ridge point
         [out,retval]Float64* deltaElevation ///< The change in elevation from the first to second ridge points
      );

      /// Computes the elevaton change from a ridge point to an offset point
      [helpstring("method GetElevationChange")] 
      HRESULT GetElevationChange(
         [in]CollectionIndexType ridgePointIdx, ///< Index of a ridge point
         [in]Float64 offset, ///< Offset from the ridge point
         [out,retval]Float64* deltaElevation ///< Change of elevation between the ridge point and the offset point
      );

      /// Computes the slope at a point offset from a ridge point
      [helpstring("method GetSlope")] 
      HRESULT GetSlope(
         [in]CollectionIndexType ridgePointIdx, ///< Index of a ridge point
         [in]Float64 offset, ///< Offset from the ridge point
         [out,retval]Float64* pSlope ///< Slope at the offset point
      );

      /// Returns the slope from horizontal of a segment
      [helpstring("method GetSegmentSlope")] HRESULT GetSegmentSlope([in]CollectionIndexType segmentIdx,[out,retval]Float64* pSlope);

      /// Computes the offset from a reference ridge point to another ridge point
      [helpstring("method GetRidgePointOffset")] 
      HRESULT GetRidgePointOffset(
         [in]IndexType ridgePointIdx, ///< Index of a ridge point
         [in]IndexType refPointIdx, ///< Index of the refernece ridge point
         [out]Float64* pOffset ///< The offset distance
      );

      /// Computes the offset from a reference ridge point to another ridge point and the elevation at that ridge point
      [helpstring("method GetidgePointElevation")] 
      HRESULT GetRidgePointElevation(
         [in]IndexType ridgePointIdx, ///< Index of a ridge point
         [in]IndexType refPointIdx, ///< Index of the reference ridge point
         [out]Float64* pOffset, ///< Offset from the reference ridge point
         [out]Float64* pElev ///< Elevation at the specified ridge point
      );

      /// Removes all TemplateSegments from this SurfaceTemplate
      [helpstring("method Clear")] HRESULT Clear();

      /// Copies this SurfaceTemplate and all TemplateSegment objects
      [helpstring("method Clone")] HRESULT Clone([out,retval] ISurfaceTemplate* *clone);

      /// The StructuredStorage property
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for ISurfaceTemplate events
   [
      object,
      uuid(E7E90090-DECB-4646-BAFB-4C8BF9B765B4),
      oleautomation,
      //helpcontext(IDH_SurfaceTemplate),
      helpstring("ISurfaceTemplateEvents Interface"),
      pointer_default(unique)
   ]
   interface ISurfaceTemplateEvents : IUnknown
   {
      /// Called after a SurfaceTemplate has changed
      [helpstring("event OnSurfaceTemplateChanged")] HRESULT OnSurfaceTemplateChanged([in]ISurfaceTemplate* pTemplate);

      /// Called when a TemplateSemgenet is added to a SurfaceTemplate
      [helpstring("event OnTemplateSegmentAdded")] HRESULT OnTemplateSegmentAdded([in]ISurfaceTemplate* pTemplate,[in]ITemplateSegment* pSegment);

      /// Called when a TemplateSegment is removed from a SurfaceTemplate
      [helpstring("event OnTemplateSegmentRemoved")] HRESULT OnTemplateSegmentRemoved([in]ISurfaceTemplate* pTemplate);

      /// Called when a SurfaceTemplate is cleared
      [helpstring("event OnTemplateSegmentsCleared")] HRESULT OnTemplateSegmentsCleared([in]ISurfaceTemplate* pTemplate);
   };

   /// Interface for objects that enumerate a collection of ISurfaceTemplate objects
	[
	   object,
	   uuid(D0644265-55FE-499e-9090-5E80B6641247),
	   helpstring("IEnumSurfaceTemplates Interface"),
	   //helpcontext(IDH_IEnumSurfaceTemplates),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumSurfaceTemplates : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumSurfaceTemplates** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] ISurfaceTemplate** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for objects representing a collection of ISurfaceTemplate objects
   [
		object,
		uuid(9F5259B4-F4A0-48b4-8899-AF80C1B26DB9),
		oleautomation,
		//helpcontext(IDH_SurfaceTemplateCollection),
		helpstring("ISurfaceTemplateCollection Interface"),
		pointer_default(unique)
	]
	interface ISurfaceTemplateCollection : IUnknown
	{
      /// The associated Surface object
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);
      
      /// Gets an item from the collection at the specified index
      [propget, helpstring("property Item")] HRESULT Item([in] CollectionIndexType idx,[out, retval] ISurfaceTemplate* *pVal);
      
      /// Replaces an item in the collection
      [propputref, helpstring("property Item")] HRESULT Item([in] CollectionIndexType idx,[in] ISurfaceTemplate* pVal);
      
      /// Returns the number of items in the collection.
      [propget, helpstring("property Count")] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a SurfaceTemplate object to the collection
		[helpstring("method Add")] HRESULT Add([in] ISurfaceTemplate* pVal);

      /// Removes a SurfaceTemplate object at the specified index from the collection
		[helpstring("method Remove")] HRESULT Remove([in] CollectionIndexType idx);

      /// Removes all SurfaceTemplate objects from the collection
		[helpstring("method Clear")] HRESULT Clear();

      /// Returns the SurfaceTemplate objects that bound the specified station
      [helpstring("method GetBoundingTemplates")] HRESULT GetBoundingTemplates(
         [in]VARIANT varStation, ///< The station
         [out]ISurfaceTemplate** ppStart, ///< The SurfaceTemplate immediately before the station
         [out]ISurfaceTemplate** ppEnd ///< The SurfaceTemplate immediately after the station
      );

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumSurfaceTemplates interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumSurfaceTemplates")] HRESULT _EnumSurfaceTemplates([out, retval] IEnumSurfaceTemplates** retval);

      /// Clones the collection making a copy of all the contained objects
      [helpstring("method Clone")] HRESULT Clone([out,retval] ISurfaceTemplateCollection* *clone);
      
      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for ISurfaceTemplateCollection events
   [
		object,
		uuid(32093DF8-B30F-4377-9EA0-2369B2ED7C23),
		oleautomation,
		//helpcontext(IDH_SurfaceTemplateCollection),
		helpstring("ISurfaceTemplateCollectionEvents Interface"),
		pointer_default(unique)
	]
	interface ISurfaceTemplateCollectionEvents : IUnknown
   {
      /// Called after a SurfaceTemplate has changed
       [helpstring("event OnSurfaceTemplateChanged")] HRESULT OnSurfaceTemplateChanged([in] ISurfaceTemplate* pSurfaceTemplate);

       /// Called after a SurfaceTemplate has been added
       [helpstring("event OnSurfaceTemplateAdded")] HRESULT OnSurfaceTemplateAdded([in] ISurfaceTemplate* pSurfaceTemplate);

       /// Called after a SurfaceTemplate has been removed
       [helpstring("event OnSurfaceTemplateRemoved")] HRESULT OnSurfaceTemplateRemoved();

       /// Called after the collection has been cleared
       [helpstring("event OnSurfaceTemplatesCleared")] HRESULT OnSurfaceTemplatesCleared();
   };

   /// Interface for objects that represent a point in a SurfaceProfile
   ///
   /// A surface point is defined by it's station, normal offset, cut line offset, elevation, and plan view coordinate.
   [
       object,
       uuid(D4CD4F83-7F81-4ee9-B9AD-546E23014880),
       oleautomation,
	   //helpcontext(IDH_SurfacePoint),
       helpstring("ISurfacePoint Interface"),
       pointer_default(unique)
   ]
   interface ISurfacePoint : IUnknown
   {
      /// The associated Surface object
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Station where this point occurs
       [propget, helpstring("property Station")]HRESULT Station([out, retval] IStation* *station);
       [propput, helpstring("property Station")] HRESULT Station([in] VARIANT varStation);

       /// Normal offset from the alignment, at the location of the Station property, to this point
       [propget, helpstring("property NormalOffset")] HRESULT NormalOffset([out, retval] Float64 *pVal);
       [propput, helpstring("property NormalOffset")] HRESULT NormalOffset([in] Float64 newVal);

       /// Offset from the alignment, at the location of the Station property, measured along a cut line to this point
       [propget, helpstring("property CutLineOffset")] HRESULT CutLineOffset([out, retval] Float64 *pVal);
       [propput, helpstring("property CutLineOffset")] HRESULT CutLineOffset([in] Float64 newVal);

       /// Elevation of this point
       [propget, helpstring("property Elevation")] HRESULT Elevation([out, retval] Float64 *pVal);
       [propput, helpstring("property Elevation")] HRESULT Elevation([in] Float64 newVal);

       /// Plan view coordinate of this point represented with a Point2d object
       [propget, helpstring("property Location")] HRESULT Location([out,retval]IPoint2d** ppLocation);
       [propput, helpstring("property Location")] HRESULT Location([in]IPoint2d* ppLocation);

       /// Spatial representation of this point as a Point3d object
       [helpstring("method GetPoint")] HRESULT GetPoint([out,retval]IPoint3d** ppPoint);

       /// Creates a copy of this point
       [helpstring("method Clone")] HRESULT Clone([out,retval] ISurfacePoint* *clone);

       /// The StructuredStorage property
        [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Interface for objects that represent a SurfaceProfile
   ///
   /// Surface points are defined left to right along the surface profile.
   [
      object,
      uuid(677A9E7B-7CA1-47ef-95FF-EBB88CC2CA0A),
      oleautomation,
      //helpcontext(IDH_SurfaceProfile),
      helpstring("ISurfaceProfile Interface"),
      pointer_default(unique)
   ]
   interface ISurfaceProfile : IUnknown
   {
      /// The associated Surface object
      [propget, helpstring("property Surface")] HRESULT Surface([out, retval] ISurface* *pVal);
      [propputref, helpstring("property Surface")] HRESULT Surface([in] ISurface* newVal);

      /// Station that locates this SurfaceProfile along an alignment
      [propput,helpstring("property Station")] HRESULT Station([in]VARIANT varStation);
      [propget,helpstring("property Station")] HRESULT Station([out,retval]IStation** station);

      /// Direction of a cutline defining this SurfaceProfile
      [propput,helpstring("property Direction")] HRESULT Direction([in]VARIANT varDirection);
      [propget,helpstring("property Direction")] HRESULT Direction([out,retval]IDirection** direction);

      /// Adds a point to this SurfaceProfile
      [helpstring("method AddPoint")] HRESULT AddPoint(
         [in]VARIANT varStation, ///< Station where a normal line passing through this point intersects the alignment
         [in]Float64 normalOffset, ///< Normal offset from the alignment to this point
         [in]Float64 cutLineOffset, ///< Offset along the cut line to this point
         [in]Float64 elev, ///< Elevation of this point
         [in]IPoint2d* pnt ///< The location of this point in plan view
      );

      /// Adds a SurfacePoint to this SurfaceProfile
      [helpstring("method AddPointEx")] HRESULT AddPointEx([in]ISurfacePoint* point);

      /// Removes the SurfacePoint at the specified index from this SurfaceProfile
      [helpstring("method RemovePoint")] HRESULT RemovePoint([in]CollectionIndexType idx);

      /// Gets the number of surface points
      [propget,helpstring("property Count")] HRESULT Count([out,retval]CollectionIndexType* count);

      /// Gets the SurfacePoint at the specified index
      [propget,helpstring("property Item")] HRESULT Item([in]CollectionIndexType idx,[out,retval]ISurfacePoint** point);

      /// Gets the change in elevation between two surface points
      [helpstring("method GetSurfacePointElevationChange")] 
      HRESULT GetSurfacePointElevationChange(
         [in]CollectionIndexType surfacePointIdx1, ///< Index of the first surface point
         [in]CollectionIndexType surfacePointIdx2, ///< Index of the second surface point
         [out,retval]Float64* deltaElevation ///< The change in elevation from the first to the second surface points.
      );

      /// Computes the elevation change from a surface point to an offset
      [helpstring("method GetElevationChange")] 
      HRESULT GetElevationChange(
         [in]CollectionIndexType surfacePointIdx, ///< Index of a surface point
         [in]Float64 offset, ///< Offset from the surface point
         [out,retval]Float64* deltaElevation ///< Change of elevation between the surface point and the offset point
      );

      /// Computes the slope at a point offset from a surface point
      [helpstring("method GetSlope")] 
      HRESULT GetSlope(
         [in]CollectionIndexType surfacePointIdx, ///< Index of a surface point
         [in]Float64 offset, ///< Offset from the surface point
         [out,retval]Float64* pSlope ///< Slope in the direction of the cutline at the offset point
      );

      /// Returns the slope from horizontal in the direction of the cutline
      [helpstring("method GetSegmentSlope")] HRESULT GetSegmentSlope([in]CollectionIndexType segmentIdx,[out,retval]Float64* pSlope);

      /// Returns the offset distance along the cutline to a surface point
      [helpstring("method GetSurfacePointOffset")] HRESULT GetSurfacePointOffset([in]IndexType ridgePointIdx,[out]Float64* pOffset);

      /// Computes the offset distance along the cutline and elevation of a surface point
      [helpstring("method GetSurfacePointElevation")] 
      HRESULT GetSurfacePointElevation(
         [in]IndexType ridgePointIdx, ///< Index of a surface point
         [out]Float64* pOffset, ///< Offset to the surface point along the cutline
         [out]Float64* pElev ///< Elevation of the surface point
      );

      /// Removes all SurfacePoint objects from this SurfaceProfile
      [helpstring("method Clear")] HRESULT Clear();

      /// Copies this SurfaceProfile and all SurfacePoint objects
      [helpstring("method Clone")] HRESULT Clone([out,retval] ISurfaceProfile* *clone);

      /// The StructuredStorageProperty
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Interface defining a surface.
   [
      object,
      uuid(07A3322F-F4C1-4635-9339-7B2954BB589D),
      oleautomation,
      //helpcontext(IDH_Surface),
      helpstring("ISurface Interface"),
      pointer_default(unique)
   ]
   interface ISurface : IUnknown
   {
      /// The associated profile
      [propget, helpstring("property Profile")] HRESULT Profile([out, retval] IProfile* *pVal);
      [propputref, helpstring("property Profile")] HRESULT Profile([in] IProfile* newVal);

      /// A unique identifier
      [propget, helpstring("property ID")] HRESULT ID([out,retval]CogoObjectID* id);
      [propput, helpstring("property ID")] HRESULT ID([in]CogoObjectID id);

      /// The collection of SurfaceTemplate objects associated with this Surface. All SurfaceTemplate objects must have the same number of SurfaceTemplateSegments.
      [propget,helpstring("property SurfaceTemplates")] HRESULT SurfaceTemplates([out,retval]ISurfaceTemplateCollection** ppTemplates);

      /// The number of SurfaceTemplateSegments in the collection of SurfaceTemplate objects. All SurfaceTemplate objects must have the same number of SurfaceTemplateSegments.
      [propget,helpstring("property SegmentCount")] HRESULT SegmentCount([out,retval]IndexType* pcnt);

      /// Index of the SurfaceTemplate point coincidient with the Alignment
      [propput,helpstring("property AlignmentPoint")] HRESULT AlignmentPoint([in]IndexType pntIdx);
      [propget,helpstring("property AlignmentPoint")] HRESULT AlignmentPoint([out,retval]IndexType* pntIdx);

      /// Index of the SurfaceTemplate point coincident with the Profile
      [propput,helpstring("property ProfileGradePoint")] HRESULT ProfileGradePoint([in]IndexType pntIdx);
      [propget,helpstring("property ProfileGradePoint")] HRESULT ProfileGradePoint([out,retval]IndexType* pntIdx);

      /// The collection of Superelevation objects associated with this Surface.
      [propget,helpstring("property Superelevations")] HRESULT Superelevations([out,retval]ISuperelevationCollection** ppSuperelevations);

      /// The collection of Widening objects associated with this Surface.
      [propget,helpstring("property Widenings")] HRESULT Widenings([out,retval]IWideningCollection** ppWidenings);

      /// A plan view line for the first SurfaceTemplate. This line is normal to the associated alignment. The line ranges between the left and right-most ridge points.
      [propget,helpstring("property StartBoundaryLine")] HRESULT StartBoundaryLine([in]ILineSegment2d** ppEndLine);

      /// A plan view line for the last SurfaceTemplate. This line is normal to the associated alignment. The line ranges between the left and right-most ridge points.
      [propget,helpstring("property EndBoundaryLine")] HRESULT EndBoundaryLine([in]ILineSegment2d** ppEndLine);

      /// The station range covered by this surface
      [helpstring("method GetStationRange")] HRESULT GetStationRange([out]IStation** ppStart,[out]IStation** ppEnd);

      /// Creates a SurfaceTemplate at the specified station.
      [helpstring("method CreateSurfaceTemplate")] HRESULT CreateSurfaceTemplate(
         [in]VARIANT varStation, ///< Station where the surface template is created
         [in]VARIANT_BOOL bApplyModifiers, ///< If VARIANT_TRUE, Superelevation and Widening modifiers are applied
         [out,retval]ISurfaceTemplate** ppSurfaceTemplate ///< The SurfaceTemplate
      );

      /// Creates a SurfaceProfile along a cut line passing through the specified station at the specified direction.
      [helpstring("method CreateSurfaceProfile")] HRESULT CreateSurfaceProfile(
         [in]VARIANT varStation, ///< Station where the surface profile is created
         [in]VARIANT varDirection, ///< Direction of the cut line.
         [in]VARIANT_BOOL bApplyModifiers, ///< If VARIANT_TRUE, Superelevation and Widening modifiers are applied
         [out,retval]ISurfaceProfile** ppSurfaceProfile ///< The SurfaceProfile
      );

      /// Clones the Surface making a copy of all the contained objects
      [helpstring("method Clone")] HRESULT Clone([out,retval] ISurface* *clone);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for ISurface events
   [
      object,
      uuid(19B01B9A-E4F1-4c8c-A255-3234AFC13CFC),
      oleautomation,
      //helpcontext(IDH_Surface),
      helpstring("ISurfaceEvents Interface"),
      pointer_default(unique)
   ]
   interface ISurfaceEvents : IUnknown
   {
      /// Called after the surface is changed
      [helpstring("event OnSurfaceChanged")] HRESULT OnSurfaceChanged([in]ISurface* pSurface);
   };

   /// Interface used to enumerate values in a container 
   [
	   object,
	   uuid(8395542A-0B80-4d6a-BA86-E3EDAA575798),
	   helpstring("IEnumSurfaces Interface"),
	   //helpcontext(IDH_IEnumSurfaces),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumSurfaces : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumSurfaces** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] ISurface** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for defining collection of objects that implement the ISurface interface.
   [
		object,
		uuid(44E00FE5-285A-45c2-9622-CB9E828234B7),
		oleautomation,
		//helpcontext(IDH_SurfaceCollection),
		helpstring("ISurfaceCollection Interface"),
		pointer_default(unique)
	]
	interface ISurfaceCollection : IUnknown
	{
      /// The associated Profile object
      [propget, helpstring("property Profile")] HRESULT Profile([out, retval] IProfile* *pVal);
      [propputref, helpstring("property Profile")] HRESULT Profile([in] IProfile* newVal);

      /// Gets an item from the collection using its identifier.
      [propget, helpstring("property Item")] HRESULT Item([in] CollectionIndexType idx,[out, retval] ISurface* *pVal);
      
      /// Replaces an item in the collection
      [propputref, helpstring("property Item")] HRESULT Item([in] CollectionIndexType idx,[in] ISurface* pVal);
      
      /// Returns the number of items in the collection.
      [propget, helpstring("property Count")] HRESULT Count([out, retval] CollectionIndexType *pVal);
      
      /// Adds a Surface to the collection
		[helpstring("method Add")] HRESULT Add([in] ISurface* pVal);
      
      /// Removes a Surface from the collection
      [helpstring("method Remove")] HRESULT Remove([in] CollectionIndexType idx);
      
      /// Removes all items from the collection
      [helpstring("method Clear")] HRESULT Clear();

      /// Searches the collection for a Surface with the specified id.
      [helpstring("method FindSurface")] HRESULT FindSurface([in]CogoObjectID id,[out,retval]ISurface** ppSurface);

      /// Searches the collection for a Surface with the specified id that contains the specified station.
     [helpstring("method GetSurface")] HRESULT GetSurface([in]CogoObjectID id,[in]VARIANT varStation,[out,retval]ISurface** ppSurface);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumSurfaces interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumSurfaces")] HRESULT _EnumSurfaces([out, retval] IEnumSurfaces** retval);

      /// Clones the collection making a copy of all the contained objects
      [helpstring("method Clone")] HRESULT Clone([out,retval] ISurfaceCollection* *clone);
      
      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for ISurfaceCollection events
   [
		object,
		uuid(86CE6349-FF88-482f-91A6-E0BDC9D5B22A),
		oleautomation,
		//helpcontext(IDH_SurfaceCollection),
		helpstring("ISurfaceCollectionEvents Interface"),
		pointer_default(unique)
	]
	interface ISurfaceCollectionEvents : IUnknown
   {
      /// Called after a surface has changed
       [helpstring("event OnSurfaceChanged")] HRESULT OnSurfaceChanged([in] ISurface* pSurface);

       /// Called after a surface is added
       [helpstring("event OnSurfaceAdded")] HRESULT OnSurfaceAdded([in] ISurface* pSurface);

       /// Called when a surface is removed
       [helpstring("event OnSurfaceRemoved")] HRESULT OnSurfaceRemoved();

       /// Called when the collection is cleared
       [helpstring("event OnSurfaceCleared")] HRESULT OnSurfacesCleared();
   };

   /// Interface for objects that represent an element in a profile.
   [
		object,
		uuid(885D3FAE-E15A-4BF0-AAD0-8622700D4250),
		oleautomation,
		helpcontext(IDH_ProfileElement),
		helpstring("IProfileElement Interface"),
		pointer_default(unique)
	]
	interface IProfileElement : IUnknown
	{
      /// The element type
      [propget, helpstring("property Type"), helpcontext(IDH_ProfileElement_Type)] HRESULT Type([out, retval] ProfileElementType *pVal);

      /// The profile element object.
      [propget, helpstring("property Value"), helpcontext(IDH_ProfileElement_Value)] HRESULT Value([out, retval] IUnknown** dispVal);
		[propputref, helpstring("property Value"), helpcontext(IDH_ProfileElement_Value)] HRESULT Value([in] IUnknown* dispVal);

      /// Creates a copy of the profile element. Copies the contained elements.
      [helpstring("method Clone"), helpcontext(IDH_ProfileElement_Clone)] HRESULT Clone([out,retval] IProfileElement* *clone);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for IProfileElement events
   [
		object,
		uuid(EEB5D577-DAAE-4a84-9010-67820CF18AE7),
		oleautomation,
		helpcontext(IDH_ProfileElement),
		helpstring("IProfileElementEvents Interface"),
		pointer_default(unique)
	]
	interface IProfileElementEvents : IUnknown
   {
      /// Called when a profile element changes
      [helpstring("event OnProfileElementChanged"), helpcontext(IDH_ProfileElement_OnProfileElementChanged)] HRESULT OnProfileElementChanged([in] IProfileElement* pe);
   };
   
   /// Interface for objects that enumerate a collection of IProfileElements objects
   [
	   object,
	   uuid(E570BCE7-4608-4279-8F25-4222F5B304E4),
	   helpstring("IEnumProfileElements Interface"),
	   //helpcontext(IDH_IEnumProfileElements),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumProfileElements : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumProfileElements** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IProfileElement** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};
   
   /// Interface defining a Profile object.
   [
		object,
		uuid(33CC0CE8-3BF5-4E27-A483-8EA6B4A2327B),
		oleautomation,
		helpcontext(IDH_Profile),
		helpstring("IProfile Interface"),
		pointer_default(unique)
	]
	interface IProfile : IUnknown
	{
      /// Returns the associated alignment
      [propget,helpstring("property Alignment")] HRESULT Alignment([out,retval]IAlignment** ppAlignment);

      /// Collection of Surface objects
      [propget,helpstring("property Surfaces")] HRESULT Surfaces([out,retval]ISurfaceCollection** ppSurfaces);
      [propputref,helpstring("property Surfaces")] HRESULT Surfaces([in]ISurfaceCollection* pSurfaces);

      /// A ProfileElement item
		[propget, helpstring("property Item"), helpcontext(IDH_Profile_Item)] HRESULT Item([in] CollectionIndexType idx,[out, retval] IProfileElement* *pVal);
		[propputref, helpstring("property Item"), helpcontext(IDH_Profile_Item)] HRESULT Item([in] CollectionIndexType idx,[in] IProfileElement* pVal);

      /// The number of ProfileElement items in the path
      [propget, helpstring("property Count"), helpcontext(IDH_Profile_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a ProfileElement to the collection
      [helpstring("method Add"), helpcontext(IDH_Profile_Add)] HRESULT Add([in] IProfileElement* element);

      /// Adds a ProfilePoitn or VertCurve object to the profile and creates a new ProfileElement object
      [helpstring("method AddEx"), helpcontext(IDH_Profile_AddEx)] HRESULT AddEx([in] IUnknown* dispElement);

      /// Removes a ProfileElement from the profile.
      [helpstring("method Remove"), helpcontext(IDH_Profile_Remove)] HRESULT Remove(
         [in] VARIANT varIdxOrElement ///< VARIANT containing either the index of the ProfileElement to remove or an IDispatch or IUnknown interface for a ProfileElement, ProfilePoint, or VertCurve object to be removed
      );

      /// Removes all ProfileElement objects from the profile
      [helpstring("method Clear"), helpcontext(IDH_Profile_Clear)] HRESULT Clear();

      /// Computes elevation at a specified station and offset
		[helpstring("method Elevation"), helpcontext(IDH_Profile_Elevation)] 
      HRESULT Elevation(
         [in] VARIANT varStation, ///< Station where the elevation is computed
         [in] Float64 offset, ///< Offset from the profile grade line
         [out,retval] Float64* elev ///< The profile element
      );

      /// Computes the profile grade at a specified station
		[helpstring("method Grade"), helpcontext(IDH_Profile_Grade)] 
      HRESULT Grade(
         [in] VARIANT varStation, ///< Station where the grade is computed
         [out,retval] Float64* grade ///< The profile grade
      );

      /// Computes the cross slope at a specified station and offset
		[helpstring("method Slope"), helpcontext(IDH_Profile_Slope)] 
      HRESULT Slope(
         [in] VARIANT varStation, ///< Station where the slope is computed
         [in] Float64 offset, ///< Offset from the profile grade line
         [out,retval] Float64* slope ///< The cross slope
      );

      /// Returns a surface template slope with respect to the horizontal
      [helpstring("method TemplateSegmentSlope")] 
      HRESULT TemplateSegmentSlope(
         [in]CogoObjectID surfaceID, ///< ID of a Surface object
         [in]VARIANT varStation, ///< Station where a SurfaceTemplate is created
         [in]CollectionIndexType templateSegmentIdx, ///< Index of the SurfaceTemplateSegment from which the slope is returned
         [out,retval]Float64* pSlope ///< The SurfaceTemplateSegment slope
      );

      /// Returns the Surface identified by surfaceID and containing the specified station.
      [helpstring("method GetSurface")] HRESULT GetSurface(
         [in]CogoObjectID surfaceID, ///< ID of a Surface object
         [in]VARIANT varStation, ///< The station
         [out,retval]ISurface** ppSurface ///< The Surface object
      );

      /// Returns the offset of a ridge point relative to a reference ridge point.
      [helpstring("method RidgePointOffset")] HRESULT RidgePointOffset(
         [in]CogoObjectID surfaceID, ///< ID of a Surface object
         [in]VARIANT varStation, ///< Station where a SurfaceTemplate is created
         [in]IndexType ridgePointIdx, ///< The ridge point index
         [in]IndexType refPointIdx, ///< The reference point
         [out]Float64* pOffset ///< The offset from the reference point to the ridge point
      );

      /// Returns the offset and elevation of a ridge point relative to a reference ridge point.
      [helpstring("method RidgePointElevation")] HRESULT RidgePointElevation(
         [in]CogoObjectID surfaceID, ///< ID of a Surface object
         [in]VARIANT varStation, ///< Statoin where a SurfaceTemplate is created
         [in]IndexType ridgePointIdx, ///< The ridge point index
         [in]IndexType refPointIdx, ///< The reference point index
         [out]Float64* pOffset, ///< The offset from the reference point to the ridge point
         [out]Float64* pElev ///< The elevation of the ridge point
      );

      /// Creates a copy of the profile. Copies all ProfileElements.
      [helpstring("method Clone"), helpcontext(IDH_Profile_Clone)] HRESULT Clone([out,retval] IProfile* *clone);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumProfileElements interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumProfileElements"), helpcontext(IDH_Profile__EnumProfileElements)] HRESULT _EnumProfileElements([out, retval] IEnumProfileElements** retval);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for IProfile events
   [
		object,
		uuid(0185AF42-F10A-4b4d-AB0E-58275D72E131),
		oleautomation,
		helpcontext(IDH_Profile),
		helpstring("IProfileEvents Interface"),
		pointer_default(unique)
	]
	interface IProfileEvents : IUnknown
	{
      /// Called after the profile is changed
	   [helpstring("event OnProifleChanged"), helpcontext(IDH_Profile_OnProifleChanged)] HRESULT OnProfileChanged([in] IProfile* profile);
	};

   /// Interface for objects that represent an element in a path.
	[
		object,
		uuid(60F5D239-6851-41B6-AD37-7CBA6BB9D78A),
		oleautomation,
		helpcontext(IDH_PathElement),
		helpstring("IPathElement Interface"),
		pointer_default(unique)
	]
	interface IPathElement : IUnknown
	{
      /// The element type
		[propget, helpstring("property Type"), helpcontext(IDH_PathElement_Type)] HRESULT Type([out, retval] PathElementType *pVal);

      /// The path element object.
		[propget, helpstring("property Value"), helpcontext(IDH_PathElement_Value)] HRESULT Value([out, retval] IUnknown* *pVal);
		[propputref, helpstring("property Value"), helpcontext(IDH_PathElement_Value)] HRESULT Value([in] IUnknown* newVal);

      /// Creates a copy of the path element. Copies the contained elements.
      [helpstring("method Clone"), helpcontext(IDH_PathElement_Clone)] HRESULT Clone([out,retval] IPathElement* *clone);

      /// Moves the path element
		[helpstring("method Move")] 
      HRESULT Move(
         [in] Float64 dist, ///< Distance to move the path element. The path element is moved in the opposite direction then the Direction object indicates when this parameter is less than zero.
         [in] IDirection* direction ///< The direction to move the path element.
      );

      /// Offsets the position of the path element
      [helpstring("method Offset")] HRESULT Offset(
         [in]Float64 dx, ///< Offset in the X (East-West) direction
         [in]Float64 dy ///< Offset in the Y (North-South) direction
      );

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for IPathElement events
   [
		object,
		uuid(6C8D62A8-6E1C-4c94-BD54-F3CDFA9E7B27),
		oleautomation,
		helpcontext(IDH_PathElement),
		helpstring("IPathElementEvents Interface"),
		pointer_default(unique)
	]
	interface IPathElementEvents : IUnknown
	{
      /// Called when a path element changes
	   [helpstring("event OnPathElementChanged"), helpcontext(IDH_PathElement_OnPathElementChanged)] HRESULT OnPathElementChanged([in] IPathElement* element);
	};

   /// Interface for objects that enumerate a collection of IPathElements objects
   [
	   object,
	   uuid(BD543403-0846-4502-841F-1904DC1F1144),
	   helpstring("IEnumPathElements Interface"),
	   helpcontext(IDH_IEnumPathElements),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumPathElements : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumPathElements** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IPathElement** rgelt,  ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface defining a Path object.
	[
		object,
		uuid(A43DACE9-956A-4421-9A3A-01D2453FCE03),
		oleautomation,
		helpcontext(IDH_Path),
		helpstring("IPath Interface"),
		pointer_default(unique)
	]
	interface IPath : IUnknown
	{
      /// A PathElement item in the path
		[propget, helpstring("property Item"), helpcontext(IDH_Path_Item)] HRESULT Item([in] CollectionIndexType idx,[out, retval] IPathElement* *pVal);
		[propputref, helpstring("property Item"), helpcontext(IDH_Path_Item)] HRESULT Item([in] CollectionIndexType idx,[in] IPathElement *pVal);

      /// The number of PathElement items in the path
		[propget, helpstring("property Count"), helpcontext(IDH_Path_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// Adds a PathElement to the collection
		[helpstring("method Add"), helpcontext(IDH_Path_Add)] HRESULT Add([in] IPathElement* element);

      /// Adds a Point2d, LineSegment2d, CubicSpline, or HorzCurve object to the path and creates a new PathElement object
		[helpstring("method AddEx"), helpcontext(IDH_Path_AddEx)] HRESULT AddEx([in] IUnknown* dispElement);

      /// Inserts a PathElement object into the Path at the specified index.
      [helpstring("method Insert"), helpcontext(IDH_Path_Insert)] HRESULT Insert([in] CollectionIndexType idx,[in] IPathElement* element);

      /// Inserts a Point2d, LineSegment2d, CubicSpline, or HorzCurve object into the Path at the specified index.
      [helpstring("method InsertEx"), helpcontext(IDH_Path_InsertEx)] HRESULT InsertEx([in] CollectionIndexType idx,[in] IUnknown* dispElement);

      /// Removes a PathElement from the path.
		[helpstring("method Remove"), helpcontext(IDH_Path_Remove)] HRESULT Remove(
         [in] VARIANT varIdxOrElement ///< VARIANT containing either the index of the PathElement to remove or an IDispatch or IUnknown interface for a PathElement, Point2d, LineSegment2d, CubicSpline, or HorzCurve object to be removed
      );

      /// Removes all PathElement objects from the path
		[helpstring("method Clear"), helpcontext(IDH_Path_Clear)] HRESULT Clear();
      
      /// Creates a Point object on the path at a specified location.
      /// \image html /Path/LocatePoint.jpg
		[helpstring("method LocatePoint"), helpcontext(IDH_Path_LocatePoint)] 
      HRESULT LocatePoint(
         [in] Float64 distance, ///< Distance from the start of the path from which the point is to be located
         [in] OffsetMeasureType offsetMeasure, ///< Specifies how offset is measured
         [in] Float64 offset, ///< Offset from the path to the point
         [in] VARIANT varDir, ///< Direction from the path at which to locate the point
         [out,retval] IPoint2d* *newPoint ///< The new point
      ); 

      /// Computes the bearing of the path at a specified location.
      /// \image html /Path/Bearing.jpg
		[helpstring("method Bearing"), helpcontext(IDH_Path_Bearing)] 
      HRESULT Bearing(
         [in] Float64 distance, ///< Distance from the start of the path at which the bearing is to be computed
         [out,retval] IDirection* *dir ///< A Direction object representing the bearing
      ); 

      /// Computes the normal to the path at a specified location.
      /// \image html /Path/Normal.jpg
      [helpstring("method Normal"), helpcontext(IDH_Path_Normal)] 
      HRESULT Normal(
         [in] Float64 distance, ///< Distance from the start of the path at which the normal is to be computed
         [out,retval] IDirection* *dir ///< A Direction object representing the normal
      );

      /// Projects a point onto the path
      /// \image html /Path/ProjectPoint.jpg
      [helpstring("method ProjectPoint"), helpcontext(IDH_Path_ProjectPoint)] 
      HRESULT ProjectPoint(
         [in] IPoint2d* point, ///< The point to project onto the path
         [out,retval] IPoint2d* *newPoint ///< The point on the path
      );

      /// Computes the distance along the path and the offset from the path for a given point
      /// \image html /Path/Offset.jpg
      [helpstring("method Offset"), helpcontext(IDH_Path_Offset)] 
      HRESULT Offset(
         [in] IPoint2d* point, ///< The point whose distance and offset is to be computed
         [out] Float64* distance, ///< The distance from the start of the path where a normal line passing through point intersects the path
         [out] Float64* offset ///< The offset from the path to the point
      );

      /// Intersects a Line2d object with the Path, projecting the start and end tangents, returning the intersection point nearest a specified point.
		[helpstring("method Intersect")] HRESULT Intersect(
         [in] ILine2d* line, ///< The line to intersect with the path.
         [in]IPoint2d* pNearest, ///< A point used for comparison with multiple intersection points.
         [out,retval]IPoint2d** point ///< The intersection point closed to pNearest.
      );

      /// Intersects a Line2d object with the Path returning the intersection point nearest a specified point.
      [helpstring("method IntersectEx")] HRESULT IntersectEx(
         [in]ILine2d* line, ///< The line to intersect with the path.
         [in]IPoint2d* pNearest, ///< A point used for comparison with multiple intersection points.
         [in]VARIANT_BOOL vbProjectBack, ///< If VARIANT_TRUE, the back tangent line at the start of the path is considered to be part of the path
         [in]VARIANT_BOOL vbProjectAhead, ///< If VARIANT_TRUE, the ahead tangent line at the end of the path is considered to be part of the path
         [out,retval]IPoint2d** point ///< The intersection point closed to pNearest.
      );

      /// Returns the length of the path
      [propget,helpstring("property Length")] HRESULT Length([out,retval]Float64* pLength);

      /// Creates a new Path that is parallel to the this Path.
      ///
      /// HorizCurve objects are degraded to points if the offset is on the same side of the Path as the center point and the offset exceeds the radius.
      /// CubicSpline objects are degraded to a point if lines normal to the spline at the control points intersect on the same side of the Path as the offset and the offset distance exceeds the distance from the spline to the intersection point.
		[helpstring("method CreateParallelPath"),helpcontext(IDH_Path_CreateParallelPath)] 
      HRESULT CreateParallelPath(
         [in] Float64 offset, ///< Offset to the new path. The new path is to the right of the original path for positive values.
         [out,retval]IPath** path /// The new path.
      );

      /// Creates a new Path that is a subset of this Path.
		[helpstring("method CreateSubPath"),helpcontext(IDH_Path_CreateSubPath)] 
      HRESULT CreateSubPath(
         [in]Float64 start, ///< Distance to the start of the sub-path
         [in]Float64 end, ///< Distance to the end of the sub-path
         [out,retval]IPath** path ///< A new Path object
      );
      
      /// Creates a new Path object where all elements of the path are connect with PathElement objects.
      ///
      /// A path can have breaks in it's definition such as a sequence of points. Intermediate PathElement objects for line segments are assumed to bridge these breaks.
      /// This methods creates a Path object that explicitly includes the intermediate PathElement objects
		[helpstring("method CreateConnectedPath"),helpcontext(IDH_Path_CreateConnectedPath)] HRESULT CreateConnectedPath([out,retval]IPath** path);

      /// Moves the path
		[helpstring("method Move"),helpcontext(IDH_Path_Move)] 
      HRESULT Move(
         [in] Float64 dist, ///< Distance to move the path. The path is moved in the opposite direction then the Direction object indicates when this parameter is less than zero.
         [in] IDirection* direction ///< The direction to move the path.
      );

      /// Creates a copy of the path. Copies all PathElements.
      [helpstring("method Clone"), helpcontext(IDH_Path_Clone)] HRESULT Clone([out, retval] IPath* *clone);

      /// A factory object used to create new Point2d objects
      [propget, helpstring("property PointFactory"), helpcontext(IDH_Path_PointFactory)] HRESULT PointFactory([out, retval]IPoint2dFactory* *factory);
      [propputref, helpstring("property PointFactory"), helpcontext(IDH_Path_PointFactory)] HRESULT PointFactory([in]IPoint2dFactory* factory);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")]  HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumPathElements interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumPathElements"), helpcontext(IDH_Path__EnumPathElements)] HRESULT _EnumPathElements([out, retval] IEnumPathElements** pVal);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for IPath events
   [
		object,
		uuid(BC341CD7-1B43-4f73-9975-93B02DD949F2),
		oleautomation,
		helpcontext(IDH_Path),
		helpstring("IPathEvents Interface"),
		pointer_default(unique)
	]
	interface IPathEvents : IUnknown
	{
      /// Called after the path is changed
	   [helpstring("event OnPathChanged"), helpcontext(IDH_Alignment_OnAlignmentChanged)] HRESULT OnPathChanged([in] IPath* path);
	};

   /// Interface for objects that enumerate a collection of IPath objects
   [
	   object,
	   uuid(D5BECD44-9730-4bf4-80B2-8B983C21E110),
	   helpstring("IEnumPaths Interface"),
	   //helpcontext(IDH_IEnumCrossSections),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumPaths : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumPaths** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt, ///< Number of elements being requested
         [out] IPath** rgelt, ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for objects that create Path objects
   [
		object,
		uuid(97990706-8447-459c-A05B-74540273CBE3),
		oleautomation,
		helpcontext(IDH_PathFactory),
		helpstring("PathFactory Interface"),
		pointer_default(unique)
	]
	interface IPathFactory : IUnknown
	{
      /// Returns a new Path object. The caller must define the path parameters.
      [helpstring("method CreatePath"), helpcontext(IDH_PathFactory_CreatePath)] HRESULT CreatePath([out,retval]IPath* *pVal);

      /// Evaluates a Path to determine if it is valid. Used by PathCollection objects to determine if a Path is valid when it is added to the collection.
		[helpstring("method IsValidType"), helpcontext(IDH_PathFactory_IsValidType)] HRESULT IsValidType([in]IPath* path,[out,retval]VARIANT_BOOL* bIsValid);
 
      /// The StructuredStorage property
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Interface for defining a collection of objects implementing the IPath interface.
   [
		object,
		uuid(DFDF1C35-39DB-4285-AA38-BE6C189E29E0),
		oleautomation,
		helpcontext(IDH_PathCollection),
		helpstring("IPathCollection Interface"),
		pointer_default(unique)
	]
	interface IPathCollection : IUnknown
	{
      /// Gets an item from the collection using its identifier.
      [propget, helpstring("property Item"), helpcontext(IDH_PathCollection_Item)] HRESULT Item([in] CogoObjectID id, [out, retval] IPath* *pVal);
      
      /// Replaces an item in the collection
      [propputref, helpstring("property Item"), helpcontext(IDH_PathCollection_Item)] HRESULT Item([in] CogoObjectID id, [in] IPath* pVal);
      
      /// Returns the number of items in the collection.
      [propget, helpstring("property Count"), helpcontext(IDH_PathCollection_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);
      
      /// Adds a path to the collection. The new path object is created with the IPathFactory object associated with this collection.
      [helpstring("method Add"), helpcontext(IDH_PathCollection_Add)] HRESULT Add(
         [in] CogoObjectID id, ///< Unique identifier for the path
         [out,retval] IPath* *path ///< A new Path object
      );

      /// Adds a path to the collection
        [helpstring("method AddEx"), helpcontext(IDH_PathCollection_AddEx)] HRESULT AddEx(
           [in] CogoObjectID id, ///< Unique identifier for the path
           [in] IPath* newVal ///< A Path Object
        );

        /// Removes a path from the collection
        [helpstring("method Remove"), helpcontext(IDH_PathCollection_Remove)] HRESULT Remove([in] CogoObjectID id);

        /// Removes all items from the collection
        [helpstring("method Clear"), helpcontext(IDH_PathCollection_Clear)] HRESULT Clear();

        /// Searches the collection for a path and returns its identifier
        [helpstring("method FindID"), helpcontext(IDH_PathCollection_FindID)] HRESULT FindID([in] IPath* path,[out,retval]CogoObjectID* ID);

        /// Returns the ID at a specific location in the collection
        [helpstring("method ID"), helpcontext(IDH_PathCollection_ID)] HRESULT ID([in] CollectionIndexType index,[out,retval] CogoObjectID* ID);

        /// A factory object used to create new Path objects
        [propget, helpstring("method Factory"), helpcontext(IDH_PathCollection_Factory)] HRESULT Factory([out, retval]IPathFactory** factory);
        [propputref, helpstring("method Factory"), helpcontext(IDH_PathCollection_Factory)] HRESULT Factory([in]IPathFactory* factory);

        /// Clones the collection making a copy of all the contained objects
        [helpstring("method Clone"), helpcontext(IDH_PathCollection_Clone)] HRESULT Clone([out, retval] IPathCollection* *clone);

        /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
        [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

        /// Returns an IEnumIDs interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
        [propget, restricted, helpstring("property _EnumIDs"), helpcontext(IDH_PathCollection__EnumIDs)] HRESULT _EnumIDs([out, retval] IEnumIDs** ppenum);

        /// Returns an IEnumPaths interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
        [propget, restricted, helpstring("property _EnumPaths"), helpcontext(IDH_PathCollection__EnumPaths)] HRESULT _EnumPaths([out, retval] IEnumPaths** ppenum);

        /// The StructuredStorage property.
        [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Callback interface for IPathCollection events
   [
		object,
		uuid(176DAD7B-1209-47ad-9AC7-8901C6AEC89A),
		oleautomation,
		helpcontext(IDH_PathCollection),
		helpstring("IPathCollectionEvents Interface"),
		pointer_default(unique)
	]
	interface IPathCollectionEvents : IUnknown
	{
      /// Called after a path is changed
      [helpstring("event OnPathChanged"), helpcontext(IDH_PathCollection_OnAlignmentChanged)] HRESULT OnPathChanged(
         [in]IPathCollection* coll, ///< The PathCollection containing the Path object that changed
         [in] CogoObjectID id, ///< ID of the Path that changed
         [in] IPath* path ///< The Path that changed
      );

      /// Called after a Path is added
       [helpstring("event OnPathAdded"), helpcontext(IDH_PathCollection_OnAlignmentAdded)] HRESULT OnPathAdded(
          [in]IPathCollection* coll, ///< The PathCollection containing the Path that was added
          [in] CogoObjectID id, ///< ID of the Path that was added
          [in] IPath* path ///< The Path that was added
       );

       /// Called after a Path is removed
       [helpstring("event OnPathRemoved"), helpcontext(IDH_PathCollection_OnAlignmentRemoved)] HRESULT OnPathRemoved(
          [in]IPathCollection* coll, ///< The PathCollection that contained the Path object that was removed
          [in] CogoObjectID id ///< ID of the Path that was removed
       );

       /// Called when the collection is cleared
       [helpstring("event OnPathsCleared"), helpcontext(IDH_PathCollection_OnAlignmentCleared)] HRESULT OnPathsCleared(
          [in]IPathCollection* coll ///< The PathCollection that was cleared.
       );
	};

   /// Interface defining an Alignment object
   [
		object,
		uuid(30638CFA-0F23-4784-8FC9-D1A2E4A50F02),
		oleautomation,
		helpcontext(IDH_Alignment),
		helpstring("IAlignment Interface"),
		pointer_default(unique)
	]
	interface IAlignment : IUnknown
	{
      /// A PathElement item in the alignment
      [propget, helpstring("property Item"), helpcontext(IDH_Alignment_Item)] HRESULT Item([in] CollectionIndexType idx,[out, retval] IPathElement* *pVal);
		[propputref, helpstring("property Item"), helpcontext(IDH_Alignment_Item)] HRESULT Item([in] CollectionIndexType idx,[in] IPathElement *pVal);

      /// The number of PathElement items in the alignment
      [propget, helpstring("property Count"), helpcontext(IDH_Alignment_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);

      /// The alignemnt reference station.
      ///
      /// The reference station defines the stationing of the entire alignment. The reference station is the station at the beginning of the first PathElement. 
      /// If the first PathElement represents an HorzCurve object, the reference station is at the TS point of the curve.
		[propget, helpstring("property RefStation"), helpcontext(IDH_Alignment_RefStation)] HRESULT RefStation([out, retval] IStation* *station);
		[propput, helpstring("property RefStation"), helpcontext(IDH_Alignment_RefStation)] HRESULT RefStation([in] VARIANT varStation);

      /// Returns a collection of StationEquation objects for this alignment
      [propget, helpstring("property StationEquations"), helpcontext(IDH_Alignment_StationEquations)] HRESULT StationEquations([out, retval] IStationEquationCollection* *pVal);

      /// Returns the Profile object associated with this alignment
		[propget, helpstring("property Profile"), helpcontext(IDH_Alignment_Profile)] HRESULT Profile([out, retval] IProfile* *pVal);

      /// Adds a PathElement to the alignment
 		[helpstring("method Add"), helpcontext(IDH_Alignment_Add)] HRESULT Add([in] IPathElement* element);

      /// Adds a Point2d, LineSegment2d, CubicSpline, or HorzCurve object to the alignment and creates a new PathElement object
      [helpstring("method AddEx"), helpcontext(IDH_Alignment_AddEx)] HRESULT AddEx([in] IUnknown* dispElement);

      /// Inserts a PathElement object into the alignment at the specified index.
      [helpstring("method Insert"), helpcontext(IDH_Alignment_Insert)] HRESULT Insert([in] CollectionIndexType idx,[in] IPathElement* element);
      
      /// Inserts a Point2d, LineSegment2d, CubicSpline, or HorzCurve object into the alignment at the specified index.
      [helpstring("method InsertEx"), helpcontext(IDH_Alignment_InsertEx)] HRESULT InsertEx([in] CollectionIndexType idx,[in] IUnknown* dispElement);

      /// Removes a PathElement from the alignment.
		[helpstring("method Remove"), helpcontext(IDH_Alignment_Remove)] HRESULT Remove(
         [in] VARIANT varIdxOrElement ///< VARIANT containing either the index of the PathElement to remove or an IDispatch or IUnknown interface for a PathElement, Point2d, LineSegment2d, CubicSpline, or HorzCurve object to be removed
      );

      /// Removes all PathElement objects from the alignment
      [helpstring("method Clear"), helpcontext(IDH_Alignment_Clear)] HRESULT Clear();

      /// Creates a Point object on the alignment at a specified location.
      /// \image html /Alignment/LocatePoint.jpg
		[helpstring("method LocatePoint"), helpcontext(IDH_Alignment_LocatePoint)] 
      HRESULT LocatePoint(
         [in] VARIANT varStation,  ///< Station from which the point is to be located
         [in] OffsetMeasureType offsetMeasure, ///< Specifies how offset is measured
         [in] Float64 offset,  ///< Offset from the path to the point
         [in] VARIANT varDir, ///< Direction from the path at which to locate the point
         [out,retval] IPoint2d* *newPoint///< The new point
      ); 

      /// Computes the bearing of the alignment at a specified station.
      /// \image html /Alignment/Bearing.jpg
      [helpstring("method Bearing"), helpcontext(IDH_Alignment_Bearing)] 
      HRESULT Bearing(
         [in] VARIANT varStation, ///< Station at which the bearing is to be computed
         [out,retval] IDirection* *dir ///< A Direction object representing the bearing
      );

      /// Computes the normal to the aligment at a specified station.
      /// \image html /Alignment/Normal.jpg
      [helpstring("method Normal"), helpcontext(IDH_Alignment_Normal)] 
      HRESULT Normal(
         [in] VARIANT varStation, ///< Station at which the norma/ is to be computed
         [out,retval] IDirection* *dir ///< A Direction object representing the normal
      );

      /// Projects a point onto the aligment
      /// \image html /Alignment/ProjectPoint.jpg
      [helpstring("method ProjectPoint"), helpcontext(IDH_Alignment_ProjectPoint)]
      HRESULT ProjectPoint(
         [in] IPoint2d* point, ///< The point to project onto the alignment
         [out, retval] IPoint2d* *newPoint ///< The point on the alignment
      );

      /// Computes the station and offset from the alignment for a given point
      /// \image html /Alignment/Offset.jpg
      [helpstring("method Offset"), helpcontext(IDH_Alignment_Offset)] 
      HRESULT Offset(
         [in] IPoint2d* point,///< The point whose station and offset is to be computed
         [out] IStation* *station, ///< The station where a normal line passing through point intersects the alignment
         [out] Float64* offset ///< The offset from the alignment to the point
      );

      /// Intersects a Line2d object with the alignment, projecting the start and end tangents, returning the intersection point nearest a specified point.
      [helpstring("method Intersect")] HRESULT Intersect(
         [in] ILine2d* line, ///< The line to intersect with the alignment.
         [in]IPoint2d* pNearest, ///< A point used for comparison with multiple intersection points.
         [out,retval]IPoint2d** point ///< The intersection point closed to pNearest.
      );

      /// Intersects a Line2d object with the Path returning the intersection point nearest a specified point.
      [helpstring("method IntersectEx")] HRESULT IntersectEx(
         [in]ILine2d* line, ///< The line to intersect with the alignment.
         [in]IPoint2d* pNearest, ///< A point used for comparison with multiple intersection points.
         [in]VARIANT_BOOL vbProjectBack, ///< If VARIANT_TRUE, the back tangent line at the start of the alignment is considered to be part of the alignment
         [in]VARIANT_BOOL vbProjectAhead, ///< If VARIANT_TRUE, the ahead tangent line at the end of the alignment is considered to be part of the alignment
         [out,retval]IPoint2d** point ///< The intersection point closed to pNearest.
      );

      /// Returns the length of the alignment
      [propget,helpstring("property Length")] HRESULT Length([out,retval]Float64* pLength);
      
      /// Creates a new Alignment that is parallel to the this Alignment.
      ///
      /// HorizCurve objects are degraded to points if the offset is on the same side of the Alignment as the center point and the offset exceeds the radius.
      /// CubicSpline objects are degraded to a point if lines normal to the spline at the control points intersect on the same side of the Alignment as the offset and the offset distance exceeds the distance from the spline to the intersection point.
      [helpstring("method CreateParallelAlignment"),helpcontext(IDH_Alignment_CreateParallelAlignment)] 
      HRESULT CreateParallelAlignment(
         [in] Float64 offset, ///< Offset to the new alignment. The new alignment is to the right of the original alignmen tfor positive values.
         [out,retval]IAlignment** alignment ///< The new Alignment object
      );

      /// Creates a new Alignment that is a subset of this Alignment.
      [helpstring("method CreateSubAlignment"),helpcontext(IDH_Alignment_CreateSubAlignment)] 
      HRESULT CreateSubAlignment(
         [in]VARIANT varStartStation, ///< Station of the start of the sub-alignment
         [in]VARIANT varEndStation, ///< Station of the end of the sub-alignment
         [out,retval]IAlignment** alignment ///< A new Alignment object
      );

      /// Creates a new Alignemnt object where all elements of the alignment are connect with PathElement objects.
      ///
      /// An alignment can have breaks in it's definition such as a sequence of points. Intermediate PathElement objects for line segments are assumed to bridge these breaks.
      /// This methods creates an Alignment object that explicitly includes the intermediate PathElement objects
      [helpstring("method CreateConnectedAlignment"),helpcontext(IDH_Alignment_CreateConnectedAlignment)] HRESULT CreateConnectedAlignment([out,retval]IAlignment** alignment);

      /// Creates a new Path that is parallel to the this Alignment.
      ///
      /// HorizCurve objects are degraded to points if the offset is on the same side of the Path as the center point and the offset exceeds the radius.
      /// CubicSpline objects are degraded to a point if lines normal to the spline at the control points intersect on the same side of the Path as the offset and the offset distance exceeds the distance from the spline to the intersection point.
      [helpstring("method CreateParallelPath"),helpcontext(IDH_Alignment_CreateParallelPath)] 
      HRESULT CreateParallelPath(
         [in] Float64 offset,///< Offset to the new path. The new path is to the right of the original path for positive values.
         [out,retval]IPath** path /// The new path.
      );

      /// Creates a new Path that is a subset of this Alignment.
      [helpstring("method CreateSubPath"),helpcontext(IDH_Alignment_CreateSubPath)] 
      HRESULT CreateSubPath(
         [in]VARIANT varStartStation, ///< Station at the start of the sub-path
         [in]VARIANT varEndStation, ///< Station at the end of the sub-path
         [out,retval]IPath** path ///< A new Path object
      );

      /// Creates a new Path object from this Alignment object where all elements of the path are connect with PathElement objects.
      ///
      /// A path can have breaks in it's definition such as a sequence of points. Intermediate PathElement objects for line segments are assumed to bridge these breaks.
      /// This methods creates a Path object that explicitly includes the intermediate PathElement objects
      [helpstring("method CreateConnectedPath"),helpcontext(IDH_Alignment_CreateConnectedPath)] HRESULT CreateConnectedPath([out,retval]IPath** path);

      /// Moves the alignment
      [helpstring("method Move"),helpcontext(IDH_Alignment_Move)] 
      HRESULT Move(
         [in] Float64 dist, ///< Distance to move the alignment. The alignemnt is moved in the opposite direction then the Direction object indicates when this parameter is less than zero.
         [in] IDirection* direction ///< The direction to move the alignment.
      );

      /// Gets the direction of a line at a specified station.
      ///
      /// The line orientation is a text string that represents an angle, a direction, or the keyword **Normal** indicating a line normal to the alignment. See \ref WBFL_COGO_Angles_Directions_Stations.
      [helpstring("method GetDirection")] 
      HRESULT GetDirection(
         [in] VARIANT varStation, ///< Station where the direction is to be determined
         [in] BSTR bstrOrientation, ///< Orientation of the line.
         [out,retval] IDirection** direction ///< A Direction object representing the line.
      );

      /// Computes the distance between stations, taking into account the station equations.
      ///
      /// Effectively computes \f$ distance = station2 - station1 \f$.
      [helpstring("method DistanceBetweenStations")] 
      HRESULT DistanceBetweenStations(
         [in] VARIANT station1, ///< The first station
         [in] VARIANT station2, ///< The second station
         [out,retval]Float64* pDist ///< The distance between stations.
      );

      /// Creates a copy of the alignment. Copies all PathElements.
      [helpstring("method Clone"), helpcontext(IDH_Alignment_Clone)] HRESULT Clone([out, retval] IAlignment* *clone);

      /// A factory object used to create new Point2d objects
      [propget, helpstring("property PointFactory"), helpcontext(IDH_Alignment_PointFactory)] HRESULT PointFactory([out, retval]IPoint2dFactory* *factory);
      [propputref, helpstring("property PointFactory"), helpcontext(IDH_Alignment_PointFactory)] HRESULT PointFactory([in]IPoint2dFactory* factory);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")]  HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumPathElements interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumAlignmentElements"), helpcontext(IDH_Alignment__EnumAlignmentElements)] HRESULT _EnumAlignmentElements([out, retval] IEnumPathElements** pVal);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for IAlignment events
   [
		object,
		uuid(D99C606A-2AFA-4779-92BF-D2FB7E71D3B2),
		oleautomation,
		helpcontext(IDH_Alignment),
		helpstring("IAlignmentEvents Interface"),
		pointer_default(unique)
	]
	interface IAlignmentEvents : IUnknown
	{
      /// Called after the alignemnt is changed
      [helpstring("event OnAlignmentChanged"), helpcontext(IDH_Alignment_OnAlignmentChanged)] HRESULT OnAlignmentChanged([in] IAlignment* alignment);

      /// Called after the profile is changed
	   [helpstring("event OnProfileChanged"), helpcontext(IDH_Alignment_OnProfileChanged)] HRESULT OnProfileChanged([in] IProfile* profile);

      /// Called after the station equations are changed
      [helpstring("event OnStationEquationsChanged"),helpcontext(IDH_Alignment_OnStationEquationsChanged)] HRESULT OnStationEquationsChanged([in]IStationEquationCollection* equations);
	};

   /// Interface for objects that enumerate a collection of IAlignment objects
   [
	   object,
	   uuid(AE7730EB-3289-45de-9158-0345C1B93879),
	   helpstring("IEnumAlignments Interface"),
	   //helpcontext(IDH_IEnumCrossSections),
	   oleautomation,
	   hidden,restricted,
	   pointer_default(unique)
	]
	interface IEnumAlignments : IUnknown
	{
      /// Clone the enumerator
      [helpstring("Clone")] HRESULT Clone([out] IEnumAlignments** ppenum);

      /// Retrieves the next celt items from the enumeration sequence. If there are fewer than the requested number of elements in the sequence, it retrieves the remaining elements. The number of elements actually retrieved is returned through pceltFetched (unless the caller passed in NULL for that parameter).
      /// Returns S_OK if the number of elements supplied is celt, otherwise S_FALSE
      [helpstring("Next")]
	   HRESULT Next(
         [in] ULONG celt,  ///< Number of elements being requested
         [out] IAlignment** rgelt,  ///< Array of size celt (or larger) of elements of interest
         [in,out] ULONG* pceltFetched ///< Pointer to the number of elements actually supplied in rgelt. Can be nullptr if celt is 1.
      );

      /// Resets the enumeration sequence to the beginning.
      [helpstring("Reset")] HRESULT Reset();
	   
      /// Skips over the next specified number of elements in the enumeration sequence.
      [helpstring("Skip")]
	   HRESULT Skip(
         [in] ULONG celt ///< Number of elements to skip
      );
	};

   /// Interface for objects that create Alignment objects
   [
		object,
		uuid(B19475E6-68F6-4afe-80CC-C513D0836508),
		oleautomation,
		helpcontext(IDH_AlignmentFactory),
		helpstring("IAlignmentFactory Interface"),
		pointer_default(unique)
	]
	interface IAlignmentFactory : IUnknown
	{
      /// Returns a new Aligment object. The caller must define the alignment parameters.
      [helpstring("method CreateAlignment"), helpcontext(IDH_AlignmentFactory_CreateAlignment)] HRESULT CreateAlignment([out,retval]IAlignment* *pVal);

      /// Evaluates an Alignment to determine if it is valid. Used by AlignmentCollection objects to determine if an Alignment is valid when it is added to the collection.
      [helpstring("method IsValidType"), helpcontext(IDH_AlignmentFactory_IsValidType)] HRESULT IsValidType([in]IAlignment* alignment,[out,retval]VARIANT_BOOL* bIsValid);
 
      /// The StructuredStorage property
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
	};

   /// Interface for defining a collection of objects implementing the IAlignment interface.
   [
		object,
		uuid(9982DEC2-337E-462f-84C6-9E3CE075DE65),
		oleautomation,
		helpcontext(IDH_AlignmentCollection),
		helpstring("IAlignmentCollection Interface"),
		pointer_default(unique)
	]
	interface IAlignmentCollection : IUnknown
	{
      /// Gets an item from the collection using its identifier.
      [propget, helpstring("property Item"), helpcontext(IDH_AlignmentCollection_Item)] HRESULT Item([in] CogoObjectID id, [out, retval] IAlignment* *pVal);
      
      /// Replaces an item in the collection
      [propputref, helpstring("property Item"), helpcontext(IDH_AlignmentCollection_Item)] HRESULT Item([in] CogoObjectID id, [in] IAlignment* pVal);
      
      /// Returns the number of items in the collection.
      [propget, helpstring("property Count"), helpcontext(IDH_AlignmentCollection_Count)] HRESULT Count([out, retval] CollectionIndexType *pVal);
      
      /// Adds an alignment to the collection. The new alignment object is created with the IAlignmentFactory object associated with this collection.
      [helpstring("method Add"), helpcontext(IDH_AlignmentCollection_Add)] HRESULT Add(
         [in] CogoObjectID id, ///< Unique identifier for the aligment
         [out,retval] IAlignment* *Alignment /// An Alignment object
      );

      /// Adds an alignment to the collection
      [helpstring("method AddEx"), helpcontext(IDH_AlignmentCollection_AddEx)] HRESULT AddEx(
         [in] CogoObjectID id, ///< Unique identifier for the alignment
         [in] IAlignment* newVal ///< An Alignment object
      );

      /// Removes a path from the collection
      [helpstring("method Remove"), helpcontext(IDH_AlignmentCollection_Remove)] HRESULT Remove([in] CogoObjectID id);
      
      /// Removes all items from the collection
      [helpstring("method Clear"), helpcontext(IDH_AlignmentCollection_Clear)] HRESULT Clear();
      
      /// Searches the collection for an alignment and returns its identifier
      [helpstring("method FindID"), helpcontext(IDH_AlignmentCollection_FindID)] HRESULT FindID([in] IAlignment* Alignment,[out,retval]CogoObjectID* ID);
      
      /// Returns the ID at a specific location in the collection
      [helpstring("method ID"), helpcontext(IDH_AlignmentCollection_ID)] HRESULT ID([in] CollectionIndexType index,[out,retval] CogoObjectID* ID);

      /// A factory object used to create new Alignment objects
      [propget, helpstring("method Factory"), helpcontext(IDH_AlignmentCollection_Factory)] HRESULT Factory([out, retval]IAlignmentFactory** factory);
      [propputref, helpstring("method Factory"), helpcontext(IDH_AlignmentCollection_Factory)] HRESULT Factory([in]IAlignmentFactory* factory);

      /// Clones the collection making a copy of all the contained objects
      [helpstring("method Clone"), helpcontext(IDH_AlignmentCollection_Clone)] HRESULT Clone([out, retval] IAlignmentCollection* *clone);

      /// Returns the IUnknown pointer of a generic enumerator. This is a restricted property and is used by Visual Basic to enumerator collections.
      [propget, restricted, helpstring("returns an enumerator for the collection.")] HRESULT _NewEnum([out, retval] IUnknown** retval);

      /// Returns an IEnumIDs interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumIDs"), helpcontext(IDH_AlignmentCollection__EnumIDs)] HRESULT _EnumIDs([out, retval] IEnumIDs** ppenum);

      /// Returns an IEnumPaths interface. This is a restricted property and is not accessible from Visual Basic. Generally, in C++, it is easier to iterate through a collection using an enumerator than the collection interface.
      [propget, restricted, helpstring("property _EnumAlignments"), helpcontext(IDH_AlignmentCollection__EnumAlignments)] HRESULT _EnumAlignments([out, retval] IEnumAlignments** ppenum);

      /// The StructuredStorage property.
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for IAlignmentCollection events
   [
		object,
		uuid(46D1C201-C51F-4eb1-AFCC-922DDBC62D16),
		oleautomation,
		helpcontext(IDH_AlignmentCollection),
		helpstring("IAlignmentCollectionEvents Interface"),
		pointer_default(unique)
	]
	interface IAlignmentCollectionEvents : IUnknown
	{
      /// Called after a profile is changed
	   [helpstring("event OnProfileChanged"), helpcontext(IDH_AlignmentCollection_OnProfileChanged)] 
      HRESULT OnProfileChanged(
         [in]IAlignmentCollection* coll, ///< The AligmentCollection containing the Alignment whose Profile changed
         [in] IProfile* profile ///< The Profile that changed
      );

      /// Called after station equations are changed
      [helpstring("event OnStationEquationsChanged"),helpcontext(IDH_AlignmentCollection_OnStationEquationsChanged)] 
      HRESULT OnStationEquationsChanged(
         [in]IAlignmentCollection* coll, ///< The AligmentCollection containing the Alignment whose StationEquationCollection changed
         [in]IStationEquationCollection* equations ///< The StationEquationCollection that changed.
      );

      /// Called after an alignment is changed
	   [helpstring("event OnAlignmentChanged"), helpcontext(IDH_AlignmentCollection_OnAlignmentChanged)] 
      HRESULT OnAlignmentChanged(
         [in]IAlignmentCollection* coll, ///< The AlignmentCollection containing the Alignment object that changed
         [in] CogoObjectID id, ///< ID of the Alignment that changed
         [in] IAlignment* Alignment ///< The Alignment that changed
      );

      /// Called after an Alignment is added
       [helpstring("event OnAlignmentAdded"), helpcontext(IDH_AlignmentCollection_OnAlignmentAdded)] 
       HRESULT OnAlignmentAdded(
          [in]IAlignmentCollection* coll, ///< The AlignmentCollection containing the Alignment that was added
          [in] CogoObjectID id, ///< ID of the Alignemnt that was added
          [in] IAlignment* Alignment ///< The Alignment that was added
       );

       /// Called after an Alignment is removed
       [helpstring("event OnAlignmentRemoved"), helpcontext(IDH_AlignmentCollection_OnAlignmentRemoved)] 
       HRESULT OnAlignmentRemoved(
          [in]IAlignmentCollection* coll, ///< The AlignmentCollection that contained the Alignment object that was removed
          [in] CogoObjectID id ///< ID of the Alignment that was removed
       );

       /// Called when the collection is cleared
       [helpstring("event OnAlignmentsCleared"), helpcontext(IDH_AlignmentCollection_OnAlignmentCleared)] 
       HRESULT OnAlignmentsCleared(
          [in]IAlignmentCollection* coll ///< THe AlignmentCollection that was cleared
       );
	};

   /// Interface for measuring angles, distances, and angles in a COGO model.
   [
        object,
        uuid(C659E538-5EBE-11d5-8C32-006097C68A9C),
        oleautomation,
		helpcontext(IDH_IMeasure),
        helpstring("IMeasure Interface"),
        pointer_default(unique)
    ]
    interface IMeasure : IUnknown
    {
       /// Measures the angle formed by three non-coincident points.
       ///
       /// \image html /Measure/Angle.jpg
        [helpstring("method Angle"),helpcontext(IDH_IMeasure_Angle)] HRESULT Angle(
           [in] CogoObjectID fromID, ///< ID of the point the angle is measured from
           [in] CogoObjectID vertexID, ///< ID of the point at the vertex of the angle
           [in] CogoObjectID toID, ///< ID of the point the angle is measured to
           [out,retval] IAngle** angle ///< The angle
        );

        /// Measures the angle of a polygon.
        ///
        /// \image html /Measure/Area.jpg
        /// The polygon must consist of at least three non-colinear points. Points may be defined either clockwise or counter-clockwise. The last point need not be the same as the first. 
        /// Degenerate polygons (polygon with intersecting edges such as a bow-tie shape) are not detected. An incorrect area will be computed if a degenerate polygon is input.
        /// This method is not available to JavaScript clients.However, as an alternative, you can use a WBFLGeometry::Polyshape object to compute area.
        [helpstring("method Area"),helpcontext(IDH_IMeasure_Area)] HRESULT Area(
           [in] VARIANT IDs, ///< An array of IDs identifying the points that comprise the polygon
           [out,retval] Float64* area ///< The area of the polygon
        );

        /// Measures the distance between two points.
        ///
        /// \image html /Measure/Distance.jpg
        [helpstring("method Distance"),helpcontext(IDH_IMeasure_Distance)] HRESULT Distance(
           [in] CogoObjectID fromID, ///< ID of the first point
           [in] CogoObjectID toID, ///< ID of the second point
           [out,retval] Float64* dist ///< Distance between the points
        );

        /// Measures the direction between two points.
        ///
        /// \image html /Measure/Direction.jpg
        [helpstring("method Direction"),helpcontext(IDH_IMeasure_Direction)] HRESULT Direction(
           [in] CogoObjectID fromID, ///< ID of the first point
           [in] CogoObjectID toID, ///< ID of the second point
           [out,retval] IDirection** dir ///< Direction of the line from the first to second point
        );

        /// Measures the distance and direction between two points.
        ///
        /// \image html /Measure/Direction.jpg
        [helpstring("method Inverse"),helpcontext(IDH_IMeasure_Inverse)] HRESULT Inverse(
           [in] CogoObjectID fromID, ///< ID of the first point
           [in] CogoObjectID toID, ///< ID of the second point
           [out] Float64* dist, ///< Distance between the points
           [out] IDirection** dir ///< Direction of the line from the first to second point
        );
    };

    /// Interface for measuring angles, distances, and angles
    [
        object,
        uuid(677836E0-0FC9-42b3-867E-F26D7DB5591D),
        oleautomation,
		helpcontext(IDH_IMeasure),
        helpstring("IMeasure2 Interface"),
        pointer_default(unique)
    ]
    interface IMeasure2 : IUnknown
    {
       /// Measures the angle formed by three non-coincident points.
       ///
       /// \image html /Measure2/Angle.jpg
       [helpstring("method Angle"),helpcontext(IDH_IMeasure_Angle)] HRESULT Angle(
          [in] IPoint2d* from, ///< Point the angle is measured from
          [in] IPoint2d* vertex, ///< Point at the vertex of the angle
          [in] IPoint2d* to, ///< Point the angle is measured to
          [out,retval] IAngle** angle ///< The angle
       );
       
       /// Measures the angle of a polygon.
       ///
       /// \image html /Measure2/Area.jpg
       /// The polygon must consist of at least three non-colinear points. Points may be defined either clockwise or counter-clockwise. The last point need not be the same as the first. 
       /// Degenerate polygons (polygon with intersecting edges such as a bow-tie shape) are not detected. An incorrect area will be computed if a degenerate polygon is input.
       [helpstring("method Area"),helpcontext(IDH_IMeasure_Area)] HRESULT Area(
          [in] IPoint2dCollection* points, ///< Collection of points that comprise the polygon
          [out,retval] Float64* area ///< The area of the polygon
       );

       /// Measures the distance between two points.
       ///
       /// \image html /Measure2/Distance.jpg
       [helpstring("method Distance"),helpcontext(IDH_IMeasure_Distance)] HRESULT Distance(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to, ///< The second point
          [out,retval] Float64* dist ///< Distance between the points
       );

       /// Measures the direction between two points.
       ///
       /// \image html /Measure2/Direction.jpg
       [helpstring("method Direction"),helpcontext(IDH_IMeasure_Direction)] HRESULT Direction(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to, ///< The second point
          [out,retval] IDirection** dir ///< Direction of the line from the first to second point
       );

       /// Measures the distance and direction between two points.
       ///
       /// \image html /Measure2/Direction.jpg
       [helpstring("method Inverse"),helpcontext(IDH_IMeasure_Inverse)] HRESULT Inverse(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to,///< The second point
          [out] Float64* dist, ///< Distance between the points
          [out] IDirection** dir ///< Direction of the line from the first to second point
       );
    };

    /// Interface for locating points and lines in a COGO model.
    [
        object,
        uuid(26FFDDD8-5EB8-11d5-8C32-006097C68A9C),
        oleautomation,
		helpcontext(IDH_ILocate),
        helpstring("ILocate Interface"),
        pointer_default(unique)
    ]
    interface ILocate : IUnknown
    {
       /// Locates a point by distance and angle
       /// \image html /Locate/ByDistAngle.jpg
        [helpstring("method ByDistAngle"),helpcontext(IDH_ILocate_ByDistAngle)] HRESULT ByDistAngle(
           [in] CogoObjectID newID, ///< ID for storing the new point
           [in] CogoObjectID fromID, ///< ID of the first point
           [in] CogoObjectID toID,  ///< ID of the second point
           [in] Float64 dist,  ///< Distance from the second point where the new point is located
           [in] VARIANT varAngle,  ///< Angle from the line between the first and second point at which to locate the new point
           [in] Float64 offset ///< Offset from the line between the first and second point.
        );

        /// Locates a point by distance and deflection angle
        /// \image html /Locate/ByDistDefAngle.jpg
        [helpstring("method ByDistDefAngle"),helpcontext(IDH_ILocate_ByDistDefAngle)] HRESULT ByDistDefAngle(
           [in] CogoObjectID newID, ///< ID for storing the new point
           [in] CogoObjectID fromID, ///< ID of the first point
           [in] CogoObjectID toID,  ///< ID of the second point
           [in] Float64 dist,  ///< Distance from the second point where the new point is located
           [in] VARIANT varDefAngle, ///< Deflection angle the line between the first and second point at which to locate the point
           [in] Float64 offset ///< Offset from the line between the first and second point.
        );

        /// Locates a point by distance and direction
        /// \image html /Locate/ByDistDir.jpg
        [helpstring("method ByDistDir"),helpcontext(IDH_ILocate_ByDistDir)] HRESULT ByDistDir(
           [in] CogoObjectID newID, ///< ID for storing the new point
           [in] CogoObjectID fromID, ///< ID of the point the new point is located from
           [in] Float64 dist, ///< Distance from the point to the new point
           [in] VARIANT varDir,  ///< Direction at which to locate the point
           [in] Float64 offset ///< Offset from the line defined by the point and direction
        );

        /// Locates a point on a line
        /// \image html /Locate/PointOnLine.jpg
        [helpstring("method PointOnLine"),helpcontext(IDH_ILocate_PointOnLine)] HRESULT PointOnLine(
           [in] CogoObjectID newID, ///< ID for storing the new point
           [in] CogoObjectID fromID,  ///< ID of the point the new point is located from
           [in] CogoObjectID toID,   ///< ID of the second point
           [in] Float64 dist, ///< Distance from the first point to the new point. If a negative value is used, the new point will be located before the start point.
           [in] Float64 offset ///< Offset from the line between the first and second point to the new point.
        );

        /// Locates a line parallel to a line defined by two points.
        /// \image html /Locate/ParallelLineByPoints.jpg
        [helpstring("method ParallelLineByPoints"),helpcontext(IDH_ILocate_ParallelLineByPoints)] HRESULT ParallelLineByPoints(
           [in] CogoObjectID newFromID, ///< ID for storing the new line start point
           [in] CogoObjectID newToID, ///< ID for storing the new line end point
           [in] CogoObjectID fromID, ///< ID of the start point of the line
           [in] CogoObjectID toID,  ///< ID of the end point of the line
           [in] Float64 offset ///< Offset from the source line to the new line.
        );

        /// Locates a parallel line segment.
        /// \image html /Locate/ParallelLineSegment.jpg
        [helpstring("method ParallelLineSegment"),helpcontext(IDH_ILocate_ParallelLineSegment)] HRESULT ParallelLineSegment(
           [in] CogoObjectID newLineID, ///< ID for storing the new line
           [in] CogoObjectID newFromID, ///< ID for storing the start point for the new line segment
           [in] CogoObjectID newToID, ///< ID for storing the end point for the new line segment
           [in] CogoObjectID lineID, ///< ID of the source line segment
           [in] Float64 offset ///< Offset from the source line segment
        );
    };

    /// Interfaoce for locating points and lines
    [
        object,
        uuid(2F0AAEBF-F043-4d50-8E11-709CF6079F5F),
        oleautomation,
		helpcontext(IDH_ILocate),
        helpstring("ILocate Interface"),
        pointer_default(unique)
    ]
    interface ILocate2 : IUnknown
    {
       /// Locates a point by distance and angle
       /// \image html /Locate2/ByDistAngle.jpg
       [helpstring("method ByDistAngle"),helpcontext(IDH_ILocate_ByDistAngle)] HRESULT ByDistAngle(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to, ///< The second point
          [in] Float64 dist, ///< Distance from the second point to the new point
          [in] VARIANT varAngle,  ///< Angle from the line between the first and second point at which to locate the new point
          [in] Float64 offset, ///< Offset from the line between the first and second point
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Locates a point by distance and deflection angle
       /// \image html /Locate2/ByDistDefAngle.jpg
       [helpstring("method ByDistDefAngle"),helpcontext(IDH_ILocate_ByDistDefAngle)] HRESULT ByDistDefAngle(
          [in] IPoint2d* from,  ///< The first point
          [in] IPoint2d* to, ///< The second point
          [in] Float64 dist, ///< Distance from the second point to the new point
          [in] VARIANT varDefAngle, ///< Deflection angle the line between the first and second point at which to locate the point
          [in] Float64 offset, ///< Offset from the line between the first and second point.
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Locates a point by distance and direction
       /// \image html /Locate2/ByDistDir.jpg
       [helpstring("method ByDistDir"),helpcontext(IDH_ILocate_ByDistDir)] HRESULT ByDistDir(
          [in] IPoint2d* from, ///< The point the new point is located from
          [in] Float64 dist, ///< Distance from the point to the new point
          [in] VARIANT varDir,  ///< Direction at which to locate the point
          [in] Float64 offset, ///< Offset from the line defined by the point and direction
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Locates a point on a line
       /// \image html /Locate2/PointOnLine.jpg
       [helpstring("method PointOnLine"),helpcontext(IDH_ILocate_PointOnLine)] HRESULT PointOnLine(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to, ///< The second point 
          [in] Float64 dist, ///< Distance from the first point to the new point. If a negative value is used, the new point will be located before the start point.
          [in] Float64 offset,///< Offset from the line between the first and second point to the new point.
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Locates a line parallel to a line defined by two points.
       /// \image html /Locate2/ParallelLineByPoints.jpg
       [helpstring("method ParallelLineByPoints"),helpcontext(IDH_ILocate_ParallelLineByPoints)] HRESULT ParallelLineByPoints(
          [in] IPoint2d* from, ///< The first point
          [in] IPoint2d* to,  ///< The second point
          [in] Float64 offset, ///< Offset from the soruce line to the new line
          [out]IPoint2d** p1, ///< Start point of the new line
          [out]IPoint2d** p2 ///< End point of the new line
       );

       /// Locates a parallel line segment.
       /// \image html /Locate2/ParallelLineSegment.jpg
       [helpstring("method ParallelLineSegment"),helpcontext(IDH_ILocate_ParallelLineSegment)] HRESULT ParallelLineSegment(
          [in] ILineSegment2d* ls, ///< A line segment
          [in] Float64 offset, ///< Offset from the line segment to the new line segment
          [out,retval]ILineSegment2d** linesegment ///< The new line segment
       );
    };

    /// Interface for intersecting lines and circles in a COGO model.
    [
        object,
        uuid(26FFDDD6-5EB8-11d5-8C32-006097C68A9C),
        oleautomation,
		helpcontext(IDH_IIntersect),
        helpstring("IIntersect Interface"),
        pointer_default(unique)
    ]
    interface IIntersect : IUnknown
    {
       /// Intersects two lines defined by point and direction.
       /// \image html /Intersect/Bearings.jpg
      [helpstring("method Bearings"),helpcontext(IDH_IIntersect_Bearings)] HRESULT Bearings(
         [in] CogoObjectID newID, ///< ID for storing the new point
         [in] CogoObjectID id1, ///< ID of a point on the first line
         [in] VARIANT varDir1,  ///< Direction of the first line
         [in] Float64 offset1, ///< Offset from the first line
         [in] CogoObjectID id2,  ///< ID of a point on the second line
         [in] VARIANT varDir2, ///< Direction of the second line
         [in] Float64 offset2,  ///< Offset from the second line
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects a line defined by a point and direction with a circle.
      /// \image html /Intersect/BearingCircle.jpg
      [helpstring("method BearingCircle"),helpcontext(IDH_IIntersect_BearingCircle)] HRESULT BearingCircle(
         [in]CogoObjectID newID, ///< ID for storing the new point
         [in] CogoObjectID id1,  ///< ID of a point on the line
         [in] VARIANT varDir, ///< Direction of the line
         [in] Float64 offset, ///< Offset from the line
         [in] CogoObjectID idc,  ///< ID of the circle center point 
         [in] Float64 radius,  ///< Circle radius
         [in] CogoObjectID idNearest,  ///< ID of a point that will be nearest the solution point in the event two intersection points are found
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );


      /// Intersects two circles
      /// \image html /Intersect/Circles.jpg
      [helpstring("method Circles"),helpcontext(IDH_IIntersect_Circles)] HRESULT Circles(
         [in]CogoObjectID newID, ///< ID for storing the new point
         [in] CogoObjectID id1,  ///< ID of the first circle center point
         [in] Float64 r1,  ///< Radius of the first circle
         [in] CogoObjectID id2,  ///< ID of the second circle center point
         [in] Float64 r2,  ///< Radius of the second circle
         [in] CogoObjectID idNearest,  ///< ID of a point that will be nearest the solution point in the event two intersection points are found 
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects a line defined by two points with a circle.
      /// \image html /Intersect/LineByPointsCircle.jpg
      [helpstring("method LineByPointsCircle"),helpcontext(IDH_IIntersect_LineByPointsCircle)] HRESULT LineByPointsCircle(
         [in]CogoObjectID newID, ///< ID for storing the new point
         [in] CogoObjectID id1, ///< ID of first point on the line
         [in] CogoObjectID id2,  ///< ID of the second point on the line
         [in] Float64 offset, ///< Offset from the line
         [in] CogoObjectID idc,  ///< ID of the circle center point
         [in] Float64 radius, ///< Circle radius
         [in] CogoObjectID idNearest,  ///< ID of a point that will be nearest the solution point in the event two intersection points are found 
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects two lines defined by points.
      /// \image html /Intersect/LinesByPoints.jpg
      [helpstring("method LinesByPoints"),helpcontext(IDH_IIntersect_LinesByPoints)] HRESULT LinesByPoints(
         [in]CogoObjectID newID, ///< ID for storing the new point
         [in] CogoObjectID id11, ///< ID of first point through which the first line passes
         [in] CogoObjectID id12,  ///< ID of second point through which the first line passes
         [in] Float64 offset1, ///< Offset from first line
         [in] CogoObjectID id21, ///< ID of first point through which the second line passes
         [in] CogoObjectID id22, ///< ID of second point through which the second line passes
         [in] Float64 offset2, ///< Offset from second line
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects two line segments.
      /// \image html /Intersect/Lines.jpg
      [helpstring("method Lines"),helpcontext(IDH_IIntersect_Lines)] HRESULT Lines(
         [in]CogoObjectID newID, ///< ID for storing the new point
         [in]CogoObjectID id1, ///< ID of first line segment
         [in]Float64 offset1, ///< Offset from first line segment
         [in]CogoObjectID id2, ///< ID of second line segment
         [in]Float64 offset2, ///< Offset from second line segment
         [out,retval]VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );

      /// Intersects a line segment and a circle
      /// \image html /Intersect/LineSegmentCircle.jpg
      [helpstring("method LineSegmentCircle"),helpcontext(IDH_IIntersect_LineSegmentCircle)] HRESULT LineSegmentCircle(
         [in]CogoObjectID newID, ///< ID for storing the new point
         [in] CogoObjectID lineID, ///< ID of the line segment
         [in] Float64 offset, ///< Offset from the line segment
         [in] CogoObjectID idc,  ///< ID of the circle center point
         [in] Float64 radius,  ///< Circle radius
         [in] CogoObjectID idNearest,  ///< ID of a point that will be nearest the solution point in the event two intersection points are found 
         [out,retval] VARIANT_BOOL* bFound ///< Set to VARIANT_TRUE if an intersection is found
      );
    };

    /// Interface for intersection lines and circles
    [
        object,
        uuid(5AFCF67A-4802-42cf-9C5C-AF5A61D4D0D4),
        oleautomation,
		helpcontext(IDH_IIntersect),
        helpstring("IIntersect Interface"),
        pointer_default(unique)
    ]
    interface IIntersect2 : IUnknown
    {
       /// Intersects two lines defined by point and direction.
       /// \image html /Intersect2/Bearings.jpg
       [helpstring("method Bearings"),helpcontext(IDH_IIntersect_Bearings)] HRESULT Bearings(
          [in] IPoint2d* p1, ///< First point on the first line
          [in] VARIANT varDir1,  ///< Direction of the first line
          [in] Float64 offset1, ///< Offset from the first line
          [in] IPoint2d* p2, ///< Point on the second line 
          [in] VARIANT varDir2,  ///< Direction of the second line
          [in] Float64 offset2,  ///< Offset from the second line
          [out,retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects a line defined by a point and direction with a circle.
       /// \image html /Intersect2/BearingCircle.jpg
       [helpstring("method BearingCircle"),helpcontext(IDH_IIntersect_BearingCircle)] HRESULT BearingCircle(
          [in] IPoint2d* p1, ///< Point on the line
          [in] VARIANT varDir,  ///< Direction of the line
          [in] Float64 offset, ///< Offset from the line
          [in] IPoint2d* center,  ///< Center of the circle
          [in] Float64 radius,  ///< Circle radius
          [in] IPoint2d* nearest,  ///< Point that will be nearest the solution point in the event two intersection points are found
          [out,retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects two circles
       /// \image html /Intersect2/Circles.jpg
       [helpstring("method Circles"),helpcontext(IDH_IIntersect_Circles)] HRESULT Circles(
          [in] IPoint2d* p1, ///< Center of first circle
          [in] Float64 r1, ///< Radius of first circle
          [in] IPoint2d* p2,  ///< Center of second circle
          [in] Float64 r2,  ///< Radius of second circle
          [in] IPoint2d* nearest,  ///< Point that will be nearest the solution point in the event two intersection points are found
          [out, retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects a line defined by two points with a circle.
       /// \image html /Intersect2/LineByPointsCircle.jpg
       [helpstring("method LineByPointsCircle"),helpcontext(IDH_IIntersect_LineByPointsCircle)] HRESULT LineByPointsCircle(
          [in] IPoint2d* p1, ///< First point on the line
          [in] IPoint2d* p2,  ///< Second point on the line
          [in] Float64 offset, ///< Offset from the line
          [in] IPoint2d* center,  ///< Center of the circle
          [in] Float64 radius,  ///< Circle radius
          [in] IPoint2d* nearest,  ///< Point that will be nearest the solution point in the event two intersection points are found
          [out, retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects two lines defined by points.
       /// \image html /Intersect2/LinesByPoints.jpg
       [helpstring("method LinesByPoints"),helpcontext(IDH_IIntersect_LinesByPoints)] HRESULT LinesByPoints(
          [in] IPoint2d* p11, ///< First point through which the first line passes
          [in] IPoint2d* p12, ///< Second point through which the first line passes 
          [in] Float64 offset1, ///< Offset from the first line
          [in] IPoint2d* p21,  ///< First point through which the second line passes
          [in] IPoint2d* p22,  ///< Second point through which the second line passes
          [in] Float64 offset2, ///< Offset from the second line
          [out,retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects two line segments.
       /// \image html /Intersect2/Lines.jpg
       [helpstring("method Lines"),helpcontext(IDH_IIntersect_Lines)] HRESULT Lines(
          [in]ILineSegment2d* l1, ///< First line segment
          [in]Float64 offset1, ///< Offset from first line segment
          [in]ILineSegment2d* l2, ///< Second line segment
          [in]Float64 offset2, ///< Offset from second line segment
          [out,retval] IPoint2d** point ///< The intersection point
       );

       /// Intersects a line segment and a circle
       /// \image html /Intersect2/LineSegmentCircle.jpg
       [helpstring("method LineSegmentCircle"),helpcontext(IDH_IIntersect_LineSegmentCircle)] HRESULT LineSegmentCircle(
          [in] ILineSegment2d* pSeg, ///< The line segment
          [in] Float64 offset, ///< Offset from the line segment
          [in] IPoint2d* center,  ///< Center of circle
          [in] Float64 radius,  ///< Circle radius
          [in] IPoint2d* nearest,  ///< Point that will be nearest the solution point in the event two intersection points are found
          [out, retval] IPoint2d** point ///< The intersection point
       );
    };

    /// Interface for creating points by projection onto lines and curves in a COGO model.
    [
        object,
        uuid(6B161BA4-6582-11d5-8C3D-006097C68A9C),
        oleautomation,
		helpcontext(IDH_IProject),
        helpstring("IProject Interface"),
        pointer_default(unique)
    ]
    interface IProject : IUnknown
    {
       /// Projects a point onto a HorzCurve. If the point projects before or after the TS or ST point on the curve, the projected point will be on the Back or Forward Tangent, respectively.
       /// \image html /Project/PointOnCurve.jpg
       [helpstring("method PointOnCurve"), helpcontext(IDH_IProject_PointOnCurve)] HRESULT PointOnCurve(
          [in]CogoObjectID newID,  ///< ID for storing the new point
          [in] CogoObjectID fromID, ///< ID of the point to project
          [in]CogoObjectID curveID ///< ID of the curve
       );

       /// Projects a point onto a line defined by two points.
       /// \image html /Project/PointOnLineByPoints.jpg
       [helpstring("method PointOnLineByPoints"),helpcontext(IDH_IProject_PointOnLineByPoints)] HRESULT PointOnLineByPoints(
          [in] CogoObjectID newID, ///< ID for storing the new point
          [in] CogoObjectID fromID, ///< ID of the point to be projected
          [in] CogoObjectID startID,  ///< ID of first point on the line
          [in] CogoObjectID endID, ///< ID of second point on the line
          [in] Float64 offset ///< Offset from the line
       );

       /// Projects a point onto a line segment.
       /// \image html /Project/PointOnLneSegment.jpg
       [helpstring("method PointOnLineSegment"),helpcontext(IDH_IProject_PointOnLineSegment)] HRESULT PointOnLineSegment(
          [in]CogoObjectID newID, ///< ID for storing the new point
          [in]CogoObjectID fromID, ///< ID of the point to be projected
          [in] CogoObjectID lineID, ///< ID of the line segment
          [in] Float64 offset ///< Offset from the line segment
       );
    };

    /// Interface for creating points by projection onto lines and curves.
    [
        object,
        uuid(FB5BBBA8-6CFD-4cfe-8A0B-DEAB8A7AF254),
        oleautomation,
		helpcontext(IDH_IProject),
        helpstring("IProject Interface"),
        pointer_default(unique)
    ]
    interface IProject2 : IUnknown
    {
       /// Projects a point onto a HorzCurve. If the point projects before or after the TS or ST point on the curve, the projected point will be on the Back or Forward Tangent, respectively.
       /// \image html /Project2/PointOnCurve.jpg
       [helpstring("method PointOnCurve"), helpcontext(IDH_IProject_PointOnCurve)] HRESULT PointOnCurve(
          [in] IPoint2d* pnt, ///< The point to project
          [in] IHorzCurve* curve,  ///< The HorzCurve
          [out, retval] IPoint2d** point ///< The new point
       );

       /// Projects a point onto a line defined by two points.
       /// \image html /Project2/PointOnLineByPoints.jpg
       [helpstring("method PointOnLineByPoints"),helpcontext(IDH_IProject_PointOnLineByPoints)] HRESULT PointOnLineByPoints(
          [in] IPoint2d* pnt, ///< The point to project
          [in] IPoint2d* start, ///< First point on the line
          [in] IPoint2d* end,  ///< Second point on the line
          [in] Float64 offset, ///< Offset from the line
          [out,retval]IPoint2d** point ///< The new point
       );

       /// Projects a point onto a line segment.
       /// \image html /Project2/PointOnLneSegment.jpg
       [helpstring("method PointOnLineSegment"),helpcontext(IDH_IProject_PointOnLineSegment)] HRESULT PointOnLineSegment(
          [in] IPoint2d* from, ///< The point to project
          [in] ILineSegment2d* seg,  ///< The line segment
          [in] Float64 offset, ///< Offset from the line segment
          [out,retval]IPoint2d** point ///< The new point
       );
    };

    /// Interface for creating points by dividing distances, lines, and arcs in a COGO model.
    [
      object,
      uuid(2754C92C-D653-40ef-875B-D4126671E5B5),
      oleautomation,
	  helpcontext(IDH_IDivide),
      helpstring("IDivide Interface"),
      pointer_default(unique)
   ]
   interface IDivide : IUnknown
   {
      /// Divides an arc into equal length segments.
      /// This method will divide an arc into nParts equally spaced points. nParts-2 points will be created. The end points of the arc are not duplicated. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DivideArc.jpg
      [helpstring("method Arc"),helpcontext(IDH_IDivide_Arc)] HRESULT Arc(
         [in]CogoObjectID firstID, ///< ID of the first new point
         [in] CogoObjectID idInc, ///< Point ID increment
         [in] CogoObjectID fromID,  ///< ID of the point the arc is measured from
         [in] CogoObjectID vertexID,  ///< ID of the vertex point
         [in] CogoObjectID toID, ///< ID of the point the arc is measured to
         [in] CollectionIndexType nParts ///< Number of parts to divide the arc into.
      );

      /// Divides the distance between two points.
      /// This method will divide a line segment defined by two points into nParts equally spaced points. nParts-2 points will be created. The end points of the line segment are not duplicated. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DivideBetweenPoints.jpg
      [helpstring("method BetweenPoints"),helpcontext(IDH_IDivide_BetweenPoints)] HRESULT BetweenPoints(
         [in]CogoObjectID firstID, ///< ID of the first new point
         [in] CogoObjectID idInc, ///< Point ID increment
         [in] CogoObjectID fromID,  ///< ID of the start line segment point
         [in] CogoObjectID toID, ///< ID of the end line segment point
         [in] CollectionIndexType nParts ///< Number of parts to divide the line segment into.
      );

      /// Divides a line segment.
      /// This method will divide a line segment into nParts equally spaced points. nParts-2 points will be created. The end points of the line segment are not duplicated. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DivideLineSegment.jpg
      [helpstring("method LineSegment"),helpcontext(IDH_IDivide_LineSegment)] HRESULT LineSegment(
         [in]CogoObjectID firstID, ///< ID of the first new point
         [in] CogoObjectID idInc,  ///< Point ID increment
         [in] CogoObjectID lineID, ///< ID of the line segment
         [in] CollectionIndexType nParts ///< Number of parts to divide the line segment into.
      );

      /// Divides a HorzCurve.
      /// This method will divide a horizontal curve into nParts equally spaced points. nParts-2 points will be created. The end points of the horizontal curve (TS and ST) are not duplicated. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DivideHorzCurve.jpg
      [helpstring("method HorzCurve"),helpcontext(IDH_IDivide_HorzCurve)] HRESULT HorzCurve(
         [in]CogoObjectID firstID,  ///< ID of the first new point
         [in] CogoObjectID idInc,  ///< Point ID increment
         [in] CogoObjectID curveID, ///< ID of the HorzCurve
         [in] CollectionIndexType nParts ///< Number of parts to divide the HorzCurve into.
      );

      /// Divides a Path.
      /// This method will divide a path into nParts equally spaced points. nParts+1 points will be created. Points will not be generated if points with the same ID already exist in the CogoModel.
      /// \image html /Divide/DividePath.png
      [helpstring("method Path"),helpcontext(IDH_IDivide_Path)] HRESULT Path(
         [in]CogoObjectID firstID,///< ID of the first new point
         [in]CogoObjectID idInc,///< Point ID increment
         [in] CogoObjectID pathID, ///< ID of the Path
         [in] CollectionIndexType nParts, ///< Number of parts to divide the Path into.
         [in] Float64 start, ///< Distance from the start of the path to the start of the divided range
         [in] Float64 end ///< Distance from the start of the path to the end of the divided range
      );
   };

   /// Interface for creating points by dividing distances, lines, and arcs.
   [
      object,
      uuid(BF909705-8DEE-4797-A497-4BEDB2156BB5),
      oleautomation,
	  helpcontext(IDH_IDivide),
      helpstring("IDivide Interface"),
      pointer_default(unique)
   ]
   interface IDivide2 : IUnknown
   {
      /// Divides an arc into equal length segments.
      /// This method will divide an arc into nParts equally spaced points. nParts-2 points will be created. The end points of the arc are not duplicated.
      /// \image html /Divide2/DivideArc.jpg
      [helpstring("method Arc"),helpcontext(IDH_IDivide_Arc)] HRESULT Arc(
         [in] IPoint2d* from, ///< Point arc is measured from
         [in] IPoint2d* vertex,  ///< Vertex point
         [in] IPoint2d* to, ///< Point arc is measured to
         [in] CollectionIndexType nParts, ///< Number of parts to divide the arc into.
         [out,retval] IPoint2dCollection** points ///< A collection of the resulting points.
      );

      /// Divides the distance between two points.
      /// This method will divide a line segment defined by two points into nParts equally spaced points. nParts-2 points will be created. The end points of the line segment are not duplicated.
      /// \image html /Divide2/DivideBetweenPoints.jpg
      [helpstring("method BetweenPoints"),helpcontext(IDH_IDivide_BetweenPoints)] HRESULT BetweenPoints(
         [in] IPoint2d* from, ///< Start point
         [in] IPoint2d* to,///< End points
         [in] CollectionIndexType nParts, ///< Number of parts to divide the line segment into.
         [out,retval] IPoint2dCollection** points ///< A collection of the resulting points.
      );

      /// Divides a line segment.
      /// This method will divide a line segment into nParts equally spaced points. nParts-2 points will be created. The end points of the line segment are not duplicated.
      /// \image html /Divide2/DivideLineSegment.jpg
      [helpstring("method LineSegment"),helpcontext(IDH_IDivide_LineSegment)] HRESULT LineSegment(
         [in] ILineSegment2d* seg, ///< Line segment to divide
         [in] CollectionIndexType nParts, ///< Number of parts to divide the line segment into.
         [out,retval]IPoint2dCollection** points ///< A collection of the resulting points.
      );

      /// Divides a HorzCurve.
      /// This method will divide a horizontal curve into nParts equally spaced points. nParts-2 points will be created. The end points of the horizontal curve (TS and ST) are not duplicated.
      /// \image html /Divide2/DivideHorzCurve.jpg
      [helpstring("method HorzCurve"),helpcontext(IDH_IDivide_HorzCurve)] HRESULT HorzCurve(
         [in] IHorzCurve* curve, ///< HorzCurve to divide
         [in] CollectionIndexType nParts,  ///< Number of parts to divide the HorzCurve into.
         [out,retval] IPoint2dCollection** points ///< A collection of the resulting points.
      );

      /// Divides a Path.
      /// This method will divide a path into nParts equally spaced points. nParts+1 points will be created.
      /// \image html /Divide2/DividePath.png
      [helpstring("method Path"),helpcontext(IDH_IDivide_Path)] HRESULT Path(
         [in]IPath* pPath, ///< The Path to divide
         [in] CollectionIndexType nParts, ///< Number of parts to divide the Path into.
         [in] Float64 start, ///< Distance from the start of the path to the start of the divided range
         [in] Float64 end, ///< Distance from the start of the path to the end of the divided range
         [out,retval]IPoint2dCollection** points ///< A collection of the resulting points.
      );
   };

   /// Interface for locating tangents to curves in a COGO model.
   [
      object,
      uuid(E2984C32-607E-4ca3-8424-F8041D5F49D1),
      oleautomation,
	  helpcontext(IDH_ITangent),
      helpstring("ITangent Interface"),
      pointer_default(unique)
   ]
   interface ITangent : IUnknown
   {
      /// Locates points tangent to two circles where the tangent lines cross between circles.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent/Cross.gif
      [helpstring("method Cross"),helpcontext(IDH_ITangent_Cross)] HRESULT Cross(
         [in] CogoObjectID newID1,  ///< ID of the new point on the first circle
         [in] CogoObjectID idCenter1,  ///< ID of first circle center point
         [in] Float64 radius1, ///< First circle radius
         [in] CogoObjectID newID2, ///< ID of the new point on the second circle
         [in] CogoObjectID idCenter2,  ///< ID of the second circle center point
         [in] Float64 radius2,  ///< Second circle radius
         [in] TangentSignType tangent ///< Indicates which of the two tangent lines to use to locate the tangent points
      );

      /// Locates points tangent to two circles where the tangent lines are external to the circles.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent/External.gif
      [helpstring("method External"), helpcontext(IDH_ITangent_External)] HRESULT External(
         [in] CogoObjectID newID1,  ///< ID of the new point on the first circle
         [in] CogoObjectID idCenter1,  ///< ID of first circle center point
         [in] Float64 radius1, ///< First circle radius
         [in] CogoObjectID newID2, ///< ID of the new point on the second circle
         [in] CogoObjectID idCenter2,  ///< ID of the second circle center point
         [in] Float64 radius2,  ///< Second circle radius
         [in] TangentSignType tangent ///< Indicates which of the two tangent lines to use to locate the tangent points
      );

      /// Locates point tangent to a circle.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent/Point.gif
      [helpstring("method Point"),helpcontext(IDH_ITangent_Point)] HRESULT Point(
         [in] CogoObjectID newID,  ///< ID of the new point
         [in] CogoObjectID idCenter,  ///< ID of the circle center point
         [in] Float64 radius, ///< Circle radius
         [in] CogoObjectID pointID, ///< ID of the point forming a line passing through the circle center point
         [in] TangentSignType tangent ///< Indicates which of the two tangent lines to use to locate the tangent points
      );
   };

   /// Interface for locating tangents to curves.
   [
      object,
      uuid(F51A43BB-85DD-41a1-9B32-B61D9005B0D0),
      oleautomation,
	  helpcontext(IDH_ITangent),
      helpstring("ITangent Interface"),
      pointer_default(unique)
   ]
   interface ITangent2 : IUnknown
   {
      /// Locates points tangent to two circles where the tangent lines cross between circles.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent2/Cross.gif
      [helpstring("method Cross"),helpcontext(IDH_ITangent_Cross)] HRESULT Cross(
         [in] IPoint2d* center1, ///< Center of the first circle
         [in] Float64 radius1, ///< Radius of the first circle
         [in] IPoint2d* center2,  ///< Center of the second circle
         [in] Float64 radius2,  ///< Radius of the second circle
         [in] TangentSignType tangent,  ///< Indicates which of the two tangent lines to use to locate the tangent points
         [out] IPoint2d** t1, ///< Tangent point on first circle
         [out] IPoint2d** t2 ///< Tangent point on second circle
      );

      /// Locates points tangent to two circles where the tangent lines are external to the circles.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent2/External.gif
      [helpstring("method External"), helpcontext(IDH_ITangent_External)] HRESULT External(
         [in] IPoint2d* center1, ///< Center of the first circle
         [in] Float64 radius1, ///< Radius of the first circle
         [in] IPoint2d* center2,  ///< Center of the second circle
         [in] Float64 radius2,  ///< Radius of the second circle
         [in] TangentSignType tangent,  ///< Indicates which of the two tangent lines to use to locate the tangent points
         [out] IPoint2d** t1, ///< Tangent point on first circle
         [out] IPoint2d** t2 ///< Tangent point on second circle
      );

      /// Locates point tangent to a circle.
      /// If tangent is tsCW then the points indicated in the figure are located. If tangent is tsCCW, then the tangent points on the opposite tangent are located.
      /// \image html /Tangent2/Point.gif
      [helpstring("method Point"),helpcontext(IDH_ITangent_Point)] HRESULT Point(
         [in] IPoint2d* center, ///< Center of the circle
         [in] Float64 radius, ///< Circle radius
         [in] IPoint2d* point, ///< Point forming a line passing through the circle center point
         [in] TangentSignType tangent,  ///< Indicates which of the two tangent lines to use to locate the tangent points
         [out] IPoint2d** pntTangent ///< The tangent point
      );
   };

   /// Interface defining a coordinate geometry computational engine
	[
		object,
		uuid(AF7FCB40-3E8B-45BE-B8E9-AC8ADF4DDB81),
	
		helpstring("ICogoEngine Interface"),
		pointer_default(unique)
	]
	interface ICogoEngine : IUnknown
	{
      /// Interface for computing intersections
      [propget, helpstring("property Intersect"),helpcontext(IDH_CogoModel_Intersect)] HRESULT Intersect([out, retval] IIntersect2* *pVal);

      /// Interface for locating points
      [propget, helpstring("property Locate"),helpcontext(IDH_CogoModel_Locate)] HRESULT Locate([out, retval] ILocate2* *pVal);

      /// Interface for measring angles, distances, and area
      [propget, helpstring("property Measure"),helpcontext(IDH_CogoModel_Measure)] HRESULT Measure([out, retval] IMeasure2* *pVal);

      /// Interface for locating points by projection
      [propget, helpstring("property Project"),helpcontext(IDH_CogoModel_Project)] HRESULT Project([out, retval] IProject2* *pVal);

      /// Interface for creating points by dividing distances, lines, and curves
      [propget, helpstring("property Divide"),helpcontext(IDH_CogoModel_Divide)] HRESULT Divide([out, retval] IDivide2* *pVal);

      /// Interface for locating points tangent to circles
      [propget, helpstring("property Tangent"),helpcontext(IDH_CogoModel_Tangent)] HRESULT Tangent([out, retval] ITangent2* *pVal);

      /// Factory for creating Point2d objects
      [propputref, helpstring("property PointFactory"),helpcontext(IDH_CogoModel_PointFactory)] HRESULT PointFactory([in]IPoint2dFactory* factory);
      [propget, helpstring("property PointFactory"),helpcontext(IDH_CogoModel_PointFactory)] HRESULT PointFactory([out,retval]IPoint2dFactory** factory);

      /// Factory for creating LineSegment2d objects
      [propputref, helpstring("property LineSegmentFactory"),helpcontext(IDH_CogoModel_LineSegmentFactory)] HRESULT LineSegmentFactory([in]ILineSegment2dFactory* factory);
      [propget, helpstring("property LineSegmentFactory"),helpcontext(IDH_CogoModel_LineSegmentFactory)] HRESULT LineSegmentFactory([out,retval]ILineSegment2dFactory** factory);
	};

   /// Interface defining a coordinate geometry model.
   ///
   /// Points, LineSegments, Vertical Curves, Horizontal Curves, Alignments, and Paths are stored and identified by a unique identifier.
   [
       object,
       uuid(B9E4933C-5E73-11D5-8C32-006097C68A9C),
       oleautomation,
	   helpcontext(IDH_CogoModel),
       helpstring("ICogoModel Interface"),
       pointer_default(unique)
   ]
   interface ICogoModel : IUnknown
   {
      /// The Point collection
      [propget, helpstring("property Points"),helpcontext(IDH_CogoModel_Points)] HRESULT Points([out, retval] IPointCollection* *pVal);

      /// The LineSegment collection
      [propget, helpstring("property LineSegments"),helpcontext(IDH_CogoModel_LineSegments)] HRESULT LineSegments([out, retval] ILineSegmentCollection* *pVal);

      /// The ProfilePoint collection
      [propget, helpstring("property ProfilePoints"),helpcontext(IDH_CogoModel_ProfilePoints)] HRESULT ProfilePoints([out, retval] IProfilePointCollection* *pVal);

      /// The VertCurve collection
      [propget, helpstring("property VertCurves"),helpcontext(IDH_CogoModel_VertCurves)] HRESULT VertCurves([out, retval] IVertCurveCollection* *pVal);

      /// The HorzCurve collection
      [propget, helpstring("property HorzCurves"),helpcontext(IDH_CogoModel_HorzCurves)] HRESULT HorzCurves([out, retval] IHorzCurveCollection* *pVal);

      /// The Alignment collection
      [propget, helpstring("property Alignments"),helpcontext(IDH_CogoModel_Alignments)] HRESULT Alignments([out,retval] IAlignmentCollection* *pVal);

      /// The Path collection
      [propget, helpstring("property Paths"),helpcontext(IDH_CogoModel_Alignments)] HRESULT Paths([out,retval] IPathCollection* *pVal);

      /// Clears the entire COGO model
      [helpstring("method Clear"),helpcontext(IDH_CogoModel_Clear)] HRESULT Clear();

      /// Interface for computing intersections
      [propget, helpstring("property Intersect"),helpcontext(IDH_CogoModel_Intersect)] HRESULT Intersect([out, retval] IIntersect* *pVal);

      /// Interface for locating points
      [propget, helpstring("property Locate"),helpcontext(IDH_CogoModel_Locate)] HRESULT Locate([out, retval] ILocate* *pVal);

      /// Interface for measring angles, distances, and area
      [propget, helpstring("property Measure"),helpcontext(IDH_CogoModel_Measure)] HRESULT Measure([out, retval] IMeasure* *pVal);

      /// Interface for locating points by projection
      [propget, helpstring("property Project"),helpcontext(IDH_CogoModel_Project)] HRESULT Project([out, retval] IProject* *pVal);

      /// Interface for creating points by dividing distances, lines, and curves
      [propget, helpstring("property Divide"),helpcontext(IDH_CogoModel_Divide)] HRESULT Divide([out, retval] IDivide* *pVal);

      /// Interface for locating points tangent to circles
      [propget, helpstring("property Tangent"),helpcontext(IDH_CogoModel_Tangent)] HRESULT Tangent([out, retval] ITangent* *pVal);

      /// Factory for creating Point2d objects
      [propputref, helpstring("property PointFactory"),helpcontext(IDH_CogoModel_PointFactory)] HRESULT PointFactory([in]IPoint2dFactory* factory);
      [propget, helpstring("property PointFactory"),helpcontext(IDH_CogoModel_PointFactory)] HRESULT PointFactory([out,retval]IPoint2dFactory** factory);

      /// Factory for creating LineSegment2d objects
      [propputref, helpstring("property LineSegmentFactory"),helpcontext(IDH_CogoModel_LineSegmentFactory)] HRESULT LineSegmentFactory([in]ILineSegment2dFactory* factory);
      [propget, helpstring("property LineSegmentFactory"),helpcontext(IDH_CogoModel_LineSegmentFactory)] HRESULT LineSegmentFactory([out,retval]ILineSegment2dFactory** factory);

      /// Factory for creating ProfilePoint objects
      [propputref, helpstring("property ProfilePointFactory"),helpcontext(IDH_CogoModel_ProfilePointFactory)] HRESULT ProfilePointFactory([in]IProfilePointFactory* factory);
      [propget, helpstring("property ProfilePointFactory"),helpcontext(IDH_CogoModel_ProfilePointFactory)] HRESULT ProfilePointFactory([out,retval]IProfilePointFactory** factory);

      /// Factory for creating VertCurve objects
      [propputref, helpstring("property VertCurveFactory"),helpcontext(IDH_CogoModel_VertCurveFactory)] HRESULT VertCurveFactory([in]IVertCurveFactory* factory);
      [propget, helpstring("property VertCurveFactory"),helpcontext(IDH_CogoModel_VertCurveFactory)] HRESULT VertCurveFactory([out,retval]IVertCurveFactory** factory);

      /// Factory for creating HorzCurve objects
      [propputref, helpstring("property HorzCurveFactory"),helpcontext(IDH_CogoModel_HorzCurveFactory)] HRESULT HorzCurveFactory([in]IHorzCurveFactory* factory);
      [propget, helpstring("property HorzCurveFactory"),helpcontext(IDH_CogoModel_HorzCurveFactory)] HRESULT HorzCurveFactory([out,retval]IHorzCurveFactory** factory);

      /// Factory for creating Alignment objects
      [propputref, helpstring("property AlignmentFactory"),helpcontext(IDH_CogoModel_AlignmentFactory)] HRESULT AlignmentFactory([in]IAlignmentFactory* factory);
      [propget, helpstring("property AlignmentFactory"),helpcontext(IDH_CogoModel_AlignmentFactory)] HRESULT AlignmentFactory([out,retval]IAlignmentFactory** factory);

      /// Factory for creating Path objects
      [propputref, helpstring("property PathFactory"),helpcontext(IDH_CogoModel_PathFactory)] HRESULT PathFactory([in]IPathFactory* factory);
      [propget, helpstring("property PathFactory"),helpcontext(IDH_CogoModel_PathFactory)] HRESULT PathFactory([out,retval]IPathFactory** factory);

      /// Provides access to the underlying CogoEngine object
      [propget, helpstring("property Engine")/*,helpcontext(IDH_CogoModel_Engine)*/] HRESULT Engine([out,retval]ICogoEngine** engine);

      /// Creates a clone of the COGO model and all stored geometric elements
      [helpstring("property Clone"), helpcontext(IDH_CogoModel_Clone)] HRESULT Clone([out,retval] ICogoModel* *clone);

      /// The StructuredStorage property
      [propget, helpstring("property StructuredStorage")/*,helpcontext(IDH_StructuredStorage)*/] HRESULT StructuredStorage([out, retval] IStructuredStorage2* *pVal);
   };

   /// Callback interface for ICogoModel events
   [
       object,
       uuid(BBD4B66A-6102-11d5-8C3A-006097C68A9C),
       oleautomation,
	   helpcontext(IDH_CogoModel),
       helpstring("ICogoModelEvents Interface"),
       pointer_default(unique)
   ]
   interface ICogoModelEvents : IUnknown
   {
      /// Called when a point in a model changes
       [helpstring("event OnPointChanged"),helpcontext(IDH_CogoModel_OnPointChanged)] HRESULT OnPointChanged([in] ICogoModel* cm,[in] CogoObjectID id,[in] IPoint2d* point);

       /// Called when a point is added to a model
       [helpstring("event OnPointAdded"),helpcontext(IDH_CogoModel_OnPointAdded)] HRESULT OnPointAdded([in] ICogoModel* cm,[in] CogoObjectID id,[in] IPoint2d* point);

       /// Called when a point is removed from a model
       [helpstring("event OnPointRemoved"),helpcontext(IDH_CogoModel_OnPointRemoved)] HRESULT OnPointRemoved([in] ICogoModel* cm,[in] CogoObjectID id);

       /// Called when the points in a model are cleared
       [helpstring("event OnPointsCleared"),helpcontext(IDH_CogoModel_OnPointsCleared)] HRESULT OnPointsCleared([in] ICogoModel* cm);

       /// Called when a line segment in a model changes
       [helpstring("event OnLineSegmentChanged"),helpcontext(IDH_CogoModel_OnLineSegmentChanged)] HRESULT OnLineSegmentChanged([in] ICogoModel* cm,[in] CogoObjectID id,[in] ILineSegment2d* lineSeg);

       /// Called when a line segment is added to a model
       [helpstring("event OnLineSegmentAdded"),helpcontext(IDH_CogoModel_OnLineSegmentAdded)] HRESULT OnLineSegmentAdded([in] ICogoModel* cm,[in] CogoObjectID id,[in] ILineSegment2d* lineSeg);

       /// Called when a line segment is removed from a model
       [helpstring("event OnLineSegmentRemoved"),helpcontext(IDH_CogoModel_OnLineSegmentRemoved)] HRESULT OnLineSegmentRemoved([in] ICogoModel* cm,[in] CogoObjectID id);

       /// Called when the line segments in a model are cleared
       [helpstring("event OnLineSegmentsCleared"),helpcontext(IDH_CogoModel_OnLineSegmentsCleared)] HRESULT OnLineSegmentsCleared([in] ICogoModel* cm);

       /// Called when a profile point in a model changes
       [helpstring("event OnProfilePointChanged"),helpcontext(IDH_CogoModel_OnProfilePointChanged)] HRESULT OnProfilePointChanged([in] ICogoModel* cm,[in] CogoObjectID id,[in] IProfilePoint* pp);

       /// Called when a profile point is added to a model
       [helpstring("event OnProfilePointAdded"),helpcontext(IDH_CogoModel_OnProfilePointAdded)] HRESULT OnProfilePointAdded([in] ICogoModel* cm,[in] CogoObjectID id,[in] IProfilePoint* pp);

       /// Called when a profile point is removed from a model
       [helpstring("event OnProfilePointRemoved"),helpcontext(IDH_CogoModel_OnProfilePointRemoved)] HRESULT OnProfilePointRemoved([in] ICogoModel* cm,[in] CogoObjectID id);

       /// Called when the profile points in a model are cleared
       [helpstring("event OnProfilePointsCleared"),helpcontext(IDH_CogoModel_OnProfilePointsCleared)] HRESULT OnProfilePointsCleared([in] ICogoModel* cm);

       /// Called when a vertical curve in a model changes
       [helpstring("event OnVertCurveChanged"),helpcontext(IDH_CogoModel_OnVertCurveChanged)] HRESULT OnVertCurveChanged([in] ICogoModel* cm,[in] CogoObjectID id,[in] IVertCurve* vc);

       /// Called when a vertical curve is added to a model
       [helpstring("event OnVertCurveAdded"),helpcontext(IDH_CogoModel_OnVertCurveAdded)] HRESULT OnVertCurveAdded([in] ICogoModel* cm,[in] CogoObjectID id,[in] IVertCurve* vc);

       /// Called when a vertical curve is removed from a model
       [helpstring("event OnVertCurveRemoved"),helpcontext(IDH_CogoModel_OnVertCurveRemoved)] HRESULT OnVertCurveRemoved([in] ICogoModel* cm,[in] CogoObjectID id);

       /// Called when the vertical curves in a model are cleared
       [helpstring("event OnVertCurvesCleared"),helpcontext(IDH_CogoModel_OnVertCurvesCleared)] HRESULT OnVertCurvesCleared([in] ICogoModel* cm);

       /// Called when a horizontal curve in a model changes
       [helpstring("event OnHorzCurveChanged"),helpcontext(IDH_CogoModel_OnHorzCurveChanged)] HRESULT OnHorzCurveChanged([in] ICogoModel* cm,[in] CogoObjectID id,[in] IHorzCurve* vc);

       /// Called when a horizontal curve is added to a model
       [helpstring("event OnHorzCurveAdded"),helpcontext(IDH_CogoModel_OnHorzCurveAdded)] HRESULT OnHorzCurveAdded([in] ICogoModel* cm,[in] CogoObjectID id,[in] IHorzCurve* vc);

       /// Called when a horizontal curve is removed from a model
       [helpstring("event OnHorzCurveRemoved"),helpcontext(IDH_CogoModel_OnHorzCurveRemoved)] HRESULT OnHorzCurveRemoved([in] ICogoModel* cm,[in] CogoObjectID id);
       
       /// Called when the horizontal curves in a model are cleared
       [helpstring("event OnHorzCurvesCleared"),helpcontext(IDH_CogoModel_OnHorzCurvesCleared)] HRESULT OnHorzCurvesCleared([in] ICogoModel* cm);

       /// Called when a profile in a model changes
       [helpstring("event OnProfileChanged"),helpcontext(IDH_CogoModel_OnProfileChanged)] HRESULT OnProfileChanged([in] ICogoModel* cm,[in] IProfile* profile);
       
       /// Called when station equations in a model changes
       [helpstring("event OnStationEquationsChanged"),helpcontext(IDH_CogoModel_OnStationEquationsChanged)] HRESULT OnStationEquationsChanged([in] ICogoModel* cm,[in] IStationEquationCollection* equations);

       /// Called when an alignment in a model changes
       [helpstring("event OnAlignmentChanged"),helpcontext(IDH_CogoModel_OnAlignmentChanged)] HRESULT OnAlignmentChanged([in] ICogoModel* cm,[in] CogoObjectID id,[in] IAlignment* alignment);

       /// Called when an alignment is added to a model
       [helpstring("event OnAlignmentAdded"),helpcontext(IDH_CogoModel_OnAlignmentAdded)] HRESULT OnAlignmentAdded([in] ICogoModel* cm,[in] CogoObjectID id,[in] IAlignment* alignment);

       /// Called when an alignment is removed from a model
       [helpstring("event OnAlignmentRemoved"),helpcontext(IDH_CogoModel_OnAlignmentRemoved)] HRESULT OnAlignmentRemoved([in] ICogoModel* cm,[in] CogoObjectID id);

       /// Called when the alignments in a model are cleared
       [helpstring("event OnAlignmentCleared"),helpcontext(IDH_CogoModel_OnAlignmentCleared)] HRESULT OnAlignmentsCleared([in] ICogoModel* cm);
       
       /// Called when a path in a model changes
       [helpstring("event OnPathChanged"),helpcontext(IDH_CogoModel_OnPathChanged)] HRESULT OnPathChanged([in] ICogoModel* cm,[in] CogoObjectID id,[in] IPath* path);

       /// Called when a path is added to a model
       [helpstring("event OnPathAdded"),helpcontext(IDH_CogoModel_OnPathAdded)] HRESULT OnPathAdded([in] ICogoModel* cm,[in] CogoObjectID id,[in] IPath* path);

       /// Called when a path is removed from a model
       [helpstring("event OnPathRemoved"),helpcontext(IDH_CogoModel_OnPathRemoved)] HRESULT OnPathRemoved([in] ICogoModel* cm,[in] CogoObjectID id);

       /// Called when the paths in a model are cleared
       [helpstring("event OnPathCleared"),helpcontext(IDH_CogoModel_OnPathCleared)] HRESULT OnPathsCleared([in] ICogoModel* cm);
   };

   /////////////////////////////////////////////////////////////

   /// An object that implements the IAngle interface
   [
        uuid(10F574FD-5735-11D3-898C-006097C68A9C),
		helpcontext(IDH_Angle),
        helpstring("Angle Class")
    ]
    coclass Angle
    {
        [default] interface IAngle;
        interface IStructuredStorage2;
        // interface IPersist;
    };

    /// An object that implements the IDirection interface
    [
        uuid(10F574FB-5735-11D3-898C-006097C68A9C),
		helpcontext(IDH_Direction),
        helpstring("Direction Class")
    ]
    coclass Direction
    {
        [default] interface IDirection;
        interface IStructuredStorage2;
        // interface IPersist;
    };

    /// Object defining a collection of Point2d objects
    ///
    /// Implements the IPointCollection interface and fires events through the IPointCollectionEvents interface
   [
       uuid(5559C9A6-5C16-11D5-8C31-006097C68A9C),
	   helpcontext(IDH_PointCollection),
       helpstring("PointCollection Class")
   ]
   coclass PointCollection
   {
       [default] interface IPointCollection;
       [default, source] interface IPointCollectionEvents;
      interface IStructuredStorage2;
        // interface IPersist;
   };

   /// Object defining a collection of LineSegment2d objects
   ///
   /// Implements the ILineSegmentCollection interface and fires events through the ILineSegmentCollectionEvents interface
   [
       uuid(9E0F9B9E-99C9-40A8-9C08-47E6ACD762E9),
	   helpcontext(IDH_LineSegmentCollection),
       helpstring("LineSegmentCollection Class")
   ]
   coclass LineSegmentCollection
   {
       [default] interface ILineSegmentCollection;
       [default, source] interface ILineSegmentCollectionEvents;
      interface IStructuredStorage2;
        // interface IPersist;
   };

   /// A coordinate geometry model object.
   ///
   /// A CogoModel stores, creates, and manages coordinate geometry elements such as Points LineSegments, Paths, and Alignments
   ///
   /// Implements the ICogoModel interface and fires events through the ICogoModelEvents interface.
   /// Also implements the IMeasure, ILocate, IIntersect, IProject, IDivide, and ITangent interfaces.
   [
       uuid(07E3C485-573F-11D3-8CDF-BAAC148B6002),
	   helpcontext(IDH_CogoModel),
       helpstring("CogoModel Class")
   ]
   coclass CogoModel
   {
       [default] interface ICogoModel;
       interface IMeasure;
       interface ILocate;
       interface IIntersect;
     interface IProject;
     interface IDivide;
     interface ITangent;
       [default, source] interface ICogoModelEvents;
      interface IStructuredStorage2;
        // interface IPersist;
   };

   /// A computation engine for performing coordinate geometry analysis
   ///
   /// Implements the ICogoEngine interface.
   /// Also implements the IMeasure2, ILocate2, IIntersect2, IProject2, IDivide2, and ITangent2 interfaces.
   [
      uuid(C7E7D393-7C90-4AF5-88DF-A761FA3BCE19),
      helpstring("CogoEngine Class")
   ]
   coclass CogoEngine
   {
      [default] interface ICogoEngine;
      interface IMeasure2;
      interface ILocate2;
      interface IIntersect2;
      interface IProject2;
      interface IDivide2;
      interface ITangent2;
   };

   /// A object defining a point on a vertical profile
   ///
   /// Implements the IProfilePoint interface and fires events through the IProfilePointEvents interface
   [
       uuid(849FD333-4FC9-4093-93F6-FBEC311FF45A),
	   helpcontext(IDH_ProfilePoint),
       helpstring("ProfilePoint Class")
   ]
   coclass ProfilePoint
   {
       [default] interface IProfilePoint;
       [default, source] interface IProfilePointEvents;
       interface IStructuredStorage2;
        // interface IPersist;
   };

   /// Object defining a collection of ProfilePoint objects
   ///
   /// Implements the IProfilePointCollection interface and fires events through the IProfilePointCollectionEvents interface
   [
       uuid(3B3D6F38-F5B7-4621-B276-5421717846E2),
	   helpcontext(IDH_ProfilePointCollection),
       helpstring("ProfilePointCollection Class")
   ]
   coclass ProfilePointCollection
   {
       [default] interface IProfilePointCollection;
       [default, source] interface IProfilePointCollectionEvents;
      interface IStructuredStorage2;
        // interface IPersist;
   };

   /// A horizontal curve object.
   ///
   /// Implements the IVertCurve interface and fires events through the IVertCurveEvents interface.
   [
       uuid(7581BC4E-4E7C-4761-B59E-2D75EA2E1120),
	   helpcontext(IDH_VertCurve),
       helpstring("VertCurve Class")
   ]
   coclass VertCurve
   {
       [default] interface IVertCurve;
       [default, source] interface IVertCurveEvents;
       interface IStructuredStorage2;
        // interface IPersist;
   };

   /// Object defining a collection of VertCurve objects
   ///
   /// Implements the IVertCurveCollection interface and fires events through the IVertCurveCollectionEvents interface
   [
       uuid(D6732CA5-6E4F-45FE-A4FC-B0E8A94667FA),
	   helpcontext(IDH_VertCurveCollection),
       helpstring("VertCurveCollection Class")
   ]
   coclass VertCurveCollection
   {
       [default] interface IVertCurveCollection;
       [default, source] interface IVertCurveCollectionEvents;
      interface IStructuredStorage2;
        // interface IPersist;
   };

   /// A horizontal curve object.
   ///
   /// Implements the IHorzCurve interface and fires events through the IHorzCurveEvents interface.
   [
       uuid(61454EB9-8040-4B74-9429-B09D1FF1E0BB),
	   helpcontext(IDH_HorzCurve),
       helpstring("HorzCurve Class")
   ]
   coclass HorzCurve
   {
       [default] interface IHorzCurve;
       [default, source] interface IHorzCurveEvents;
       interface IStructuredStorage2;
        // interface IPersist;
   };

   /// Object defining a collection of HorzCurve objects
   ///
   /// Implements the IHorzCurveCollection interface and fires events through the IHorzCurveCollectionEvents interface
   [
		uuid(2C4945D1-9B56-430C-B395-B07209328C59),
		helpcontext(IDH_HorzCurveCollection),
		helpstring("HorzCurveCollection Class")
	]
	coclass HorzCurveCollection
	{
		[default] interface IHorzCurveCollection;
		[default, source] interface IHorzCurveCollectionEvents;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// Object defining a piecewise clamped cublic spline.
   ///
   /// A clamped cubic spline is a numerical approximation of a complex curve defined by a series of points on the curve and the tangent slopes at the start and end of the curve.
   /// \image html /CubicSpline/ClampedCubicSpline.png
   /// Implements the ICubicSpline interface and fires events thorugh the ICubicSplineEvents interface.
   [
       uuid(69706DA8-D10D-4932-A566-69DE35CAF30F),
	   //helpcontext(IDH_CubicSpline),
       helpstring("CubicSpline Class")
   ]
   coclass CubicSpline
   {
       [default] interface ICubicSpline;
		[default, source] interface ICubicSplineEvents;
       interface IStructuredStorage2;
        // interface IPersist;
   };

   /// An object that represents an element of a profile
   ///
   /// ProfileElement objects are ProfilePoint and VertCurve objects. 
   ///
   /// Implements the IProfileElement interface and fires events through the IProfileElementEvents interface.
   [
		uuid(80AC919F-D882-4C24-9E6D-721D90925FEE),
		helpcontext(IDH_ProfileElement),
		helpstring("ProfileElement Class")
	]
	coclass ProfileElement
	{
		[default] interface IProfileElement;
		[default, source] interface IProfileElementEvents;
      interface IStructuredStorage2;
	   // interface IPersist;
   };

   /// An object that represents an alignment profile. A profile can be a roadway profile, profile of an underground utility, or other such items associated with an alignment.
   ///
   /// A Profile consists of ProfileElement objects, which are ProfilePoint and VertCurve objects. 
   /// ProfileElement objects are positioned end to end in the order they are defined. Straight lines are used to connect the ProfileElement objects together. 
   /// The tangents at the beginning and end of the profile are projected as straight lines.
   /// If a Profile does not contain any ProfileElement objects, it is assumed that the profile is at a constant elevation of 0.00.
   ///
   /// Implements the IProfile interface and fires events through the IProfileEvents interface.
   [
		uuid(7FD9C064-1A8C-4853-B1CC-24D9C877406F),
		helpcontext(IDH_Profile),
		helpstring("Profile Class")
	]
	coclass Profile
	{
		[default] interface IProfile;
		[default, source] interface IProfileEvents;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// An object that represents a widening or narrowing in the roadway surface, such as adding a lane.
   ///
   /// A widening is applied as modifier to a Surface object.
   ///
   /// Implements the IWidening interface and fires events through the IWideningEvents interface.
   [
      uuid(3B817FBD-D099-49a2-8E43-E90F49A8B5B8),
      //helpcontext(IDH_Widening),
      helpstring("Widening Class")
   ]
   coclass Widening
   {
      [default] interface IWidening;
      [default,source] interface IWideningEvents;
      interface IStructuredStorage2;
   };

   /// Object defining a collection of Widening objects
   ///
   /// Implements the IWideningCollection interface and fires events through the IWideningCollectionEvents interface  
   [
      uuid(9AD670B4-C5FE-4639-A714-67008906B54D),
      //helpcontext(IDH_WideningCollection),
      helpstring("WideningCollection Class")
   ]
   coclass WideningCollection
   {
      [default] interface IWideningCollection;
      [default,source] interface IWideningCollectionEvents;
      interface IStructuredStorage2;
   };

   /// An object that represents a superelevation as would occur at a curve in the alignment.
   ///
   /// A superelevation is applied as modifier to a Surface object.
   ///
   /// Implements the ISuperelevation interface and fires events through the ISuperelevationEvents interface.
   [
      uuid(9D3C25CB-61D1-466e-AE30-1FD5C460D50B),
      //helpcontext(IDH_Superelevation),
      helpstring("Superelevation Class")
   ]
   coclass Superelevation
   {
      [default] interface ISuperelevation;
      [default,source] interface ISuperelevationEvents;
      interface IStructuredStorage2;
   };

   /// Object defining a collection of Superelevation objects
   ///
   /// Implements the ISuperelevationCollection interface and fires events through the ISuperelevationCollectionEvents interface  
   [
      uuid(981C286A-8B4B-4be9-BB9D-E927FFFF680C),
      //helpcontext(IDH_SuperelevationCollection),
      helpstring("SuperelevationCollection Class")
   ]
   coclass SuperelevationCollection
   {
      [default] interface ISuperelevationCollection;
      [default,source] interface ISuperelevationCollectionEvents;
      interface IStructuredStorage2;
   };

   /// An object the represents a segment in a SurfaceTemplate.
   ///
   /// Implements the ITemplateSegment interface and fires events through the ITemplateSegmentEvents interface.
   [
      uuid(B853F944-3791-4f03-AC3C-547C71B74743),
      //helpcontext(IDH_TemplateSegment),
      helpstring("TemplateSegment Class")
   ]
   coclass TemplateSegment
   {
      [default] interface ITemplateSegment;
      [default,source] interface ITemplateSegmentEvents;
      interface IStructuredStorage2;
   };

   /// An object that represents a cross section template for a Surface. 
   ///
   /// A SurfaceTemplate differs from a SurfaceProfile in that it represents a cross section cut through a surface normal to the associated alignment.
   /// A SurfaceTemplate is defined by a sequence of TemplateSegment objects where a SurfaceProfile is defined by a sequence of SurfacePoint objects.
   ///
   /// Implements the ISurfaceTemplate interface and fires events through the ISurfaceTemplateEvents interface
   [
      uuid(A479017E-BFE5-4e1e-B41D-E7BBF2534F52),
      //helpcontext(IDH_SurfaceTemplate),
      helpstring("SurfaceTemplate Class")
   ]
   coclass SurfaceTemplate
   {
      [default] interface ISurfaceTemplate;
      [default,source] interface ISurfaceTemplateEvents;
      interface IStructuredStorage2;
   };

   /// Object defining a collection of SurfaceTemplate objects
   ///
   /// Implements the ISurfaceTemplateCollection interface and fires events through the ISurfaceTemplateCollectionEvents interface
   [
      uuid(D3148A9A-D53F-45d0-A0B7-A03EE35A36F3),
      //helpcontext(IDH_SurfaceTemplateCollection),
      helpstring("SurfaceTemplateCollection Class")
   ]
   coclass SurfaceTemplateCollection
   {
      [default] interface ISurfaceTemplateCollection;
      [default,source] interface ISurfaceTemplateCollectionEvents;
      interface IStructuredStorage2;
   };

   /// An object that represents the surface, such as a roadway surface, associated with a Profile.
   ///
   /// A Surface is defined by collection of SurfaceTemplate objects and modified by Superelevation and Widening objects.
   ///
   /// Implements the ISurface interface and fires events through the ISurfaceEvents interface.
   [
      uuid(B8A4A5A2-A456-4161-9276-669D92B9FC5C),
      //helpcontext(IDH_Surface),
      helpstring("Surface Class")
   ]
   coclass Surface
   {
      [default] interface ISurface;
      [default,source] interface ISurfaceEvents;
      interface IStructuredStorage2;
   };

   /// Object defining a collection of Suirface objects
   ///
   /// Implements the ISurfaceCollection interface and fires events through the ISurfaceCollectionEvents interface
   [
      uuid(A0AE194C-0D1D-4acb-8514-85E4B77DD326),
      //helpcontext(IDH_SurfaceCollection),
      helpstring("SurfaceCollection Class")
   ]
   coclass SurfaceCollection
   {
      [default] interface ISurfaceCollection;
      [default,source] interface ISurfaceCollectionEvents;
      interface IStructuredStorage2;
   };

   /// An object that represents a roadway, highway or other construction alignment.
   ///
   /// An alignment consists of PathElement objects, which are: Point2d objects, LineSegment2d objects, CubicSpline objects, and HorzCurve objects. 
   /// PathElement objects are positioned end to end in the order they are defined. Straight lines are used to connect the PathElement objects together. 
   /// The tangents at the beginning and end of the path are projected as straight lines.
   /// If an Alignment does not contain any PathElement objects, it is assumed that it begins at Station 0+00, point N 0.00, E 0.00, and is a straight line bearing N 90 E.
   ///
   /// Implements the IAlignment interface and fires events through the IAlignmentEvents interface.
   [
		uuid(B46F91AB-53C2-4ECC-8E7F-55AFA0F67C2F),
		helpcontext(IDH_Alignment),
		helpstring("Alignment Class")
	]
	coclass Alignment
	{
		[default] interface IAlignment;
		[default, source] interface IAlignmentEvents;
      interface IStructuredStorage2;
        // interface IPersist;
	};
   
   /// Object defining a collection of Alignment objects
   ///
   /// Implements the IAlignmentCollection interface and fires events through the IAlignmentCollectionEvents interface
   [
		uuid(9B77429D-4A92-4ddd-BAFA-4330EEAF167C),
		helpcontext(IDH_AlignmentCollection),
		helpstring("AlignmentCollection Class")
	]
	coclass AlignmentCollection
	{
		[default] interface IAlignmentCollection;
		[default, source] interface IAlignmentCollectionEvents;
        interface IStructuredStorage2;
        // interface IPersist;
   };


   /// An object that represents a geometric element of a path.
   ///
   /// PathElement objects are: Point2d, LineSegment2d, CubicSpline, and HorzCurve objects. 
   ///
   /// Implements the IPathElement interface and fires events through the IPathElementEvents interface.
   [
      uuid(B21FFF37-F9A2-4DA0-8226-C5C3604E8262),
      helpcontext(IDH_PathElement),
      helpstring("PathElement Class")
   ]
   coclass PathElement
   {
      [default] interface IPathElement;
      [default, source] interface IPathElementEvents;
      interface IStructuredStorage2;
      // interface IPersist;
   };

   /// An object that represents a geometric path in plan view. 
   ///
   /// A path consists of PathElement objects, which are: Point2d objects, LineSegment2d objects, CubicSpline objects, and HorzCurve objects. 
   /// PathElement objects are positioned end to end in the order they are defined. Straight lines are used to connect the PathElement objects together. 
   /// The tangents at the beginning and end of the path are projected as straight lines.
   /// If a Path does not contain any PathElement objects, it is assumed that the path begins at N 0.00, E 0.00, and is a straight line bearing N 90 E.
   ///
   /// Implements the IPath interface and fires events through the IPathEvents interface.
   [
		uuid(4A138368-CF5F-4a12-BC2D-224FC85E8B8D),
		helpcontext(IDH_Path),
		helpstring("Path Class")
	]
	coclass Path
	{
		[default] interface IPath;
		[default, source] interface IPathEvents;
      interface IStructuredStorage2;
        // interface IPersist;
	};
   
   /// Object defining a collection of Path objects
   ///
   /// Implements the IPathCollection interface and fires events through the IPathCollectionEvents interface
   [
		uuid(BB37DF4F-8AD0-4778-9036-9A340F425A50),
		helpcontext(IDH_PathCollection),
		helpstring("PathCollection Class")
	]
	coclass PathCollection
	{
		[default] interface IPathCollection;
		[default, source] interface IPathCollectionEvents;
        interface IStructuredStorage2;
        // interface IPersist;
   };

   /// A vertical curve factory object.
   ///
   /// Implements the IVertCurveFactory interface.
   [
		uuid(B61E5354-A04C-439D-9661-309897677112),
		helpcontext(IDH_VertCurveFactory),
		helpstring("VertCurveFactory Class")
	]
	coclass VertCurveFactory
	{
		[default] interface IVertCurveFactory;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// A profile point factory object.
   ///
   /// Implements the IProfilePointFactory interface.
   [
		uuid(43AB1FB8-3A38-40FE-99A1-8CA49982037D),
		helpcontext(IDH_ProfilePointFactory),
		helpstring("ProfilePointFactory Class")
	]
	coclass ProfilePointFactory
	{
		[default] interface IProfilePointFactory;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// A horizontal curve factory object.
   ///
   /// Implements the IHorzCurveFactory interface.
   [
		uuid(FC1BF8D1-D732-4C86-B98C-4B08E3C9E61E),
		helpcontext(IDH_HorzCurveFactory),
		helpstring("HorzCurveFactory Class")
	]
	coclass HorzCurveFactory
	{
		[default] interface IHorzCurveFactory;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// A path factory object.
   ///
   /// Implements the IPathFactory interface.
   [
		uuid(016F7CE4-7013-47db-88EA-BBF0EA82AA30),
		helpcontext(IDH_PathFactory),
		helpstring("PathFactory Class")
	]
	coclass PathFactory
	{
		[default] interface IPathFactory;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// A alignment factory object.
   ///
   /// Implements the IAlignmentFactory interface.
   [
		uuid(302F2E74-E561-4275-8C4E-3451EC5FD757),
		helpcontext(IDH_AlignmentFactory),
		helpstring("AlignmentFactory Class")
	]
	coclass AlignmentFactory
	{
		[default] interface IAlignmentFactory;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// An object that converts angular measure values into formatted text strings.
   ///
   /// Implements the IAngleDisplayUnitFormatter interface.
	[
		uuid(0E8ADC7B-54A5-45FC-AA79-56BBE528FA47),
		helpcontext(IDH_AngleDisplayUnitFormatter),
		helpstring("AngleDisplayUnitFormatter Class")
	]
	coclass AngleDisplayUnitFormatter
	{
		[default] interface IAngleDisplayUnitFormatter;
		[default, source] interface IDisplayUnitFormatterEvents;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// An object that converts angular measure values representing a direction into formatted text strings.
   ///
   /// Implements the IDirectionDisplayUnitFormatter interface.
   [
		uuid(50A4E50C-B7A8-4177-AB25-83D4E783B7A3),
		helpcontext(IDH_DirectionDisplayUnitFormatter),
		helpstring("DirectionDisplayUnitFormatter Class")
	]
	coclass DirectionDisplayUnitFormatter
	{
		[default] interface IDirectionDisplayUnitFormatter;
		[default, source] interface IDisplayUnitFormatterEvents;
      interface IStructuredStorage2;
        // interface IPersist;
	};

   /// A point factory object.
   ///
   /// Implements the IPointFactory interface.
   [
      uuid(F0151EC9-C520-4ec7-9581-35FC1685FAAB),
      helpstring("PointFactory Class")
   ]
   coclass PointFactory
   {
      [default] interface IPoint2dFactory;
      interface IStructuredStorage2;
        // interface IPersist;
   };

   /// A line segment factory object.
   ///
   /// Implements the ILineSegment2dFactory interface.
   [
      uuid(B290D560-4DFC-404c-8CAF-CFBFE211234D),
      helpstring("LineSegmentFactory Class")
   ]
   coclass LineSegmentFactory
   {
      [default] interface ILineSegment2dFactory;
      interface IStructuredStorage2;
        // interface IPersist;
   };

   /// An object the represents a station along an alignment.
   ///
   /// Implements the IStation interface and fires events through the IStationEvents interface.
	[
		uuid(4C22AA8F-6739-49DD-B6DF-FDCD352FF969),
		helpstring("Station Class")
	]
	coclass Station
	{
		[default] interface IStation;
      [default,source] interface IStationEvents;
	};

   /// An non-creatable object the represents a station equation. StationEquation objects must be created in a StationEquationCollection.
   ///
   /// Implements the IStationEquation interface.
   [
		uuid(ABC35194-EDA2-4fa3-AC6B-B58A5F0C2385),
      noncreatable,
		helpstring("StationEquation Class")
   ]
   coclass StationEquation
   {
		[default] interface IStationEquation;
   };

   /// A collection of station equation objects.
   ///
   /// Implements the IStationEquationCollection interface and fires events through the IStationEquationCollectionEvents interface.
   [
		uuid(000FDA40-7B33-4354-8ADF-9E28D4EEE2D3),
		helpstring("StationEquationCollection Class")
   ]
   coclass StationEquationCollection
   {
		[default] interface IStationEquationCollection;
      [default,source] interface IStationEquationCollectionEvents;
   };

   /// An object that represents a point in a SurfaceProfile.
   ///
   /// Implements the ISurfacePoint interface.
   [
      uuid(D83C292A-4677-46ef-BEF2-CF9444A5D8E5),
      helpstring("SurfacePoint Class")
   ]
   coclass SurfacePoint
   {
      [default] interface ISurfacePoint;
   };

   /// An object that represents a cross section template for a Surface. 
   ///
   /// A SurfaceProfile differs from a SurfaceTemplate in that it represents a cross section cut through a surface at an arbritary orientation.
   /// A SurfaceProfile is defined by a sequence of SurfacePoint objects where a SurfaceTemplate is defined by a sequence of TemplateSegments.
   ///
   /// Implements the ISurfaceProfile interface
   [
      uuid(1B216215-3EEC-407e-BBEC-52BB0C0FBCBD),
      helpstring("SurfaceProfile Class")
   ]
   coclass SurfaceProfile
   {
      [default] interface ISurfaceProfile;
   };
};
